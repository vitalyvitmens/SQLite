# TODO: Python for Finance (Python для финансов)
#  В Python есть множество пакетов, особенно полезных при работе с финансовыми данными.
#  В этом курсе мы узнаем, как Python можно использовать в финансах для решения различных проблем и проведения
#  финансового анализа. Кроме того, в качестве практического проекта мы создадим программу для анализа цены биткойнов!
import data as data
import yfinance

# TODO: Welcome (Добро пожаловать)
#  Умение программировать действительно полезно для многих дисциплин, включая финансы.
#  С его помощью можно легко получать финансовые данные, рассчитывать метрики, генерировать отчеты,
#  автоматизировать различные задачи и проводить финансовый анализ.
#  В этом курсе мы узнаем, как Python можно использовать в финансах для решения различных финансовых проблем.
#  В качестве предварительного условия для этого курса мы ожидаем, что вы знаете основы финансов.
#  Мы также рассмотрим различные концепции Python, прежде чем показать их в действии.

# TODO: Why Python (Почему Python)
#  Python — один из самых популярных языков программирования в мире,
#  так как он прост в освоении и имеет простой синтаксис.
#  Например, вот код, используемый для вычисления и вывода результата умножения 123 на 456:
# print(123 * 456)

# TODO: Output (Выход)
#  Оператор печати используется для генерации вывода.
#  Это может быть число, текст или результат вычисления:
#  За оператором печати всегда следуют круглые скобки, содержащие вывод, который мы хотим сгенерировать.
# print(42)

# TODO: Printing Text (Печать текста)
#  При печати текста его необходимо заключать в одинарные или двойные кавычки.
#  Текст в кавычках называется строкой.
#  Кавычки, окружающие текст, должны быть одинаковыми: либо одинарными, либо двойными.
# print("Python is cool")

# TODO: Обратите внимание, что оператор печати заключает текст, который мы хотим вывести, в круглые скобки.
#  Всегда не забывайте закрывать открытые скобки — без них оператор печати не будет работать.
# print("Welcome")

# TODO: Projects (Проекты)
#  В ходе этого курса мы изучим основы Python, используя его для решения нескольких
#  реальных финансовых проблем и выполнения расчетов.
#  Вот некоторые из проектов, которые мы рассмотрим:
#  - Расчет основных финансовых показателей
#  - Построение графиков на основе финансовых данных
#  - Получение и анализ цен на акции
#  - Выполнение финансового анализа акций и портфелей, включая доходность акций, корреляции, анализ рисков
#  - Оптимизация портфеля с использованием моделирования Монте-Карло
#  В качестве практического проекта мы создадим программу для анализа цены биткойнов!
#  Навыки, полученные в ходе этого курса, могут быть использованы для решения множества различных финансовых проблем,
#  создания отчетов и помощи в принятии решений.

# TODO: ЗАДАЧА: Начиная
#  Давайте практиковаться, кодируя по-настоящему!
#  Мы начнем с простого вывода текста, чтобы познакомить вас со средой Code Playground,
#  чтобы вы могли написать свой первый настоящий код.
#  Задание Исправьте программу для вывода цитаты:
#  Инвестиции в знания окупаются с наибольшей выгодой.
# print('An investment in knowledge pays the best interest.')

# TODO: Simple Operations (Простые операции)
#  Python также может выполнять вычисления. Мы можем ввести его прямо в оператор печати,
#  например:
# print(2 + 2)
# print(5 + 4 - 3)

# TODO: Multiplication (Умножение)
#  Умножение выполняется с помощью символа звездочки * :
# print(12 * 64)

# TODO: Division (Разделение)
#  Деление осуществляется с помощью косой черты:
#  Использование одной косой черты для деления чисел всегда дает десятичное число (или число с плавающей запятой,
#  как это называется в программировании), даже если результатом является целое число.
# print(100 / 2)

# TODO: Simple Operations (Простые операции)
#  Как и в обычной математике, мы можем использовать круглые скобки, чтобы указать операции, которые мы хотим
#  выполнить в первую очередь (но нам все еще нужно включить те, которые находятся вокруг оператора!).
#  Как это: Не забудьте закрыть все открывающие скобки соответствующими закрывающими скобками.
# print(2 * (3 + 4))

# TODO: Simple Operations (Простые операции)
#  Одна из замечательных особенностей Python заключается в том, что он может выполнять операции с
#  действительно большими числами. Например, посчитаем 123456789 умножить на 12345:
# print(123456789 * 12345)

# TODO: Exponentiation (Возведение в степень)
#  Две звездочки ** используются для возведения числа в степень другого, что называется возведением в степень.
#  Например:
# print(2 ** 5)

# TODO: Inflation (Инфляция)
#  Нам нужно рассчитать, сколько будет стоить вещь стоимостью 8000 долларов сегодня через 10 лет, если
#  годовой уровень инфляции составит 5%. Подсказка: используйте следующую формулу для расчета будущей стоимости:
#  текущая стоимость * (1+уровень инфляции) ** годы.
#  Обратите внимание, что уровень инфляции должен быть выражен в виде десятичной дроби,
#  поэтому 5% соответствует значению 0,05 . Напишите программу для расчета и выведите результат.
#  Используйте формулу в операторе печати с заданными значениями.
# print(8000 * (1 + 0.05) ** 10)

# TODO: Variables (Переменные)
#  Переменная позволяет хранить значение, присваивая ему имя.
#  Имя можно использовать для ссылки на значение позже в программе.
#  Например, вы можете использовать переменную для хранения цены акции и выполнения с ней различных расчетов.
#  Чтобы присвоить переменную, используйте один знак равенства.
#  В приведенном ниже примере мы присвоили значение 412.8 переменной с именем price.
# price = 412.8

# TODO: Working with Variables (Работа с переменными)
#  Итак, вы получили свою переменную и назвали ее.
#  Теперь вы можете использовать её для выполнения соответствующих операций точно так же, как с числами и строками,
#  например:
# price = 412.8
#
# print(price * 2)
# print(price / 2)

# TODO: Operators (Операторы)
#  У вас может быть несколько переменных.
#  Давайте используем две переменные с именами x и y для выполнения всех распространенных числовых операций в Python:
#  Python позволяет выполнять вычисления с действительно большими числами!
#  Попробуйте изменить код, чтобы использовать два очень больших числа для x и y.
# x = 9
# y = 5
#
# # multiplication
# print(x * y)
#
# # division
# print(x / y)
#
# # exponentiation: raise one number to the power of another
# print(x ** y)
#
# # Quotient: the quantity produced by the division of two numbers.
# print(x // y)
#
# # remainder
# print(x % y)

# TODO: Variables (Переменные)
#  Переменные можно переназначать сколько угодно раз, например:
# x = 8
# print(x)
# x = 41
# print(x + 1)

# TODO: Variable Names (Имена переменных)
#  Именование ваших переменных довольно гибкое. Вы можете использовать буквы, цифры и символы подчеркивания в именах
#  переменных, однако вы не можете использовать специальные символы или начинать имя с цифры.
#  Помните, что Python — это язык, чувствительный к регистру.
#  Это означает, что Lastname и lastname — это два разных имени переменной.

# TODO: ЗАДАЧА: Коэффициент цена/прибыль
#  Нам нужно рассчитать и вывести соотношение цены и прибыли (P/E) компании.
#  P/E — это цена акций компании, деленная на EPS (прибыль на акцию).
#  Цена акций компании и средняя прибыль на акцию за последние 12 месяцев хранятся в соответствующих переменных.
#  Используйте эти значения, чтобы рассчитать соотношение P/E для компании,
#  сохраните его в переменной с именем pe и выведите его значение.
#  Сначала определите переменную с именем pe, назначьте ей формулу соотношения цена/прибыль,
#  а затем используйте ее в операторе печати.
# price = 160.8
# eps = 3.42
# pe = price / eps
# print(pe)

# TODO: Arrays (Массивы)
#  В финансах мы в основном имеем дело с несколькими значениями,
#  такими как ежедневные цены на акции, цены на жилье и т.д.
#  Вместо объявления отдельных переменных для каждого значения мы можем использовать массив!
#  Массив позволяет хранить несколько значений в одной переменной.
#  Например, объявим массив цен:
#  Как видите, массив присваивается переменной, которая хранит несколько значений.
#  Элементы массива разделяются запятыми.
# prices = [42.8, 102.03, 240.38, 80.9]
# print(prices)

# TODO: Arrays (Массивы)
#  Если вы хотите получить доступ к определенному элементу в массиве, вы можете сделать это,
#  используя его индекс в квадратных скобках. В нашем примере это будет выглядеть так:
#  Индекс первого элемента списка равен 0, а не 1, как можно было ожидать.
# prices = [42.8, 102.03, 240.38, 80.9]
#
# print(prices[0])
# print(prices[1])
# print(prices[2])

# TODO: Arrays (Массивы)
#  Вы можете использовать значения массива в вычислениях.
#  Например, добавим первые два элемента и выведем результат:
#  Мы сохранили результат в переменной res и использовали ее в выводе.
# prices = [42.8, 102.03, 240.38, 80.9]
#
# res = prices[0] + prices[1]
# print(res)

# TODO: Arrays (Массивы)
#  Python имеет много полезных функций.
#  Например, функция max позволяет найти наибольшее значение в массиве:
#  Обратите внимание, что нам нужны круглые скобки после ключевого слова max вокруг массива цен.
#  Мы узнаем больше о функции в следующем модуле.
# prices = [42.8, 102.03, 240.38, 80.9]
# print(max(prices))

# TODO: Arrays (Массивы)
#  Точно так же функцию min можно использовать для поиска наименьшего значения в массиве:
# prices = [42.8, 102.03, 240.38, 80.9]
# print(min(prices))

# TODO: Arrays (Массивы)
#  В качестве примера программы давайте найдем среднее значение массива.
#  Среднее значение представляет собой сумму всех значений, деленную на их количество.
#  Мы можем найти сумму всех значений с помощью функции sum() и их количество с помощью len():
#  Приведенный ниже код вычисляет и выводит среднее значение массива цен.
#  О многих других полезных и продвинутых функциях мы узнаем в следующем модуле.
# prices = [42.8, 102.03, 240.38, 80.9]
# res = sum(prices) / len(prices)
# print(res)

# TODO: ЗАДАЧА: Average Revenue (Средний доход)
#  Данный код объявляет массив, в котором хранятся ежемесячные доходы компании за 12 месяцев.
#  Каждое значение соответствует месяцу, первое значение — январь, второе — февраль и т.д.
#  Вам необходимо рассчитать и вывести среднемесячный доход компании за этот год.
#  Подсказка: используйте функцию sum(),
#  чтобы вычислить сумму всех значений массива и разделить ее на количество значений.
# revenue = [125000, 200000, 150000, 175000, 162000, 120000, 98000, 105400, 198000, 202500, 97000, 220500]
# res = sum(revenue) / len(revenue)
# print(res)

# TODO: Function (Функция)
#  Важным понятием в программировании являются функции.
#  Функция — это группа связанных операторов, которая выполняет определенную задачу.
#  Например, функция печати, которую мы видели, используется для генерации вывода:
# print("Hello")

# TODO: Functions (Функции)
#  Слова перед скобками - это имена функций,
#  а значения внутри скобок - аргументы функции (также называемые параметрами).
#  В нашем примере print — это имя функции, а «Hello» — ее аргумент.
# print("Hello")

# TODO: Arguments (Аргументы)
#  Мы видели функции в действии в предыдущем модуле при вычислении минимума/максимума/суммы массива.
#  Функция также может иметь несколько аргументов, которые должны быть разделены запятыми.
#  Например:
#  Функцию max() также можно использовать для нахождения максимального значения из ее аргументов.
# x = max(4, 8, 1)
# print(x)

# TODO: Function (Функция)
#  Чтобы использовать функцию в нашем коде, нам нужно "вызвать" ее.
#  Вы вызываете функцию, используя ее имя, за которым следуют круглые скобки, заключающие аргументы.
#  Например, мы вызываем функцию печати со строковым аргументом для генерации вывода:
# print("some text")

# TODO: Functions (Функции)
#  В некоторых ситуациях нам нужно создать собственную функцию и использовать ее в нашем коде.
#  Это можно сделать с помощью ключевого слова def.
#  Вот пример функции с именем avg(), которая вычисляет и выводит среднее значение своего массива аргументов:
#  Обратите внимание на двоеточие: после имени функции. Это обязательная часть синтаксиса.
# def avg(x):
#     res = sum(x) / len(x)
#     print(res)
#
#
# a = [1, 2, 3, 4, 5, 6, 7, 8, 10]
# avg(a)

# TODO: Functions (Функции)
#  Теперь мы можем вызвать нашу функцию для любого массива в нашем коде и увидеть результат:
#  Python использует отступы white tab at the beginning of a line
#  (белая вкладка в начале строки) для разделения блоков кода.
#  В зависимости от логики программы отступ может быть обязательным.
#  Как видите, код внутри функции должен иметь отступ.
# def avg(x):
#     res = sum(x) / len(x)
#     print(res)
#
#
# prices = [42.8, 102.03, 240.38, 80.9]
# avg(prices)

# TODO: Functions (Функции)
#  Мы можем вызывать нашу функцию avg() столько раз, сколько захотим, с разными аргументами:
# def avg(x):
#     res = sum(x) / len(x)
#     print(res)
#
#
# prices = [42.8, 102.03, 240.38, 80.9]
# avg(prices)
#
# x = [1, 2, 3, 4, 5]
# avg(x)

# TODO: Functions (Функции)
#  В нашем примере функция использовала print для вывода результата.
#  В некоторых ситуациях нам нужно иметь возможность присваивать и использовать значение нашей функции.
#  Для этого вместо print мы можем использовать ключевое слово return в нашей функции:
# def avg(x):
#     res = sum(x) / len(x)
#     return res
# TODO: Это позволяет нам сделать следующее:
# def avg(x):
#     res = sum(x) / len(x)
#     return res
#
#
# prices = [42.8, 102.03, 240.38, 80.9]
# a = avg(prices)
# print(a)

# TODO: ЗАДАЧА: Median Value (Среднее значение)
#  Вам дан список цен на дома в районе, отсортированный в порядке возрастания.
#  В списке нечетное количество домов.
#  Создайте функцию, которая вычисляет и возвращает среднюю цену дома.
#  Данный код определяет и вызывает функцию с именем "median()".
#  Завершите его определение, чтобы вычислить и вернуть медианное значение массива аргументов.
#  Подсказка: Поскольку количество домов нечетное, мы можем взять средний элемент массива,
#  который будет представлять медианное значение.
#  Для этого разделите количество элементов в массиве на 2. В результате получится индекс среднего элемента,
#  например:
#      index = len(arr) // 2
#      return arr[index]
#  Обратите внимание, что нам нужно использовать оператор //,
#  который представляет собой деление на пол, в результате чего получается целое число.
# prices = [75000, 95000, 98000, 109000, 135500, 185000, 199000, 249000, 255000, 280000, 299000, 330000, 380000]
#
#
# def median(arr):
#     index = len(arr) // 2
#     return arr[index]
#
#
# res = median(prices)
# print(res)

# TODO: Packages (Пакеты)
#  Одним из преимуществ Python является наличие множества пакетов, которые вы можете использовать.
#  Пакеты содержат функции, которые вы можете импортировать и использовать в своем коде для выполнения различных
#  расчетов и задач, таких как расчет внутренних коэффициентов доходности, сложных процентов и многого другого.
#  Давайте узнаем о пакетах!
#  В качестве примера возьмем пакет math, который используется для математических вычислений.
#  Чтобы использовать пакет, нам сначала нужно импортировать его в наш код. Это делается с помощью оператора импорта:
#      import math as m
#  Это импортирует математический модуль под именем m.
#  Мы можем назвать пакет как угодно. Это удобно, так как мы можем давать более короткие имена длинным именам пакетов.

# TODO: Packages (Пакеты)
#  Как только мы импортируем пакет, мы можем использовать его функции!
#  Чтобы вызвать функцию из пакета, нам нужно использовать:
#  имя пакета, точку и имя функции, которую мы хотим использовать.
#  Например, воспользуемся функцией sqrt() из пакета math для вывода квадратного корня из 4096:
# import math as m
#
# x = m.sqrt(4096)
# print(x)

# TODO: Numpy (числовой Python)
#  Еще один полезный пакет — NumPy, что означает числовой Python.
#  NumPy очень популярен благодаря включению в него функций для работы с числовыми данными.
#  np — наиболее распространенное имя, используемое для импорта numpy.
#  Начнем с импорта пакета:
#      import numpy as np

# TODO: Numpy (числовой Python)
#  Теперь мы можем использовать функции NumPy для выполнения операций с массивами.
#  Например, функция mean() вычисляет среднее значение массива:
#  Обратите внимание на синтаксис вызова функции:
#  он начинается с имени пакета, точки, а затем имени функции и аргументов.
# import numpy as np
#
# prices = [42.8, 102.03, 240.38, 80.9]
# print(np.mean(prices))

# TODO: Numpy (числовой Python)
#  Вот некоторые популярные функции Numpy:
#      mean - возвращает среднее значение массива
#      std - возвращает стандартное отклонение
#      sum - возвращает сумму всех значений
#      max - возвращает максимальное значение
#  Массивы NumPy позволяют легко и эффективно выполнять вычисления.
# import numpy as np
#
# prices = [42.8, 102.03, 240.38, 80.9]
#
# print(np.mean(prices))
# print(np.std(prices))
# print(np.sum(prices))
# print(np.max(prices))

# TODO: ЗАДАЧА: Standard Deviation (Стандартное отклонение)
#  Стандартное отклонение — это мера того, насколько разбросаны числа.
#  Вам дан массив цен на жилье, и вам нужно рассчитать стандартное отклонение цен.
#  Импортируйте правильный пакет и используйте соответствующую функцию,
#  чтобы вычислить стандартное отклонение массива и вывести его с помощью оператора печати.
# import numpy as np
#
# prices = [75000, 95000, 98000, 109000, 135500, 185000, 199000, 249000, 255000, 280000, 299000, 330000, 380000]
# print(np.std(prices))

# TODO: Numpy Financial (Финансовый числовой Python)
#  Время для финансовых пакетов!
#  Пакет Numpy Financial, созданный на основе NumPy, включает множество полезных финансовых функций.
#  Чтобы использовать их, нам сначала нужно импортировать пакет:
#      import numpy_financial as npf
#  npf — это обычно используемая аббревиатура, используемая при импорте пакета.

# TODO: Numpy Financial (Финансовый числовой Python)
#  Давайте посмотрим на функции, которые он предоставляет.
#  Функция fv() вычисляет будущую стоимость инвестиций.
#  Предположим, вы инвестируете 1000 долларов на 5 лет с годовой доходностью 8%.
#  Нам нужно рассчитать, сколько наши инвестиции будут стоить через 5 лет.
#  Процентная ставка представлена в виде десятичной дроби, где 1 представляет 100%, таким образом, 0.08 соответствует 8%
#      nper – количество периодов.
#      pmt - соответствует периодическим платежам/инвестициям, что в нашем случае равно 0.
#      pv — это текущая стоимость, которая в нашем случае представляет собой инвестиции в размере 1000 долларов,
#  поэтому знак минус.
# import numpy_financial as npf
#
# res = npf.fv(rate=0.08, nper=5, pmt=0, pv=-1000)
# print(res)

# TODO: Present Value (Приведенная стоимость)
#  Точно так же функция pv() используется для расчета приведенной стоимости инвестиций.
#  Например, давайте рассчитаем текущую стоимость инвестиции,
#  которая должна составить 1000 за 8 лет при годовой процентной ставке 10%:
#  Результатом кода будет сумма, которую вам нужно инвестировать сегодня, чтобы достичь 1000 через 8 лет.
# import numpy_financial as npf
#
# res = npf.pv(rate=0.10, nper=8, pmt=0, fv=1000)
# print(res)

# TODO: Monthly Loan Payments (Ежемесячные платежи по кредиту)
#  Функция pmt() используется для расчета платежа по основной сумме кредита плюс проценты.
#  Допустим, мы хотим рассчитать, сколько мы должны платить ежемесячно, чтобы погасить кредит в 100 000 через 5 лет.
#  Годовая процентная ставка составляет 7% и рассчитывается ежемесячно.
#  Поскольку нам нужно рассчитать ежемесячные платежи, мы устанавливаем ставку и периоды (nper) в месяцах.
#  Параметр pv показывает текущую стоимость кредита,
#  а параметр fv показывает будущую стоимость, которую мы хотим получить.
#  Запустите код, чтобы увидеть результирующую сумму ежемесячных платежей.
#  Этот метод можно использовать, например, для расчета платежей по ипотеке.
# import numpy_financial as npf
#
# res = npf.pmt(rate=0.07 / 12, nper=5 * 12, pv=100000, fv=0)
# print(res)

# TODO: pmt() - функция расчета платежа по основной сумме кредита плюс проценты
#  Обратите внимание, что помимо расчета ежемесячного платежа по ипотеке, функция pmt() может использоваться
#  для возврата периодического депозита,
#  необходимого для достижения определенного будущего баланса с заданной процентной ставкой.
#  Например:
#  Код вернет ежемесячные депозиты, необходимые для достижения 50000 за 5 лет, с годовой процентной ставкой 10%.
#  Попробуйте написать программу, которая вычисляет, сколько вам нужно откладывать ежегодно,
#  чтобы получить желаемые пенсионные накопления.
# import numpy_financial as npf
#
# res = npf.pmt(rate=0.10 / 12, nper=5 * 12, pv=0, fv=50000)
# print(res)

# import numpy_financial as npf
#
# res = npf.pmt(rate=0.07, nper=2, pv=0, fv=100000)
# print(res)

# TODO: pmt()
#  Cколько вам нужно экономить ежегодно, чтобы получить 100000 сбережений за 30 лет.
#  Процентная ставка составляет 3%.
# import numpy_financial as npf
#
# res = npf.pmt(rate=0.03, nper=30, pv=0, fv=100000)
# print(res)

# TODO: Mortgage Payments (Платежи по ипотечным кредитам)
#  Вам необходимо рассчитать ежемесячные платежи по кредиту в размере 500 000 долларов США в течение 30 лет.
#  Годовая процентная ставка составляет 4%, проценты начисляются ежемесячно.
#  Напишите программу для вычисления и вывода результата.
#  Подсказка: используйте функцию pmt() пакета NumPy Financial.
#  Он имеет следующий синтаксис:
#      pmt(rate, nper, pv, fv)
#  Обратите внимание, что ваша будущая стоимость (fv) должна быть равна 0, а текущая стоимость (pv) — 500 000.
#  Помните, что аргументы nper и rate должны быть месячными, то есть ставка должна быть разделена на 12,
#  а период nper должен быть в месяцах (годы * 12).
# import numpy_financial as npf
#
# res = npf.pmt(rate=0.04 / 12, nper=30 * 12, pv=500000, fv=0)
# print(res)

# TODO: IRR
#  В Numpy Financial есть функция irr(), используемая для расчета IRR (внутренняя норма доходности).
#  Предположим, мы вложили 5000 и получили следующие платежи: 500, 700, 1000, 3000.
#  Чтобы рассчитать IRR, нам сначала нужно объявить массив со значениями,
#  где первое значение — это наша первоначальная инвестиция:
#      cashflow = [-5000, 500, 700, 1000, 3000]
#  Теперь мы можем использовать функцию irr():
#  Это позволит рассчитать внутреннюю норму доходности.
# import numpy_financial as npf
#
# cashflow = [-5000, 500, 700, 1000, 3000]
# print(npf.irr(cashflow))

# TODO: Comparing IRR (Сравнение внутренней нормы доходности)
#  Давайте воспользуемся функцией irr(), чтобы сравнить две инвестиционные возможности и решить, какая из них лучше.
#  Вариант 1: Требуются 50 000 инвестиций
#  Будут выплачивать 10 000, 25 000, 25 000, 35 000, 42 000 каждый год в течение следующих 5 лет.
#  Вариант 2: Требуются 30 000 инвестиций
#  Будут платить 10 000, 13 000, 18 000, 25 000, 20 000 каждый год в течение следующих 5 лет.
#  Сначала создадим соответствующие массивы:
#  Обратите внимание, что первые значения массивов — это суммы инвестиций, поэтому они отрицательные.
#      cf1 = [-50000, 10000, 25000, 25000, 35000, 42000]
#      cf2 = [-30000, 10000, 13000, 18000, 25000, 20000]
#  Сравнение внутренней нормы доходности
#  Давайте выведем IRR для каждой инвестиции и сравним:
#  Запустите код, чтобы увидеть, какой вариант имеет лучшую IRR.
# import numpy_financial as npf
#
# cf1 = [-50000, 10000, 25000, 25000, 35000, 42000]
# cf2 = [-30000, 10000, 13000, 18000, 25000, 20000]
#
# print("Option 1: ", npf.irr(cf1))
# print("Option 2: ", npf.irr(cf2))

# import numpy_financial as npf
#
# cf = [-1, 1]
# print(npf.irr(cf))

# TODO: ЗАДАЧА: Crypto Mining (Криптовалютный майнинг)
#  Вы решили начать бизнес по добыче криптовалюты в январе 2017 года.
#  Для покупки необходимого оборудования для майнинга требуются первоначальные инвестиции в размере 500 тысяч долларов.
#  Каждый год он сможет добывать 10 монет.
#  Итак, ваш первый возврат будет 1 января 2018 года.
#  Цена монеты за каждый год дана в виде массива в коде.
#  Задача Рассчитайте прибыль за каждый год (2018-2021) и выведите IRR проекта.
#  Вы можете рассчитать, сколько 10 монет будут стоить каждый год, добавить значения в массив,
#  а затем использовать функцию npf.irr() для расчета IRR.
#  Помните, что первым значением массива должна быть первоначальная инвестиция в виде отрицательного значения.
# import numpy_financial as npf
#
# cf1 = [-500000]
# price = [3000, 8000, 29300, 38000]
# for i in price:
#     i *= 10
#     cf1.append(i)
# print(cf1)
# print(npf.irr(cf1))

# TODO: Plotting Data (Отображение данных)
#  Теперь, когда мы знаем, как выполнять основные финансовые расчеты, давайте посмотрим на построение графиков.
#  Python имеет пакет с именем matplotlib, который включает в себя pyplot,
#  используемый для создания графиков и диаграмм.
#  Чтобы использовать его, нам сначала нужно его импортировать:
#      import matplotlib.pyplot as plt
#  plt — это обычное имя, используемое при импорте пакета.
#  Предположим, у нас есть данные о доходах компании за 5 месяцев в виде массива:
#  rev = [18000, 25000, 20000, 45000, 19500]
#  Мы хотим построить диаграмму, актуализирующую данные о доходах.
#  Чтобы создать диаграмму, нам просто нужно вызвать функцию plot для наших данных:
#  Функция savefig() используется для сохранения диаграммы в виде изображения,
#  чтобы ее можно было отобразить на нашей площадке для кода.
# import matplotlib.pyplot as plt
#
# rev = [18000, 25000, 20000, 45000, 32000]
# plt.plot(rev)
# plt.savefig('plot.png')

# TODO: Plotting Data
#  Функция plot() также может принимать значения как для оси x, так и для оси y.
#  Добавим названия месяцев по горизонтальной оси:
#  Теперь вы знаете, как выполнять базовые финансовые расчеты и создавать графики с помощью Python!
#  Вы можете хранить данные в массивах, манипулировать ими и выполнять вычисления с помощью пакетов Numpy и
#  Numpy Financial, а также создавать диаграммы, написав всего пару строк кода.
#  В следующем модуле мы рассмотрим более сложные вопросы (например, цены на акции), так что следите за обновлениями.
# import matplotlib.pyplot as plt
#
# rev = [18000, 25000, 20000, 45000, 32000]
# months = ['June', 'July', 'August', 'September', 'October']
# plt.plot(months, rev)
# plt.savefig('plot.png')

# import numpy_financial as npf
#
# print(npf.fv(rate=0, nper=3, pmt=0, pv=-100))

# TODO: Accessing Data (Доступ к данным)
#  Теперь, когда мы знаем, как выполнять базовые вычисления с помощью Numpy, давайте углубимся в более сложные темы!
#  В этом модуле мы узнаем, как получить доступ к финансовым данным из Интернета.
#  Мы рассмотрим два метода доступа к данным:
#  - просмотр веб-страниц
#  - и использование пакета Python

# TODO: Web Scraping (Веб-скрейпинг)
#  Веб-скрапинг — это процесс использования программы для извлечения содержимого и данных с веб-сайта.
#  Веб-скрапинг извлекает базовый HTML-код веб-сайта.
#  HTML означает язык гипертекстовой разметки и описывает структуру веб-страницы.
#  Этот метод можно использовать для очистки любой общедоступной веб-страницы.
#  Веб-страницы могут иметь ограничения на использование их данных,
#  поэтому обязательно ознакомьтесь с их политикой конфиденциальности,
#  если вы собираетесь использовать данные веб-сайта.

# TODO: Pandas (панельные данные)
#  Чтобы собрать данные из Интернета с помощью Python, нам сначала нужно узнать о Pandas, еще одном полезном пакете.
#  Его можно использовать для очистки и хранения данных в табличном формате.
#  С помощью Pandas нам понадобится всего пара строк кода, чтобы получить нужные данные.
#  Чтобы начать использовать pandas, нам нужно сначала импортировать его:
#      import pandas as pd
#  pd — общепринятая аббревиатура, используемая при импорте библиотеки.
#  Двумя основными компонентами pandas являются Series и DataFrame.
#  Серия — это, по сути, столбец, а DataFrame — это многомерная таблица, состоящая из набора серий.
#  Например, следующий DataFrame состоит из двух серий, возраста и роста: см файл: DataFrame.png
#  Вы можете думать о Series как о массиве, а DataFrame — это набор массивов.

# TODO: Series (Серии)
#  Давайте создадим серию Pandas на основе массива:
# import pandas as pd
#
# prices = [42.8, 102.03, 240.38, 80.9]
# s = pd.Series(prices)
# print(s)
# TODO: Теперь мы можем использовать функции Pandas в Series.
#  Например, мы можем использовать функцию описать describe(), чтобы увидеть ключевую статистику:
# print(s.describe())
# TODO: Вы можете получить доступ к элементам Series аналогично массивам, используя квадратные скобки и индекс.
#  Например: s[1] получит доступ ко второму элементу.
# print(s[1])

# TODO: DataFrame (кадр данных)
#  DataFrame похож на электронную таблицу, хранящую данные в строках и столбцах.
#  Это набор серий, соответствующих столбцам.
#  Давайте создадим DataFrame, который содержит цены и соответствующие им даты:
# import pandas as pd
#
# data = {
#     'date': ['2021-06-10', '2021-06-11', '2021-06-12', '2021-06-13'],
#     'prices': [42.8, 102.03, 240.38, 80.9]
# }
# df = pd.DataFrame(data)
# print(df)
# TODO: Приведенный выше код создает DataFrame с двумя столбцами: дата и цены .
#  Pandas предоставляет множество полезных функций для управления данными в DataFrame.
#  Мы рассмотрим их на следующих уроках, собирая данные из Интернета.
#  Вы можете узнать больше о Pandas и DataFrames в нашем курсе Python для науки о данных.

# TODO: Web Scraping (Веб-скрейпинг)
#  Pandas предоставляет функцию read_html(),
#  которую можно использовать для преобразования таблиц на веб-страницах в DataFrames.
#  Например, возьмем список компаний S&P 500 из Википедии.
#  Список доступен на следующей странице статьи Википедии в виде таблицы:
#  https://en.wikipedia.org/wiki/List_of_S%26P_500_companies
#  Чтобы соскрейпинговать данные, нам просто нужно вызвать функцию read_html()
#  с URL-адресом страницы в качестве параметра:
#  Это прочитает и сохранит все таблицы страницы в переменной данных.
#  data = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')

# TODO: Web Scraping (Веб-скрейпинг)
#  Каждая таблица на веб-странице хранится как DataFrame в отдельном индексе.
#  Первая таблица имеет индекс 0, вторая таблица имеет индекс 1 и так далее.
#  Давайте получим доступ и выведем первую таблицу:
#  Из-за большого размера таблица может выглядеть немного сложной.
# import pandas as pd
#
# data = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')
# df = data[0]
# print(df)

# import pandas as pd
#
# data = pd.read_html('https://stal-stroy.by/prais-list')
# df = data[0]
# print(df)

# TODO: Web Scraping (Веб-скрейпинг)
#  Мы можем определить только определенные столбцы, которые мы хотим выбрать.
#  Выберем и выведем только столбцы Symbol и Security:
#  Обратите внимание на синтаксис: две квадратные скобки используются для указания столбцов,
#  которые мы хотим выбрать, которые должны быть разделены запятыми.
# import pandas as pd
#
# data = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')
# df = data[0]
#
# df = df[['Symbol', 'Security']]
# print(df)

# TODO: Web Scraping (Веб-скрейпинг)
#  Мы также можем отфильтровать таблицу, например, по названию компании:
#  При этом будут выбраны только те строки, в которых столбец «Security» равен «Apple».
# import pandas as pd
#
# data = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')
# df = data[0]
# df = df[df['Security'] == 'Apple']
# print(df)
# df.info()

# TODO: Web Scraping (Веб-скрейпинг)
#  Функцию info() можно использовать для просмотра всех доступных столбцов:
#  Вы можете узнать больше о манипулировании данными с помощью Pandas в нашем курсе Python для науки о данных.
# import pandas as pd
#
# data = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')
# df = data[0]
# df.info()

# TODO: Web Scraping (Веб-скрейпинг)
#  Давайте перейдем к Yahoo Finance, которая предоставляет данные о компаниях,
#  их финансовых показателях и профилях. Например, вот страница профиля Tesla:
#  https://finance.yahoo.com/quote/TSLA/profile

# TODO: Web Scraping (Веб-скрейпинг)
#  Первая таблица представляет собой список ключевых руководителей.
#  Давайте соскрейпингуем его в DataFrame:
#      data = pd.read_html('https://finance.yahoo.com/quote/TSLA/profile')
#  Этот код вызовет ошибку, поскольку Yahoo проверяет запрашивающую сторону и требует допустимый заголовок.
#  Для того, чтобы исправить ошибку, нам нужно указать заголовок запроса.
#  Для этого мы будем использовать пакет запросов и снабдим его допустимым заголовком:
# import requests
#
# url_link = 'https://finance.yahoo.com/quote/TSLA/profile'
# r = requests.get(url_link, headers={
#     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'})
# TODO: Это будет использовать пакет запросов для получения содержимого веб-страницы, указанной в переменной url_link.
#  Значение заголовков используется, чтобы заставить Yahoo думать, что стандартный браузер делает запрос, а не программа
#  Заголовок запроса используется в HTTP-запросе для предоставления информации о контексте запроса,
#  чтобы сервер мог адаптировать ответ. Мы предоставили данные для стандартного веб-браузера.

# TODO: Web Scraping (Веб-скрейпинг)
#  Теперь, когда у нас есть содержимое страницы, мы можем передать его Pandas для очистки таблиц:
#  r.text представляет содержимое веб-страницы, которое мы получили с помощью пакета запросов.
#  Мы использовали пакет request для получения данных и передачи их в функцию read_html().
# import pandas as pd
# import requests
#
# url_link = 'https://finance.yahoo.com/quote/TSLA/profile'
# r = requests.get(url_link, headers={
#     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'})
#
# data = pd.read_html(r.text)
# print(data[0])

# TODO: Web Scraping (Веб-скрейпинг)
#  Теперь мы можем получить доступ к другим финансовым показателям.
#  Например, давайте соскрейпингуем оценки доходов со страницы анализа:
#  Мы использовали индекс [0], так как это первая таблица на странице.
# import pandas as pd
# import requests
#
# url_link = 'https://finance.yahoo.com/quote/TSLA/analysis?p=TSLA'
# r = requests.get(url_link, headers={
#     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'})
#
# data = pd.read_html(r.text)
# print(data[0])

# TODO: Web Scraping (Веб-скрейпинг)
#  Мы можем получить доступ к Avg. Оцените строку из таблицы и постройте ее в виде гистограммы:
#  Запустите код, чтобы увидеть диаграмму, показывающую Avg. Оцените значения из таблицы.
#  Обратите внимание, что мы вызвали функцию plot() прямо в DataFrame, указав тип диаграммы.
#  Это был просто пример данных — с помощью этой техники вы можете извлечь и использовать любые данные
#  в табличном формате из Интернета.
# import pandas as pd
# import requests
#
# url_link = 'https://finance.yahoo.com/quote/TSLA/analysis?p=TSLA'
# r = requests.get(url_link, headers={
#     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'})
#
# data = pd.read_html(r.text)
# print(data[0])
# # data = data[data['Earnings Estimate'] == 'Avg.Estimate']
# # data.plot(kind='bar')

# TODO: Python Package (Пакет Python)
#  Парсинг Yahoo Finance включает в себя много ручной работы, включая добавление заголовка,
#  указание URL-адреса, выполнение запроса и использование функции read_html().
#  Еще один способ получить финансовые данные от Yahoo Finance — использовать пакет yfinance.
#  Он был создан, чтобы обеспечить очень простой способ доступа к финансовым данным без необходимости ручной работы.
#  Существует множество пакетов, созданных сообществом Python, которые можно использовать
#  для извлечения данных из Интернета.

# TODO: yFinance (пакет Yahoo Finance)
#  Чтобы использовать пакет, нам нужно сначала установить и импортировать его:
#      import yfinance as yf
#  Пакет создается и распространяется среди сообщества Python независимым разработчиком.

# TODO: yFinance (пакет Yahoo Finance)
#  После импорта пакета мы можем использовать его возможности.
#  Модуль Ticker позволяет нам получить доступ к данным компании на основе их рыночного тикера.
#  Например, возьмем данные Теслы:
#      data = yf.Ticker("TSLA")
#  TSLA — это тикер, представляющий Tesla на рынке.

# TODO: yFinance (пакет Yahoo Finance)
#  Теперь мы можем получить доступ к информации о компании в соответствующих полях.
#  Например, чтобы получить общие данные:
# import yfinance as yf
#
# data = yf.Ticker("TSLA")
# print(data.info)
# TODO: Выведем маржу прибыли и RoE:
# import yfinance as yf
#
# data = yf.Ticker("TSLA")
# print(data.info['profitMargins'])
# print(data.info['returnOnEquity'])
# TODO: Вы можете проверить все доступные имена полей, используя data.info.keys()
# info = data.info.keys()
# print('\n'.join(info))

# TODO: yFinance (пакет Yahoo Finance)
#  В дополнение к информационным полям объект данных предоставляет следующие поля:
# import yfinance as yf
#
# data = yf.Ticker("TSLA")
# # show dividends (показывать дивиденды)
# print(data.dividends)
# # show splits (показать шпагаты)
# print(data.splits)
# # show balance sheet (показать баланс)
# print(data.balance_sheet)
# # show cashflow (показать денежный поток)
# print(data.cashflow)
# # show earnings (показать доход)
# print(data.earnings)

# TODO: yFinance (пакет Yahoo Finance)
#  Мы также можем легко построить данные.
#  Например, давайте создадим гистограмму дохода:
#  Как видите, пакет yfinance упрощает доступ к данным Yahoo Finance и их использование.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker("TSLA")
#
# x = data.earnings
# x.plot(kind="bar")
# # rev = [18000, 25000, 20000, 45000, 32000]
# # plt.plot(rev)
# plt.savefig('plot.png')

# import yfinance as yf
#
# data = yf.Ticker("BTC-USD")
# print(data.info['description'])

# TODO: Отобразить таблицу денежных потоков в виде гистограмм:
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker("TSLA")
# x = data.cashflow
# x.plot(kind="bar")
# plt.savefig('plot.png')

# TODO: Company Data (Данные компании)
#  Мы также можем использовать пакет yfinance для доступа к данным об инвесторах компании.
#  Выведем список основных держателей Tesla:
# import yfinance as yf
#
# data = yf.Ticker("TSLA")
# print(data.major_holders)

# TODO: Company Data (Данные компании)
#  Мы также можем получить список институциональных держателей:
#  Эти поля на самом деле являются DataFrames.
#  Это означает, что вы можете использовать все функции DataFrame и параметры фильтрации данных.
#  Например, вы можете использовать .info(), чтобы увидеть все столбцы, доступные в DataFrame.
# import yfinance as yf
#
# data = yf.Ticker("TSLA")
# print(data.institutional_holders)
# # print(data.institutional_holders.info())


# TODO: ЗАДАЧА: Company Data (Данные компании)
#  1). Выведите только институциональных инвесторов Tesla, у которых более 10 миллионов акций.
#  2). Выведите только институциональных инвесторов Tesla, у которых 'Value' (стоимость) более 20 миллиардов.
# import yfinance as yf
#
# data = yf.Ticker("TSLA")
# x = data.institutional_holders
# print(x[x['Shares'] > 10000000])
# print(x[x['Value'] > 20000000000])

# TODO: Company Data (Данные компании)
#  Поле рекомендаций предоставляет данные по историческим рекомендациям инвестиционных банков.
#  Давайте отфильтруем только те, которые появились недавно:
#  Индекс DataFrame — это столбец Date.
# import yfinance as yf
#
# data = yf.Ticker("TSLA")
#
# x = data.recommendations
# x = x[x.index > '2022-10-01']
# print(x)

# TODO: Company Data (Данные компании)
#  Давайте применим то, что мы узнали: создадим функцию,
#  которая будет принимать тикер в качестве параметра и выводить значение ROE для этого тикера.
#  Это позволит вам сравнить значения ROE разных компаний:
#  Наша функция получает данные для данного тикера и выводит название и поля RoE для этой компании.
# import yfinance as yf
#
#
# def RoE(ticker):
#     data = yf.Ticker(ticker)
#     roe = data.info['returnOnEquity']
#     name = data.info['shortName']
#     print(f'{name} : {roe}')
#
#
# RoE('TSLA')

# TODO: Company Data (Данные компании)
#  Теперь мы можем вызывать нашу функцию с разными значениями тикера:
#  Это позволяет нам повторно использовать нашу функцию и вызывать ее для разных параметров
#  в нашем коде, когда это необходимо.
# import yfinance as yf
#
#
# def RoE(ticker):
#     data = yf.Ticker(ticker)
#     roe = data.info['returnOnEquity']
#     name = data.info['shortName']
#     print(f'{name} : {roe}')
#
#
# RoE('AAPL')
# RoE('MSFT')

# TODO: Stock Prices (Цены на акции)
#  yfinance также предоставляет цены акций данного тикера.
#  Это выведет цены акций за последний месяц.
#  Обратите внимание, что history() — это функция, и ее нужно вызывать с круглыми скобками.
# import yfinance as yf
#
# data = yf.Ticker('TSLA')
# print(data.history())

# import yfinance as yf
#
# data = yf.Ticker('AMZN')
# print(data.history())

# import yfinance as yf
#
# data = yf.Ticker('MSFT')
# print(data.history())

# TODO: Stock Prices (Цены на акции)
#  Мы можем предоставить параметр периода, чтобы получить данные за указанный период:
#  Valid periods: 1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max.
#  Срок действия: 1д, 5д, 1мес, 3мес, 6мес, 1г, 2г, 5г, 10г, с начала года, макс.
# import yfinance as yf
#
# data = yf.Ticker('TSLA')
# print(data.history(period='1mo'))

# TODO: Stock Prices (Цены на акции)
#  Мы также можем указать пользовательские даты начала и окончания.
#  Например:
# import yfinance as yf
#
# data = yf.Ticker('TSLA')
# print(data.history(start="2022-01-01", end="2022-10-27"))

# TODO: Stock Prices (Цены на акции)
#  Поскольку данные представляют собой DataFrame, мы можем легко их построить.
#  Давайте построим дневную цену закрытия акций Tesla за последний месяц:
#  Вы можете применить любую функцию DataFrame и фильтр для управления данными.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker('TSLA')
#
# x = data.history(period='1y')['Close']
# x.plot()
#
# plt.savefig('plot.png')

# TODO: ЗАДАЧА: Выведите среднюю цену закрытия акций Tesla за последние 3 месяца.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker('TSLA')
# x = data.history('3mo')['Close']
# print(x.mean())
# x.plot()
# plt.savefig('plot.png')

# TODO: Кроме того, yfinance позволяет загружать исторические цены для нескольких акций одновременно.
#  Например, возьмем цены акций Apple, Microsoft и Tesla одной линией:
#  Вам нужно разделить символы тикера пробелами.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.download("AAPL BTC-USD META MSFT SPY TSLA TWTR", start='2021-01-01')
# print(data['Close'])
# data.plot()
# plt.savefig('plot.png')

# TODO: ЗАДАЧА:
#  1). Выведите максимальную цену акций за все время для данных тикеров.
#  2). Выведите максимальную цену акций за 1 месяц для данных тикеров.
# import yfinance as yf
#
# data = yf.download('AAPL BTC-USD META MSFT SPY TSLA TWTR')
# print(data['Close'].max())
# data = yf.download('AAPL BTC-USD META MSFT SPY TSLA TWTR', period='1mo')
# print(data['Close'].max())

# TODO: Поскольку наши данные содержат цены акций 3 компаний, мы можем построить цены акций всех 3 тикеров:
#  Мы можем выбрать цену закрытия только одного выбранного тикера, например, MSFT, используя:
#      data['Close']['MSFT']
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.download("AAPL BTC-USD META MSFT SPY TSLA TWTR", start='2021-01-01')
# data['Close'].plot()
# plt.savefig('plot.png')

# TODO: ЗАДАЧА: Bitcoin Price (Биткойн Цена)
#  Время получить некоторые значения!
#  Задача 1. Получить и вывести цены закрытия акций Tesla за последние 5 дней.
#  Подсказка: Используйте функцию history() для вашего объекта данных
#  и передайте параметр period с соответствующим значением для указанного периода.
#  Не забудьте добавить фильтр ['Close'] в конце.
# import yfinance as yf
#
# data = yf.Ticker('TSLA')
# x = data.history(period='5d')['Close']
# print(x)

# TODO: Stock Returns (Возврат акций)
#  Теперь, когда мы знаем, как получить цены акций, мы можем выполнять расчеты и анализ.
#  Мы начнем с расчета дневной доходности акции. Получим цены акций Tesla за последний год:
# import yfinance as yf
# data = yf.Ticker('TSLA')
# price = data.history(period='1y')
# print(price)

# TODO: Daily Returns (Ежедневные возвраты)
#  Чтобы рассчитать ежедневную доходность, мы будем использовать функцию pct_change(),
#  которая вычисляет процентное изменение между текущим элементом и предыдущим.
#  Мы будем использовать его в столбце «Close»:
#  pct_change() — это функция Pandas, которую можно применять к DataFrames.
# import yfinance as yf
# from matplotlib import pyplot as plt
#
# data = yf.Ticker('TWTR')
# price = data.history(period='1y')
# x = price['Close'].pct_change()
# print(x)
# x.plot()
# plt.savefig('plot.png')

# TODO: Daily Returns (Ежедневные возвраты)
#  Чтобы визуализировать результаты, мы можем построить график для ежедневной доходности:
#  Этот график покажет, как ежедневные доходы изменились за период.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker('TSLA')
# price = data.history(period='1y')
# x = price['Close'].pct_change()
# x.plot()
# plt.savefig('plot.png')

# TODO: Daily Returns (Ежедневные возвраты)
#  Мы также можем сделать гистограмму, чтобы увидеть распределение:
#  Гистограмма — это приблизительное представление распределения числовых данных.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker('TWTR')
# price = data.history(period='1y')
# x = price['Close'].pct_change()
# x.plot(kind='hist')
# plt.savefig('plot.png')

# TODO: Stock Returns (Возврат акций)
#  Поняв, как распределяется прибыль, мы можем рассчитать прибыль от инвестиций.
#  Для этого нам нужно рассчитать совокупную доходность, что можно сделать с помощью функции cumprod():
#  Мы добавляем 1 к х, потому что это представляет ежедневное изменение в процентах.
#  Функция cumprod() используется для получения совокупного произведения
#  по массиву элементов и возврата массива результатов.
#      x = price['Close'].pct_change()
#      returns = (x + 1).cumprod()

# import numpy as np
#
# x = np.array([2, 4, 2])
# r = x.cumprod()
# print(r)

# TODO: Stock Returns (Возврат акций)
#  Теперь, когда у нас есть ежедневная доходность, мы можем построить данные:
#  График показывает, как инвестиции в размере 1 доллара будут расти за данный период.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker('TWTR')
# price = data.history(period='1y')
# x = price['Close'].pct_change()
# returns = (x + 1).cumprod()
# returns.plot()
# plt.savefig('plot.png')

# TODO: ЗАДАЧА: Analyzing Bitcoin (Анализ биткойнов)
#  Время рассчитать совокупную доходность биткойнов!
#  Задача: Рассчитайте и начертите кумулятивную доходность биткойнов за последние 2 года.
#  Совет Построить график легко! Просто импортируйте пакет matplotlib.pyplot и вызовите функцию plot() для массива.
#  Не забудьте использовать функцию pct_change(),
#  чтобы получить процент ежедневной доходности, а затем рассчитать совокупную доходность с помощью функции cumprod().
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.Ticker('BTC-USD')
# price = data.history(period='2y')
# x = price['Close'].pct_change()
# returns = (x + 1).cumprod()
# returns.plot()
# plt.savefig('plot.png')
# print(price)

# TODO: Multiple Stocks (Несколько акций)
#  Давайте возьмем 4 разных тикера и воспользуемся функцией pct_change() для расчета дневной доходности:
#  Приведенный ниже код получает цены акций для заданных акций и применяет функцию pct_change() к цене закрытия.
#  Когда мы указываем только дату начала для функции download(), дата окончания устанавливается как текущая дата.
# import yfinance as yf
#
# data = yf.download("AAPL BTC-USD META MSFT SPY TSLA TWTR", start='2022-10-26', end='2022-10-28')
# x = data['Close'].pct_change()
# print(x)

# TODO: Multiple Stocks (Несколько акций)
#  Чтобы лучше понять возвращаемые значения, мы можем использовать функцию describe() в DataFrame,
#  чтобы получить описательную статистику:
#  Описательная статистика включает среднее значение, стандартное отклонение,
#  минимальное и максимальное значения, а также процентили 25/50/75%.
# import yfinance as yf
#
# data = yf.download("AAPL BTC-USD META MSFT SPY TSLA TWTR", start='2021-01-01')
# x = data['Close'].pct_change()
# print(x.describe())

# TODO: Multiple Stocks (Несколько акций)
#  Давайте визуализируем результаты с помощью диаграмм.
#  Вот график, сравнивающий дневные цены акций:
#  Запустите код, чтобы увидеть результирующую диаграмму.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.download("AAPL BTC-USD META MSFT SPY TSLA TWTR", start='2022-10-26')
# data['Close'].plot()
# plt.savefig('plot.png')

# TODO: Multiple Stocks (Несколько акций)
#  Мы также можем построить график их ежедневной доходности:
#  Как видите, логика та же, что и для одиночной акции.
#  Разница в том, что результат включает в себя результаты для нескольких акций в DataFrame.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.download("AAPL BTC-USD META MSFT SPY TSLA TWTR", start='2022-10-26')
# x = data['Close'].pct_change()
# x.plot()
# plt.savefig('plot.png')

# TODO: Multiple Stocks (Несколько акций)
#  И, наконец, вот совокупная доходность данных акций:
#  Визуализация помогает понять, как ведут себя акции в данный период.
# import yfinance as yf
# import matplotlib.pyplot as plt
#
# data = yf.download("AAPL BTC-USD META MSFT SPY TSLA TWTR", period='1mo')
# x = data['Close'].pct_change()
# (x + 1).cumprod().plot()
# plt.savefig('plot.png')

# TODO: Correlations (Корреляции)
#  В финансах корреляция — это статистика, которая измеряет степень изменения двух ценных бумаг
#  по отношению друг к другу. Мы можем легко рассчитать корреляции между акциями в Python с помощью функции corr().
#  "AAPL AMZN BTC-USD GOOG META MSFT NFLX SPY TSLA TWTR"
# import yfinance as yf
#
# data = yf.download("AAPL AMZN GOOG META NFLX", period='1mo')
# x = data['Close'].pct_change()
# corr = x.corr()
# print(corr)

# TODO: Correlations (Корреляции)
#  Результатом функции corr() является матрица, включающая значения для каждой пары акций.
#  Значения находятся в диапазоне от -1 до 1.
#  Положительная корреляция означает, что доходность акций имеет положительную корреляцию и движется в одном направлении
#  +1 означает, что доходы полностью коррелированны. Корреляция 0 показывает отсутствие связи между парой.
#  Отрицательная корреляция показывает, что доходы движутся в разных направлениях.
#  Поиск акций с низкой корреляцией помогает диверсифицировать инвестиционный портфель и минимизировать риск.

# TODO: Correlations (Корреляции)
#  Корреляция — это матрица, показывающая, как каждая из акций коррелирует с другими.
#  Чтобы показать корреляцию визуально, нам нужно построить ее.
#  Построить корреляцию можно с помощью пакета statsmodels, который включает в себя модуль API:
#      import statsmodels.api as sm
#  Нам нужен только модуль API пакета, поэтому это все, что мы импортировали.

# TODO: Correlations (Корреляции)
#  Давайте нарисуем красивую графику с помощью пакета statmodels:
#  Функция plot_corr() принимает в качестве параметров корреляционную матрицу и названия акций.
#  Это приведет к графику, показывающему корреляцию между данными акциями в данный период.
# import yfinance as yf
# import matplotlib.pyplot as plt
# import statsmodels.api as sm
#
# data = yf.download("META AMZN AAPL NFLX GOOG", start='2022-10-24')
# x = data['Close'].pct_change()
# corr = x.corr()
# sm.graphics.plot_corr(corr, xnames=list(x.columns))
# plt.savefig('plot.png')

# TODO: Analyzing a Portfolio (Анализ портфолио)
#  В этом уроке мы возьмем гипотетический портфель акций и проанализируем его,
#  рассчитав некоторые важные показатели. Во-первых, давайте определим наш портфель.
#  В качестве примера, давайте создадим наш портфель из 30% Apple, 20% Amazon, 40% Microsoft и 10% Tesla.
#  Мы определим биржевые тикеры и веса портфеля, используя массивы:
#      stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
#      weights = [0.3, 0.2, 0.4, 0.1]

# TODO: Analyzing a Portfolio (Анализ портфолио)
#  Теперь, когда у нас определены массивы, мы можем получить цены акций и рассчитать доходность портфеля:
#  Чтобы получить дневную доходность портфеля, мы умножили дневную доходность на веса и вычислили сумму результатов.
# import yfinance as yf
# import numpy as np
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
# weights = [0.3, 0.2, 0.4, 0.1]
#
# data = yf.download(stocks, start='2022-10-01')
# # daily returns (ежедневный доход)
# x = data['Close'].pct_change()
# # portfolio return (доходность портфеля)
# ret = (x * weights).sum(axis=1)
# # total cumulative returns for our portfolio (общая совокупная доходность нашего портфеля)
# cumulative = (ret + 1).cumprod()
# print(cumulative)

# TODO: Analyzing a Portfolio (Анализ портфолио)
#  График кумулятивной доходности даст нам лучшее понимание данных:
#  График показывает, как наш портфель работает в течение периода.
# import yfinance as yf
# import numpy as np
# import matplotlib.pyplot as plt
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
# weights = [0.3, 0.2, 0.4, 0.1]
#
# data = yf.download(stocks, start='2022-10-01')
# # daily returns (ежедневный доход)
# x = data['Close'].pct_change()
# # portfolio return (доходность портфеля)
# ret = (x * weights).sum(axis=1)
# # total cumulative returns for our portfolio (общая совокупная доходность нашего портфеля)
# cumulative = (ret + 1).cumprod()
# cumulative.plot()
# plt.savefig('plot.png')

# TODO: Analyzing a Portfolio (Анализ портфолио)
#  Далее мы рассчитаем волатильность нашего портфеля.
#  Волатильность рассчитывается с использованием стандартного отклонения доходности портфеля.
#  Мы можем рассчитать дневную волатильность, просто используя стандартную функцию NumPy для наших ежедневных доходов:
#  Волатильность также часто используется для измерения риска.
#  Если акция очень волатильна, вы можете ожидать больших изменений ее цены и, следовательно, более высокого риска.
# import yfinance as yf
# import numpy as np
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
# weights = [0.3, 0.2, 0.4, 0.1]
#
# data = yf.download(stocks, start='2022-10-01')
# # daily returns (ежедневный доход)
# x = data['Close'].pct_change()
# # portfolio return (доходность портфеля)
# ret = (x * weights).sum(axis=1)
# print(np.std(ret))

# TODO: Analyzing a Portfolio (Анализ портфолио)
#  Мы можем рассчитать годовую волатильность,
#  взяв квадрат числа торговых дней в году (252) и умножив его на дневную волатильность:
#  Это вернет процент риска нашего портфеля.
#  np.sqrt() используется для вычисления квадратного корня заданного числа.
# import yfinance as yf
# import numpy as np
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
# weights = [0.3, 0.2, 0.4, 0.1]
#
# data = yf.download(stocks, start='2022-10-01')
# # daily returns (ежедневный доход)
# x = data['Close'].pct_change()
# # portfolio return (доходность портфеля)
# ret = (x * weights).sum(axis=1)
# annual_std = np.std(ret) * np.sqrt(252)
# print(annual_std)

# TODO: Analyzing a Portfolio (Анализ портфолио) Еще одним важным показателем является коэффициент Шарпа.
#  Коэффициент Шарпа — это мера доходности портфеля с поправкой на риск.
#  Портфель с более высоким коэффициентом Шарпа считается лучшим.
#  Чтобы рассчитать коэффициент Шарпа, нам нужно взять среднюю доходность и разделить ее на волатильность.
#  Мы умножили результат на квадратный корень из 252, чтобы перевести коэффициент Шарпа в год.
#  (В году 252 торговых дня)
#  Коэффициенты Шарпа больше 1 считаются оптимальными.
# import yfinance as yf
# import numpy as np
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
# weights = [0.3, 0.2, 0.4, 0.1]
#
# data = yf.download(stocks, start='2022-10-01')
# # daily returns (ежедневный доход)
# x = data['Close'].pct_change()
# # portfolio return (доходность портфеля)
# ret = (x * weights).sum(axis=1)
# annual_std = np.std(ret) * np.sqrt(252)
# sharpe = (np.mean(ret) / np.std(ret)) * np.sqrt(252)
# print(sharpe)

# TODO: ЗАДАЧА: Analyzing Bitcoin (Анализ биткойнов)
#  Пришло время рассчитать основные метрики для биткойна!
#  Задачи:
#  1. Импортировать пакет numpy
#  2. Рассчитать годовую волатильность биткойнов и вывести процент риска
#  3. Рассчитать и вывести коэффициент Шарпа
#  Годовая волатильность представляет собой стандартное отклонение,
#  умноженное на квадратный корень из 252 (используйте функцию np.sqrt()).
#  То же самое относится и к коэффициенту Шарпа.
# import yfinance as yf
# import numpy as np
#
# data = yf.Ticker('BTC-USD')
# price = data.history(period='1y')
# x = price['Close'].pct_change()
# # # portfolio return (доходность портфеля)
# annual_std = np.std(x) * np.sqrt(252)
# print(annual_std)
# sharpe = (np.mean(x) / np.std(x)) * np.sqrt(252)
# print(sharpe)

# TODO: Loops (Циклы)
#  Прежде чем мы сможем оптимизировать портфель, нам нужно узнать о циклах for и ranges.
#  Цикл позволяет запускать блок кода несколько раз.
#  Каждый раз, когда код в цикле выполняется, он называется итерацией.

# TODO: Loops (Циклы)
#  Например, мы можем использовать цикл for для перебора массива и вычисления произведения всех элементов:
#  Приведенный выше код вычисляет произведение всех элементов массива и выводит результат.
#  Давайте разберемся, как это работает.
# prices = [3, 5, 2, 8]
#
# prod = 1
# for p in prices:
#     prod = prod * p
#
# print(prod)

# TODO: Loops (Циклы)
#  Код создает переменную с именем prod и инициализирует её значением 1, которая будет хранить результат.
#  Далее, во время каждой итерации цикла for, переменная prod умножается на текущий элемент массива:
#  Обратите внимание на синтаксис цикла for: он использует временную переменную, представляющую текущий элемент массива.
#  Мы назвали его p, но вы можете назвать его как угодно.
#  Цикл for начинается с двоеточия : .
#  После этого код, относящийся к циклу for, должен быть разделен 4 пробелами.
#  Вот как Python понимает, какой блок кода принадлежит циклу for.
# prices = [3, 5, 2, 8]
#
# prod = 1
# for p in prices:
#     prod = prod * p
#
# print(prod)

# TODO: Ranges (Диапазоны)
#  Если вам нужно запустить цикл for заданное количество раз, вы можете использовать диапазон.
#  Что такое диапазон? Это функция, которая используется для создания последовательностей.
#  Например, следующий диапазон создает последовательность чисел от 0 до 10:
#  Параметры определяют начало и конец последовательности.
#  Обратите внимание, что конечный параметр не включается в результирующую последовательность,
#  в то время как начальный параметр включается.
# print(list(range(0, 10)))

# TODO: Ranges and Loops (Диапазоны и циклы)
#  Когда у нас есть диапазон, мы можем использовать цикл for для обхода этого диапазона.
#  Например, следующий код выведет «hello!» 5 раз:
#  Циклы for с диапазонами позволяют выполнять блок кода определенное количество раз.
#  Мы будем использовать эту технику на следующем уроке, выполняя оптимизацию портфеля!
# for i in range(0, 5):
#     print("hello!")

# TODO: Portfolio Optimization (Оптимизация портфеля)
#  Мы научились рассчитывать основные метрики для анализа и оценки портфеля акций.
#  Теперь мы можем использовать мощь Python для оптимизации портфолио!
#  Оптимизация портфеля — это метод распределения активов таким образом,
#  чтобы он имел максимальную доходность и минимальный риск.
#  Это можно сделать, найдя распределение, которое приводит к максимальному коэффициенту Шарпа.
#  Самый простой способ найти наилучшее распределение — проверить множество случайных распределений и найти то,
#  которое имеет лучший коэффициент Шарпа.
#  Этот процесс случайного угадывания известен как моделирование методом Монте-Карло.

# TODO: Portfolio Optimization (Оптимизация портфеля)
#  Для начала давайте определим исходные акции, загрузим данные об их ценах и рассчитаем ежедневную доходность.
#     p_weights = []
#     p_returns = []
#     p_risk = []
#     p_sharpe = []
#  Нам нужно сохранить веса, доходность и коэффициенты Шарпа для каждого портфеля,
#  который мы будем проверять, чтобы затем найти лучший.
#  Мы определим списки для хранения этих значений для каждого портфеля.
#  [] определяем пустой список.
# import yfinance as yf
# import numpy as np
# import pandas as pd
#
# p_weights = []
# p_returns = []
# p_risk = []
# p_sharpe = []
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
#
# data = yf.download(stocks, start='2022-10-01')
#
# # daily returns (ежедневный доход)
# data = data['Close']
# x = data.pct_change()
# print(x)
# TODO: Portfolio Optimization (Оптимизация портфеля)
#  Мы собираемся случайным образом присвоить вес каждой акции в нашем портфеле,
#  а затем вычислить показатели для этого портфеля, включая коэффициент Шарпа.
#  Для генерации случайных весов мы будем использовать случайную функцию NumPy:
#  Мы делим полученные веса на их сумму, чтобы нормализовать их, чтобы сумма случайных весов всегда равнялась 1.
#  Запуск приведенного ниже кода будет генерировать случайные веса, сумма которых равна 1.
# wts = np.random.uniform(size=len(x.columns))
# wts = wts / np.sum(wts)
#
# wts = np.random.uniform(size=4)
# wts = wts / np.sum(wts)
#
# print(wts)
# TODO: Portfolio Optimization (Оптимизация портфеля)
#  Теперь нам нужно запустить цикл for, сгенерировать случайные веса и рассчитать доходность,
#  волатильность и коэффициент Шарпа портфеля.
#  Мы уже научились рассчитывать эти метрики, так что вот код:
#  Цикл for выполняется 500 раз.
#  На каждой итерации мы вычисляем метрики и сохраняем их в соответствующих списках с помощью функции append().
#  Мы использовали 500, чтобы оптимизировать время запуска кода на нашей игровой площадке.
#  В других сценариях вы могли бы создать тысячи портфелей, чтобы получить лучший результат.
#  Код кажется длинным и сложным, однако он просто вычисляет метрики по их формулам,
#  которые мы видели ранее, и сохраняет их в списках.
# count = 500
# for k in range(0, count):
#     wts = np.random.uniform(size=len(x.columns))
#     wts = wts / np.sum(wts)
#     p_weights.append(wts)
#
#     # returns (доходности)
#     mean_ret = (x.mean() * wts).sum() * 252
#     p_returns.append(mean_ret)
#
#     # volatility (волатильность)
#     ret = (x * wts).sum(axis=1)
#     annual_std = np.std(ret) * np.sqrt(252)
#     p_risk.append(annual_std)
#
#     # Sharpe ratio (Коэффициент Шарпа)
#     sharpe = (np.mean(ret) / np.std(ret)) * np.sqrt(252)
#     p_sharpe.append(sharpe)
# TODO: Portfolio Optimization (Оптимизация портфеля)
#  Теперь у нас есть метрики для 500 портфолио!
#  Давайте найдем индекс портфеля с максимальным коэффициентом Шарпа,
#  используя функцию Numpy argmax(), и выведем максимальный коэффициент Шарпа и веса:
# import yfinance as yf
# import numpy as np
# import pandas as pd
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
#
# data = yf.download(stocks, start='2022-10-01')
#
# # daily returns
# data = data['Close']
# x = data.pct_change()
#
# p_weights = []
# p_returns = []
# p_risk = []
# p_sharpe = []
#
# count = 500
# for k in range(0, count):
#     wts = np.random.uniform(size=len(x.columns))
#     wts = wts / np.sum(wts)
#     p_weights.append(wts)
#
#     # returns (доходности)
#     mean_ret = (x.mean() * wts).sum() * 252
#     p_returns.append(mean_ret)
#
#     # volatility (волатильность)
#     ret = (x * wts).sum(axis=1)
#     annual_std = np.std(ret) * np.sqrt(252)
#     p_risk.append(annual_std)
#
#     # Sharpe ratio (Коэффициент Шарпа)
#     sharpe = (np.mean(ret) / np.std(ret)) * np.sqrt(252)
#     p_sharpe.append(sharpe)
#
# max_ind = np.argmax(p_sharpe)
#
# # Max Sharpe ratio (Максимальный коэффициент Шарпа))
# print(p_sharpe[max_ind])
#
# # weights (Веса)
# print(p_weights[max_ind])
# TODO: Этот портфель приводит к максимальному коэффициенту Шарпа.
#  Давайте нарисуем гистограмму, визуализирующую веса:
#  Вы можете получать несколько разные результаты при каждом запуске кода,
#  так как веса каждый раз генерируются случайным образом.
# import yfinance as yf
# import numpy as np
# import pandas as pd
# import matplotlib.pyplot as plt
#
# stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']
#
# data = yf.download(stocks, start='2022-10-01')
#
# # daily returns
# data = data['Close']
# x = data.pct_change()
#
# p_weights = []
# p_returns = []
# p_risk = []
# p_sharpe = []
#
# count = 500
# for k in range(0, count):
#     wts = np.random.uniform(size=len(x.columns))
#     wts = wts / np.sum(wts)
#     p_weights.append(wts)
#
#     # returns
#     mean_ret = (x.mean() * wts).sum() * 252
#     p_returns.append(mean_ret)
#
#     # volatility
#     ret = (x * wts).sum(axis=1)
#     annual_std = np.std(ret) * np.sqrt(252)
#     p_risk.append(annual_std)
#
#     # Sharpe ratio
#     sharpe = (np.mean(ret) / np.std(ret)) * np.sqrt(252)
#     p_sharpe.append(sharpe)
#
# max_ind = np.argmax(p_sharpe)
#
# s = pd.Series(p_weights[max_ind], index=x.columns)
# s.plot(kind='bar')
#
# plt.savefig('plot.png')

# TODO: Portfolio Optimization (Оптимизация портфеля)
#  Мы нашли лучшие веса портфолио!
#  В качестве последнего шага давайте нанесем на график все 500 портфелей.
#  График называется Efficient Frontier и показывает доходность по оси Y и волатильность по оси X.
#  Мы можем создать график с помощью функции scatter(), указав волатильность и списки возврата в качестве параметров:
#  Мы использовали дополнительные параметры, чтобы сделать график более красивым,
#  и добавили цветную полосу для коэффициента Шарпа. Мы также добавили на график красную звездочку,
#  показывающую наиболее эффективный портфель с лучшим коэффициентом Шарпа.
#  Диаграмма Efficient Frontier показывает доход, который мы можем получить при заданной волатильности,
#  или волатильность, которую мы получаем при определенном доходе.
import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

stocks = ['AAPL', 'AMZN', 'MSFT', 'TSLA']

data = yf.download(stocks, start='2018-01-01')

# daily returns
data = data['Close']
x = data.pct_change()

p_weights = []
p_returns = []
p_risk = []
p_sharpe = []

count = 500
for k in range(0, count):
    wts = np.random.uniform(size=len(x.columns))
    wts = wts / np.sum(wts)
    p_weights.append(wts)

    # returns
    mean_ret = (x.mean() * wts).sum() * 252
    p_returns.append(mean_ret)

    # volatility
    ret = (x * wts).sum(axis=1)
    annual_std = np.std(ret) * np.sqrt(252)
    p_risk.append(annual_std)

    # Sharpe ratio
    sharpe = (np.mean(ret) / np.std(ret)) * np.sqrt(252)
    p_sharpe.append(sharpe)

max_ind = np.argmax(p_sharpe)

plt.scatter(p_risk, p_returns, c=p_sharpe, cmap='plasma')
plt.colorbar(label='Sharpe Ratio')

plt.scatter(p_risk[max_ind], p_returns[max_ind], color='r', marker='*', s=500)
plt.show()

plt.savefig('plot.png')
