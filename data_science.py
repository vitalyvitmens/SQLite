# TODO: Data Science (Наука о данных)
#  Наука о данных — обязательная дисциплина в эпоху больших данных.
#  Сегодня компании и отрасли должны принимать решения на основе данных,
#  чтобы выжить. Узнайте, как работает наука о данных.

# TODO: Data Manipulation (Манипуляция данными)

# TODO: Welcome to Data Science (Добро пожаловать в науку о данных)
#  Поздравляем! Вы сделали большой шаг к тому, чтобы стать специалистом по данным!
#  В дополнение к прохождению этого курса не забудьте воспользоваться всей поддержкой обучения,
#  доступной вам на SoloLearn, включая ежедневные советы, практики «Попробуйте сами», задачи тренера по коду,
#  игровую площадку для кода и участие в нашем замечательном сообществе учащихся.
#  Мы рады услышать от вас, поэтому, пожалуйста, оставляйте комментарии и отзывы, когда вы учитесь с нами.
#  Давайте начнем!

# TODO: What is Data Science? (Что такое наука о данных?)
#  В бизнесе существует множество вариантов использования науки о данных,
#  включая поиск лучшего алгоритма прогнозирования цен на жилье для Zillow,
#  поиск ключевых атрибутов, связанных с качеством вина,
#  и создание системы рекомендаций для увеличения рейтинга кликов для Amazon.
#  Извлечение информации из, казалось бы, случайных данных, наука о данных обычно включает в себя сбор данных,
#  очистку данных, выполнение исследовательского анализа данных,
#  создание и оценку моделей машинного обучения и передачу информации заинтересованным сторонам.
#  Наука о данных — это междисциплинарная область, которая объединяет статистику,
#  анализ данных, машинное обучение и связанные с ними методы для извлечения знаний и идей.

# TODO: Why Python? (Почему питон?)
#  В этом курсе «Введение в науку о данных» мы изучаем науку о данных с помощью Python.
#  Будучи языком программирования общего назначения,
#  Python в настоящее время является самым популярным языком программирования в науке о данных.
#  Он прост в использовании, имеет отличную поддержку сообщества и хорошо интегрируется
#  с другими платформами (например, веб-приложениями) в инженерной среде.
#  Этот курс посвящен исследовательскому анализу данных с помощью
#  трех фундаментальных библиотек Python: numpy, pandas и matplotlib.
#  Также будет рассмотрена библиотека машинного обучения scikit-learn.
#  В более поздних модулях мы будем прогнозировать стоимость домов с помощью линейной регрессии,
#  определять классы ириса с помощью алгоритмов классификации и находить
#  кластеры в винах — всего лишь несколько примеров того, что мы можем делать в науке о данных.
#  В науке о данных есть и другие популярные языки программирования,
#  такие как R, который имеет преимущество в статистическом моделировании.

# TODO: Numerical Data (Числовые данные)
#  Наборы данных поступают из самых разных источников и форматов: это могут быть наборы числовых измерений,
#  текстовый корпус, изображения, аудиоклипы или вообще что угодно.
#  Независимо от формата, первым шагом в науке о данных является преобразование его в массивы чисел.
#  Мы собрали 45 показателей роста президента США в сантиметрах в хронологическом порядке
#  и сохранили их в списке — встроенном типе данных в python.
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
# TODO: В данном примере Джордж Вашингтон был первым президентом, а его рост составлял 189 см.
#  Если бы мы хотели узнать, сколько президентов выше 188 см, мы могли бы пройтись по списку,
#  сравнить каждый элемент со 188 и увеличить количество на 1 по мере выполнения критерия.
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# cnt = 0
# for height in heights:
#     if height > 188:
#         cnt += 1
# print(cnt)
# TODO: Это показывает, что есть пять президентов, которые выше 188 см.
#  Независимо от формата данных, первым шагом в науке о данных является преобразование их в массивы чисел.

# TODO: Introduction to Numpy (Введение в Numpy)
#  Numpy (сокращение от Numerical Python) позволяет нам с легкостью найти ответ на вопрос,
#  сколько президентов выше 188 см. Ниже мы покажем, как использовать библиотеку и начнем с базового объекта в numpy.
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# heights_arr = np.array(heights)
# print((heights_arr > 188).sum())
# TODO: Оператор import позволяет нам получить доступ к функциям и модулям внутри библиотеки numpy.
#  Библиотека будет использоваться часто, поэтому по соглашению numpy импортируется под более коротким именем, np.
#  Вторая строка предназначена для преобразования списка в объект массива numpy через np.array(),
#  с которым могут работать инструменты, предоставляемые в numpy.
#  Последняя строка предоставляет простое и естественное решение исходного вопроса с помощью numpy.
#  По мере того, как наши наборы данных становятся больше и сложнее,
#  numpy позволяет нам использовать более эффективный метод без циклов for для обработки и анализа наших данных.
#  Наш пример набора данных в этом модуле будет включать рост, возраст и партийную принадлежность президентов США.
#  Модули Python могут получить доступ к коду из другого модуля, импортировав файл/функцию с помощью оператора import.

# TODO: Size and Shape (Размер и форма)
#  Класс массива в Numpy называется ndarray или n-мерным массивом.
#  Мы можем использовать это для подсчета количества президентов в heights_arr,
#  используя атрибут numpy.ndarray.size.
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# heights_arr = np.array(heights)
# print(heights_arr.size)
# TODO: Обратите внимание, что после создания массива в numpy его размер нельзя изменить.
#  Размер говорит нам, насколько велик массив, форма говорит нам о размере.
#  Чтобы получить текущую форму массива, используйте форму атрибута:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# heights_arr = np.array(heights)
# print(heights_arr.shape)
# TODO: На выходе получается кортеж, вспомним, что кортеж встроенного типа данных является неизменяемым,
#  в то время как список является изменяемым и содержит одно значение, указывающее,
#  что существует только одно измерение, т.е. ось 0.
#  Вдоль оси 0 имеется 45 элементов (по одному для каждого президента) Здесь heights_arr — это массив из 1d.
#  Размер атрибута в numpy аналогичен встроенному методу len в python, который используется
#  для вычисления длины итерируемых объектов python, таких как str, list, dict и т.д.

# TODO: Reshape (Изменить форму)
#  Другие данные, которые мы собрали, включают возраст президентов:
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
# TODO: Поскольку и рост, и возраст относятся к одним и тем же президентам, мы можем их объединить:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# # convert a list to a numpy array (преобразовать список в массив numpy)
# heights_and_ages_arr = np.array(heights_and_ages)
# print(heights_and_ages_arr.shape)
# TODO: Это создает один длинный массив. Было бы понятнее, если бы мы могли выровнять рост и возраст
#  для каждого президента и реорганизовать данные в матрицу 2 на 45, где первая строка содержит все росты,
#  а вторая строка — возраст. Для этого можно создать новый массив,
#  вызвав numpy.ndarray.reshape с новыми размерами, указанными в кортеже:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# # convert a list to a numpy array (преобразовать список в массив numpy)
# heights_and_ages_arr = np.array(heights_and_ages)
# print(heights_and_ages_arr.reshape((2, 45)))
# TODO: Измененный массив теперь представляет собой 2darray, но обратите внимание, что исходный массив не изменился.
#  Мы можем изменить форму массива несколькими способами,
#  если размер измененного массива соответствует размеру исходного.
#  Numpy может рассчитать для нас форму (размер), если мы укажем неизвестное измерение как -1.
#  Например, для заданного 2darray `arr` формы (3,4), arr.reshape(-1)
#  выведет 1darray формы (12,), а arr.reshape((-1,2)) создаст 2dray формы (6,2).

# TODO: Data Type (Тип данных)
#  Еще одна характеристика массива numpy заключается в том, что он однородный,
#  то есть каждый элемент должен иметь один и тот же тип данных.
#  Например, в heights_arr мы записали все высоты целыми числами;
#  таким образом, каждый элемент хранится как целое число в массиве.
#  Чтобы проверить тип данных, используйте numpy.ndarray.dtype
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# heights_arr = np.array(heights)
# print(heights_arr.dtype)
# TODO: Если мы смешаем число с плавающей запятой, скажем, первый элемент будет 189,0 вместо 189:
# heights_float = [189.0, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#                  193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#                  182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
# TODO: Затем, после преобразования списка в массив, мы увидим,
#  что все остальные числа преобразуются в числа с плавающей запятой:
# import numpy as np
# heights_float = [189.0, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#                  193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#                  182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# heights_float_arr = np.array(heights_float)
# print(heights_float_arr)
# print("\n")
# print(heights_float_arr.dtype)
# TODO: Numpy поддерживает несколько типов данных, таких как:
#  - int (целое число),
#  - float (числовое число с плавающей запятой)
#  - bool (логические значения, True и False).
#  Число после типа данных, например. int64 представляет разрядность типа данных.

# TODO: Indexing (Индексация)
#  Мы можем использовать индексацию массива для выбора отдельных элементов из массивов.
#  Как и списки Python, индекс numpy начинается с 0.
#  Чтобы получить доступ к высоте 3-го президента Томаса Джефферсона в 1darray 'heights_arr':
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# heights_arr = np.array(heights)
# print(heights_arr[2])
# TODO: В 2darray есть две оси, ось 0 и 1.
#  Ось 0 проходит вниз по строкам, тогда как ось 1 проходит горизонтально по столбцам.
#  Напомним, что в 2dary heights_and_ages_arr его размеры равны (2, 45).
#  Чтобы найти возраст Томаса Джефферсона в начале его президентства,
#  вам нужно получить доступ ко второй строке, где хранится возраст:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
# print(heights_and_ages_arr[1, 2])
# TODO: В 2darray строка — это ось 0, а столбец — ось 1,
#  поэтому для доступа к 2darray numpy сначала ищет позицию в строках, а затем в столбцах.
#  Итак, в нашем примере heights_and_ages_arr[1,2] мы обращаемся к строке 2 (возраст),
#  столбцу 3 (третий президент), чтобы найти возраст Томаса Джефферсона.

# TODO: Slicing (Нарезка)
#  Что, если мы хотим проверить первые три элемента из первой строки в 2darray?
#  Мы используем «:», чтобы выбрать все элементы из индекса до конечного индекса, но не включая его.
#  Это называется нарезка
# import numpy as np
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
# print(heights_and_ages_arr[0, 0:3])
# TODO: Когда начальный индекс равен 0, мы можем его опустить, как показано ниже:
# import numpy as np
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
# print(heights_and_ages_arr[0, :3])
# TODO: Что, если мы хотим увидеть весь четвертый столбец? Укажите это, используя «:», как показано ниже.
# import numpy as np
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
# print(heights_and_ages_arr[:, 3])
# TODO: Синтаксис срезов Numpy соответствует синтаксису списка Python: arr[start:stop:step].
#  Если какой-либо из них не указан, по умолчанию используются значения start=0, stop=размер измерения, step=1.

# TODO: Assigning Single Values (Присвоение отдельных значений)
#  Иногда вам нужно изменить значения определенных элементов в массиве.
#  Например, мы заметили, что четвертая запись в heights_arr была неверной,
#  она должна быть 165 вместо 163, мы можем переназначить правильный номер:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# heights_arr = np.array(heights)
# heights_arr[3] = 165
# print(heights_arr)
# TODO: В 2darray можно легко назначить отдельные значения.
#  Вы можете использовать индексацию для одного элемента.
#  Например, измените четвертую запись в heights_arr на 165:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
# heights_and_ages_arr[0, 3] = 165
# print(heights_and_ages_arr)
# TODO: Или мы можем использовать нарезку для нескольких элементов.
#  Например, чтобы заменить первую строку ее средним значением 180 в heights_and_ages_arr:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
#
# heights_and_ages_arr[0, :] = 180
# print(heights_and_ages_arr)
# TODO: Мы также можем комбинировать нарезку, чтобы изменить любое подмножество массива.
#  Например, чтобы переназначить 0 в левый верхний угол:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
#
# heights_and_ages_arr[:, :2] = 0
# print(heights_and_ages_arr)
# TODO: Легко обновлять значения в подмассиве, когда вы объединяете массивы с нарезкой.
#  Чтобы узнать больше о базовой нарезке и расширенной индексации в numpy, перейдите по этой ссылке:
#  https://numpy.org/doc/stable/reference/arrays.indexing.html

# TODO: ЗАДАЧА: Assigning Single Values (Присвоение отдельных значений)
#  Замените значение во второй строке и третьем столбце массива heights_and_ages_arr на 2.
# heights_and_ages_arr[1, 2] = 2

# TODO: Assigning an Array to an Array (Назначение массива массиву)
#  Кроме того, 1darray или 2darry могут быть назначены подмножеству другого 2darray, если их формы совпадают.
#  Вспомним 2darray heights_and_ages_arr:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
# print(heights_and_ages_arr)
# TODO: Если мы хотим обновить рост и возраст первого президента новыми данными,
#  мы можем предоставить данные в виде списка:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
#
# heights_and_ages_arr[:, 0] = [190, 58]
# print(heights_and_ages_arr)
# TODO: Мы также можем обновить данные в подмассиве с помощью массива numpy как такового:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_and_ages = heights + ages
# heights_and_ages_arr = np.array(heights_and_ages)
# heights_and_ages_arr = heights_and_ages_arr.reshape((2, 45))
#
# new_record = np.array([[180, 183, 190], [54, 50, 69]])
# heights_and_ages_arr[:, 42:] = new_record
# print(heights_and_ages_arr)
# TODO: Обратите внимание, что значения последних трех столбцов изменились.
#  Обновление многомерного массива новой записью в numpy выполняется просто, если их формы совпадают.

# TODO: Combining Two Arrays (Объединение двух массивов)
#  Часто мы получаем данные, хранящиеся в разных массивах,
#  и нам нужно объединить их в один, чтобы хранить в одном месте.
#  Например, вместо того, чтобы хранить возраст в списке, его можно сохранить в 2darray:
# import numpy as np
#
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# ages_arr = np.array(ages)
#
# print(ages_arr.shape)
# print(ages_arr[:3, ])
# TODO: Если мы изменим heights_arr на (45,1), то же самое, что и ages_arr,
#  мы можем сложить их горизонтально (по столбцам), чтобы получить 2darray с помощью 'hstack':
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_arr = np.array(heights)
# ages_arr = np.array(ages)
#
# heights_arr = heights_arr.reshape((45, 1))
# ages_arr = ages_arr.reshape((45, 1))
#
# height_age_arr = np.hstack((heights_arr, ages_arr))
# print(height_age_arr.shape)
# print(height_age_arr[:3, ])
# TODO: Теперь в height_age_arr есть и рост, и возраст президентов,
#  каждый столбец соответствует росту и возрасту одного президента.
#  Точно так же, если мы хотим объединить массивы по вертикали (по строкам), мы можем использовать «vstack».
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_arr = np.array(heights)
# ages_arr = np.array(ages)
#
# heights_arr = heights_arr.reshape((1, 45))
# ages_arr = ages_arr.reshape((1, 45))
#
# height_age_arr = np.vstack((heights_arr, ages_arr))
# print(height_age_arr.shape)
# print(height_age_arr[:, :3])
# TODO: Чтобы объединить более двух массивов по горизонтали, просто добавьте дополнительные массивы в кортеж.

# TODO: Concatenate (Объединить)
#  В более общем смысле мы можем использовать функцию numpy.concatenate.
#  Если мы хотим объединить, связать вместе два массива по строкам, то передайте «axis = 1»,
#  чтобы получить тот же результат, что и при использовании numpy.hstack; и передайте «axis = 0»,
#  если вы хотите объединить массивы по вертикали.
#  В примере из предыдущей части вместо этого мы использовали hstack для объединения двух массивов по горизонтали:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_arr = np.array(heights)
# ages_arr = np.array(ages)
#
# heights_arr = heights_arr.reshape((45, 1))
# ages_arr = ages_arr.reshape((45, 1))
#
# # height_age_arr = np.hstack((heights_arr, ages_arr))
# height_age_arr = np.concatenate((heights_arr, ages_arr), axis=1)
#
# print(height_age_arr.shape)
# print(height_age_arr[:3, :])
# TODO: Также вы можете получить тот же результат, что и при использовании vstack:
# import numpy as np
#
# heights = [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#            193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#            182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191]
# ages = [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#         55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]
#
# heights_arr = np.array(heights)
# ages_arr = np.array(ages)
#
# heights_arr = heights_arr.reshape((1, 45))
# ages_arr = ages_arr.reshape((1, 45))
#
# # height_age_arr = np.vstack((heights_arr, ages_arr))
# height_age_arr = np.concatenate((heights_arr, ages_arr), axis=0)
#
# print(height_age_arr.shape)
# print(height_age_arr[:, :3])
# TODO: Вы можете использовать np.hstack для объединения массивов, ТОЛЬКО если они имеют одинаковое количество строк.

# TODO: Mathematical Operations on Arrays (Математические операции над массивами)
#  Выполнение математических операций над массивами очень просто.
#  Например, чтобы преобразовать высоту из сантиметров в футы, зная,
#  что 1 сантиметр равен 0,0328084 фута, мы можем использовать умножение:
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# print(height_age_arr[:, 0] * 0.0328084)
# TODO: Теперь у нас есть все высоты в футах. Обратите внимание, что эта операция не изменит исходный массив,
#  она вернет новый 1darray, где 0,0328084 было умножено на каждый элемент в первом столбце «heights_age_arr».
#  Другие математические операции сложения, вычитания,
#  деления и возведения в степень (+, -, /, **) работают с массивами точно так же.

# TODO: Numpy Array Method (Метод массива Numpy)
#  Кроме того, в numpy есть несколько методов для выполнения более сложных вычислений с массивами.
#  Например, метод sum() находит сумму всех элементов массива:
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# print(height_age_arr.sum())
# TODO: Сумма всех ростов и возрастов равна 10 575.
#  Чтобы суммировать все высоты и суммировать все возрасты по отдельности, мы можем указать ось = 0,
#  чтобы вычислить сумму по строкам, то есть вычислить сумму для каждого столбца или сумму столбца.
#  С другой стороны, чтобы получить суммы строк, укажите axis=1.
#  В этом примере мы хотим вычислить общую сумму роста и возраста соответственно:
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# print(height_age_arr.sum(axis=0))
# print(height_age_arr.min(axis=0))
# print(height_age_arr.max(axis=0))
# print(height_age_arr.mean(axis=0))
# TODO: Результатом являются суммы строк: рост всех президентов (т. е. первая строка) составляет в сумме 8100,
#  а сумма возрастов (т. е. вторая строка) равна 2475.
#  Другие операции, такие как .min(), .max(), .mean(), работают аналогично .sum().

# TODO: Comparisons (Сравнения)
#  Практикуя науку о данных, мы часто сталкиваемся со сравнениями для определения строк,
#  которые соответствуют определенным значениям.
#  Для этого мы можем использовать такие операции, как «<», «>», «>=», «<=» и «==».
#  Например, в наборе данных height_age_arr нас могут интересовать только те президенты,
#  которые начали свое президентство моложе 55 лет.
# TODO:
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# print(height_age_arr[:, 1] < 55)
# TODO: Результатом является 1darray с логическими значениями, указывающими, какие президенты соответствуют критериям.
#  Если нас интересует только то, какие президенты начали свое президентство в возрасте 51 года,
#  мы можем вместо этого использовать «==».
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# print(height_age_arr[:, 1] == 51)
# print(f'Удовлетворяет условию: {(height_age_arr[:, 1] == 51).sum()} строк')
# TODO: Чтобы узнать, сколько строк удовлетворяет условию, используйте .sum() в результирующем булевом массиве 1d,
#  например, (height_age_arr[:, 1] == 51).sum(), чтобы увидеть, что было ровно пять президентов,
#  которые начали президентство в возрасте 51 года. Истина рассматривается как 1, а Ложь - как 0 в сумме.

# TODO: Mask & Subsetting (Маска и подмножество)
#  Теперь, когда можно идентифицировать строки, соответствующие определенным критериям, можно найти подмножество данных.
#  Например, вместо всего набора данных нам нужны только высокие президенты, то есть те президенты,
#  чей рост больше или равен 182 см. Сначала мы создаем маску 1darray с логическими значениями:
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# mask = height_age_arr[:, 0] >= 182
# print(mask.sum())
# TODO: Затем передайте его на первую ось `height_age_arr`,
#  чтобы отфильтровать президентов, которые не соответствуют критериям:
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# mask = height_age_arr[:, 0] >= 182
# tall_presidents = height_age_arr[mask]
# print(tall_presidents.shape)
# # print(tall_presidents)
# TODO: Это подмассив height_age_arr, и все президенты в high_presidents были ростом не менее 182 см.
#  Маскирование используется для извлечения, изменения, подсчета или иного манипулирования значениями
#  в массиве на основе некоторого критерия. В нашем примере критерием был рост 182 см и выше.

# TODO: Multiple Criteria (Несколько критериев)
#  Мы можем создать маску, удовлетворяющую более чем одному критерию.
#  Например, помимо роста, мы хотим найти тех президентов,
#  которым на момент начала президентства было 50 лет или меньше.
#  Для этого мы используем & для разделения условий,
#  и каждое условие заключено в круглые скобки «()», как показано ниже:
# import numpy as np
#
# heights_arr = np.array(
#     [189, 170, 189, 163, 183, 171, 185, 168, 173, 183, 173, 173, 175, 178, 183,
#      193, 178, 173, 174, 183, 183, 180, 168, 180, 170, 178, 182, 180, 183, 178,
#      182, 188, 175, 179, 183, 193, 182, 183, 177, 185, 188, 188, 182, 185, 191])
# ages_arr = np.array(
#     [57, 61, 57, 57, 58, 57, 61, 54, 68, 51, 49, 64, 50, 48, 65, 52, 56, 46, 54, 49, 51, 47, 55,
#      55, 54, 42, 51, 56, 55, 51, 54, 51, 60, 62, 43, 55, 56, 61, 52, 69, 64, 46, 54, 47, 70]).reshape((-1, 1))
#
# heights_arr = heights_arr.reshape((45, 1))
# height_age_arr = np.hstack((heights_arr, ages_arr))
#
# mask = (height_age_arr[:, 0] >= 182) & (height_age_arr[:, 1] <= 50)
#
# print(height_age_arr[mask])
# TODO: Результаты показывают нам, что есть четыре президента, которые удовлетворяют обоим условиям.
#  Манипуляции с данными в Python почти синонимичны манипулированию массивами Numpy.
#  Операции, показанные здесь, являются строительными блоками многих других примеров,
#  используемых в этом курсе. Их важно освоить!

# TODO: ЗАДАЧА: Data Science - Average of Rows (Наука о данных — среднее количество строк)
#  В матрице или двумерном массиве X средние значения (or means)
#  элементов строк называются средними значениями строк.
#  Задача:
#  Для заданного двумерного массива вернуть средние значения строк.
#  Формат ввода Первая строка: два целых числа, разделенные пробелами,
#  первое указывает на строки матрицы X (n), а второе указывает на столбцы X (p)
#  Следующие n строк: значения строки в X
#  Output Format:
#  Пустой массив 1d из значения округляются до второго десятичного знака.
#  2 2
#  1.5 1
#  2 2.9
#  Sample Output:
#  [1.25 2.45]
#  Output Format:
#  3 3
#  1.5 3.8 2
#  1.5 2.2 7.7
#  2.2 3.3 4.4
#  Sample Output:
#  [2.43 3.8  3.3 ]
#  Пояснение:
#  В первой строке есть два числа 1.5 и 1, поэтому сумма равна 1.5 + 1 = 2.5,
#  а среднее значение равно 2.5/2 = 1.25.
#  Затем для второй строки вычисляется среднее значение как (2 + 2.9)/2 = 4.9/2 = 2.45.
# import numpy as np
#
# row, col = [int(x) for x in input().split()]
#
# list = [float(j) for i in range(row) for j in input().split()]
# array = np.array(list).reshape((row, col))
#
# print(array.mean(axis=1).round(2))

# import numpy as np
#
# n, p = [int(x) for x in input().split()]  # он принимает первые два ввода n и p
# x = []  # массив для списка
#
# for i in range(n):  # ввод данных для каждой строки
#     x.append(input().split())  # ввод и разбиение данных на ввод по столбцам
#
# arr = np.array(x)  # создание этого массива numpy
# arr = arr.astype(np.float16)  # преобразование типа данных в float
#
# print(arr.mean(axis=1).round(2))   # имеющее среднее значение по строкам с осью = 1

# TODO: Pandas vs. Numpy (Панды против Нампи)
#  Что, если мы хотим проверить данные об Аврааме Линкольне в 'height_age_arr',
#  но не можем вспомнить его целочисленное положение.
#  Есть ли удобный способ получить доступ к данным, проиндексировав имя президента,
#  например:
# print(height_age_arr['Abraham Lincoln'])
# TODO: К сожалению, мы получим сообщение об ошибке. Однако это можно сделать в пандах.
#  Библиотека pandas построена на основе numpy, что означает, что многие features, методы и функции являются общими.
#  По соглашению импортируйте библиотеку под коротким именем «pd»:
# import pandas as pd
# TODO: В следующих уроках мы увидим, что pandas позволяет нам получать доступ к данным, напрямую индексируя имя.
#  Поскольку numpy ndarrays однородны, pandas ослабляет это требование
#  и допускает различные dtypes в своих структурах данных.

# TODO: Series Серии
#  Серия — это один из строительных блоков в пандах.
#  Pandas Series — это одномерный помеченный массив, который может содержать данные любого типа
#  (целое число, строка, число с плавающей запятой, объекты Python и т.д.), подобно столбцу в электронной таблице Excel.
#  Метки осей вместе называются индексом. Если нам дадут мешок с буквами a, b и c, и мы посчитаем,
#  сколько букв каждой из них у нас есть, мы обнаружим, что есть 1 a, 2 b и 3 c.
#  Мы могли бы создать серию, указав список счетчиков и соответствующие им метки:
# import pandas as pd
#
# print(pd.Series([1, 2, 3], index=['a', 'b', 'c']))  # with index
# # TODO: В качестве альтернативы значения могут быть массивом numpy:
# import numpy as np
# import pandas as pd
#
# print(pd.Series(np.array([1, 2, 3]), index=['a', 'b', 'c']))  # from a 1darray
# TODO: Или мы могли бы использовать словарь для указания индекса с ключами:
# import pandas as pd
#
# print(pd.Series({'a': 1, 'b': 2, 'c': 3}))  # from a dict
# TODO: Если мы не укажем индекс, по умолчанию индексом будут целые позиции, начинающиеся с 0.
#  В серии мы можем получить доступ к значению напрямую по его индексу:
# import pandas as pd
#
# series = pd.Series({'a': 1, 'b': 2, 'c': 3})
# print(series['a'])
# print(series[:])
# TODO: Доступ к значению по его индексу, а не по целочисленной позиции, удобен,
#  когда набор данных состоит из тысяч, если не миллионов строк.
#  Series — это строительный блок для DataFrame, который мы представим далее.
#  Думайте о Series как о пустом 1darray с именами индексов или строк.

# TODO: DataFrames (кадры данных)
#  В науке о данных данные обычно более чем одномерны и относятся к разным типам данных;
#  таким образом, Серии недостаточно. DataFrames — это 2darrays с метками строк и столбцов.
#  Один из способов создать DataFrame с нуля — передать dict.
#  Например, на этой неделе мы продали 3 бутылки красного вина Адаму, 6 — Бобу и 5 — Чарльзу.
#  Мы продали 5 бутылок белого вина Адаму, 0 бутылок Бобу и 10 бутылок Чарльзу.
#  Мы можем организовать данные в DataFrame, создав dict «wine_dict» с количеством бутылок каждого типа вина, которое
#  мы продали, а затем передать его вместе с именами клиентов в качестве индекса для создания DataFrame «продажи».
#  См. фото: wine_dict.jpg
# import pandas as pd
#
# wine_dict = {
#     'red_wine': [3, 6, 5],
#     'white_wine': [5, 0, 10]
# }
# sales = pd.DataFrame(wine_dict, index=["adam", "bob", "charles"])
# print(sales)
# TODO: Думайте о DataFrame как о коллекции Series.
#  Здесь продажи состоят из двух серий, одна из которых называется «red_wine»,
#  а другая — «white_wine», поэтому мы можем получить доступ к каждой серии, вызвав ее имя:
# import pandas as pd
#
# wine_dict = {
#     'red_wine': [3, 6, 5],
#     'white_wine': [5, 0, 10]
# }
# sales = pd.DataFrame(wine_dict, index=["adam", "bob", "charles"])
# print(sales['white_wine'])
# TODO: Мы увидим другие способы индексации в DataFrames в последующих частях.
#  Если мы не укажем индекс, DataFrame сгенерирует целочисленный индекс, начиная с 0.

# TODO: Inspect a DataFrame - Shape and Size (Проверка DataFrame — форма и размер)
#  Давайте взглянем на новый DataFrame, там помимо роста и возраста президентов есть информация о порядке,
#  именах и партиях. DataFrame Presidents_df считывается из CSV-файла следующим образом.
#  Обратите внимание, что index установлен для имен президентов.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
# TODO: Подобно numpy, чтобы получить размеры DataFrame, используйте .shape
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.shape)
# TODO: В этом DataFrame 45 строк и 4 столбца.
#  Чтобы получить количество строк, мы можем получить доступ к первому элементу в кортеже.
#  Чтобы получить количество столбцов, мы можем получить доступ ко второму элементу в кортеже.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.shape[0])
# print(presidents_df.shape[1])
# # print(presidents_df)
# TODO: Size также работает с DataFrame, возвращая целое число, представляющее количество элементов в этом объекте.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.size)
# TODO: Здесь оба метода. .shape и .size работают так же, как и с numpy ndarrays.

# TODO: Inspect a DataFrame - Head and Tail (Осмотрите DataFrame — голова и хвост)
#  Вместо того, чтобы смотреть на весь набор данных, мы можем просто взглянуть.
#  Чтобы увидеть первые несколько строк в DataFrame, используйте .head() ;
#  если мы не указываем n (количество строк), по умолчанию отображаются первые пять строк.
#  Здесь мы хотим увидеть верхние 3 строки.
#  См. фото: presidents_df_head.jpg
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.head(n=3))
# TODO: В Presidents_df индексом является имя президента, всего четыре столбца: порядок, возраст, рост и партия.
#  Точно так же, если мы хотим увидеть последние несколько строк,
#  мы можем использовать .tail(), по умолчанию также пять строк.
#  См. фото: presidents_df_tail.jpg
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.tail())
# TODO: Функция .head полезна для быстрой проверки наличия в объекте данных правильного типа.

# TODO: Inspect a DataFrame - Info (Проверка DataFrame — информация)
#  Используйте .info(), чтобы получить обзор DataFrame.
#  Его выходные данные включают индекс, имена столбцов, количество ненулевых значений, dtypes и использование памяти.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# presidents_df.info()
# TODO: Тип dtype для порядка, возраста и роста — целые числа, а партия — объект.
#  Количество ненулевых значений в каждом столбце совпадает с количеством строк,
#  что указывает на отсутствие пропущенных значений.
#  В дополнение к форме и размеру, как показано в numpy,
#  функции pandas предоставляют дополнительные функции для изучения данных.

# TODO: Rows with .loc (Строки с .loc)
#  Вместо того, чтобы запоминать целочисленные позиции для определения
#  порядка, возраста, роста и партии Авраама Линкольна,
#  с помощью DataFrame мы можем получить к нему доступ по имени, используя .loc
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.loc['Abraham Lincoln'])
# # TODO: Результатом является серия панд формы (4,).
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(type(presidents_df.loc['Abraham Lincoln']))
# print(presidents_df.loc['Abraham Lincoln'].shape)
# TODO: Мы также можем разрезать по индексу.
#  Скажем, мы заинтересованы в сборе информации обо всех президентах от Авраама Линкольна до Улисса С. Гранта:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.loc['Abraham Lincoln':'Ulysses S. Grant'])
# TODO: Результатом является новый DataFrame, подмножество 'presidents_df'.
#  .loc[] позволяет нам выбирать данные по метке или по условному оператору.

# TODO: Rows with .loc (Строки с .loc)
#  В качестве альтернативы, если мы знаем целочисленную позицию (позиции),
#  мы можем использовать .iloc для доступа к строке (строкам).
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.iloc[44])
# TODO: Чтобы собрать информацию от 16-го по 18-й президентов, мы можем:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.iloc[15:18])
# TODO: И .loc[], и .iloc[] могут использоваться с булевым массивом для подмножества данных.

# TODO: Columns (Столбцы)
#  Мы можем получить весь столбец из Presidents_df по имени.
#  Сначала мы получаем доступ ко всем именам столбцов:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.columns)
# TODO: Который возвращает объект индекса, содержащий все имена столбцов.
#  Затем мы можем получить доступ к столбцу 'height':
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df['height'])
# print(presidents_df['height'].shape)
# TODO: Который возвращает серию, содержащую рост всех президентов США.
#  Чтобы выбрать несколько столбцов, мы передаем имена в списке, в результате чего создается DataFrame.
#  Помните, мы можем использовать .head() для доступа к первым трем строкам, как показано ниже:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df[['height', 'age']].head(n=3))
# TODO: Таким образом, мы фокусируемся только на интересующих столбцах.
#  При доступе к одному столбцу одна скобка приводит к ряду (одномерному),
#  а двойные скобки приводят к DataFrame (многомерному).

# TODO: More with .loc (Больше о .loc)
#  Если мы хотим получить доступ к столбцу 'order', 'age' и 'height',
#  мы можем сделать это с помощью .loc . .loc позволяет нам получить доступ к любому из столбцов.
#  Например, если мы хотим получить доступ к столбцам от порядка до роста для первых трех президентов:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.loc[:, 'order':'height'].head(n=3))
# TODO: Индекс в pandas делает извлечение информации из строк или столбцов удобным и простым,
#  особенно когда набор данных большой или столбцов много.
#  Поэтому нам не нужно запоминать целые позиции каждой строки или столбца.

# TODO: Min / Max / Mean (Мин./макс./среднее)
#  Нецелесообразно распечатывать весь набор данных с большим размером выборки.
#  Вместо этого мы хотим обобщить и охарактеризовать выборочные данные, используя только несколько значений.
#  Сводная статистика включает меры местоположения и меры распространения.
#  Меры местоположения — это величины, которые представляют собой среднее значение переменной,
#  а меры разброса показывают, насколько схожи или различны значения переменной.
#  Меры местоположения — минимум, максимум, среднее. Меры разброса — диапазон, дисперсия, стандартное отклонение.
#  Простейшие сводные статистические данные, которые являются мерами местоположения,
#  включают минимальное, наименьшее число:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.min())
# TODO: максимум, наибольшее число:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.max())
# # TODO: и mean, среднее:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.mean())
# print(presidents_df['age'].mean())
# print(presidents_df['height'].mean())
# TODO: Напомним, что среднее арифметическое — это сумма элементов, деленная на количество элементов,
#  в python 3.x деление целых чисел приводит к числу с плавающей запятой. Когда минимум и максимум известны,
#  мы можем определить диапазон, меру распространения. Например, рост всех президентов США колеблется от 163 до 193 см.
#  Среднее значение говорит нам, где сосредоточены данные.
#  Например, средний возраст в начале президентского срока составляет 54,71 года.
#  Обратите внимание, что метод mean() может работать только с числовыми значениями, поэтому столбец «party» был опущен.
#  Эти методы работают и с сериями.
#  Например, 'presidents_df['age'].mean()' также дает результат 54,71.

# TODO: Quantiles (квантили)
#  Квантиль - это точка отсечения, которая делит диапазон данных
#  на непрерывные интервалы с равным количеством наблюдений.
#  Медиана — это единственная точка отсечения в 2-квантили,
#  так что 50% данных ниже медианы, а другая половина выше нее.
#  Квартили позволяют быстро разделить набор данных на четыре группы,
#  что позволяет легко увидеть, к какой из четырех групп относится конкретная точка данных.
#  первый квартиль (первые 25% данных),
#  следующий квартиль - 25% данных между первым квартилем и медианой,
#  следующий квартиль - 25% данных между медианой и третьим квартилем,
#  последний квартиль - 25% данных между третьим квартилем и максимумом.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df['height'].quantile([0.25, 0.5, 0.75, 1]))
# print(presidents_df[['order', 'age', 'height']].quantile([0.25, 0.5, 0.75, 1]))
# TODO: Здесь 25% президентов начали свое президентство в возрасте 51 года или моложе,
#  а половина — в возрасте 55 лет или моложе.
#  Среднее значение и медиана обычно не совпадают,
#  если только данные не являются идеально симметричными.
#  Среднее значение — это среднее значение всех чисел, сложенных вместе и разделенное на количество добавленных чисел.
#  Медиана — это значение, отделяющее верхнюю половину от нижней половины выборки данных.
#  В возрастных данных среднее значение близко к медиане, это означает, что данные могут быть симметричными.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df[['age', 'height']].mean())
# print(presidents_df[['age', 'height']].median())
# print(presidents_df[['age', 'height']].quantile(0.5))
# TODO: И .quantile(0.5), и .median() приводят к одному и тому же результату.

# import pandas as pd
#
# a = pd.Series([1, 2, 4, 2, 4, 1])
# print(a.median())
# print(a.quantile(0.5))

# TODO: Variance and Standard Deviation (Дисперсия и стандартное отклонение)
#  В теории вероятностей и статистике дисперсия - это среднеквадратичное отклонение каждой точки данных
#  от среднего значения всего набора данных.
#  Вы можете думать об этом как о том, насколько далеко набор чисел разбросан от их среднего значения.
#  Стандартное отклонение (std) представляет собой квадратный корень из дисперсии.
#  Высокое стандартное значение указывает на большой спред,
#  а низкое стандартное значение указывает на малый спред или на то,
#  что большинство точек близко к среднему значению.
#  В примере ниже, данные состоят из всех констант 2, вариации нет,
#  поэтому Дисперсия равна 0,0, так же как и ее стандартное отклонение:
# import pandas as pd
#
# const = pd.Series([2, 2, 2])
#
# print(dat.mean())
# print(const.var())
# print(const.std())
# TODO: Рассмотрим другой пример:
# [2, 3, 4]
# TODO: Среднее значение [2,3,4] равно (2+3+4)/3 = 3.0,
#  а его изменение равно (2-3.0)**2 + (3-3.0)**2 + (4-3.0)**2 = 1+0+1 = 2.
#  Обратите внимание, что в Python .var() вернет дисперсию, деленную на N-1,
#  где N — длина данных, тогда результат будет 2/(3.0-1) = 1.
# import pandas as pd
#
# dat = pd.Series([2, 3, 4])
#
# print(dat.mean())
# print(dat.var())
# print(dat.std())
# TODO: И std - это просто квадратный корень из дисперсии:
# import pandas as pd
#
# dat = pd.Series([-4, 3, 10])
# # dat = pd.Series([-50, 0, 50])
#
# print(dat.mean())
# print(dat.var())
# print(dat.std())
# TODO: Для возрастов президентов:
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df['age'].mean())
# print(presidents_df['age'].var())
# print(presidents_df['age'].std())
# TODO: Мы можем применить std ко всему DataFrame, чтобы получить стандартное отклонение по столбцам.
#  Для того, что бы убрать ошибку Python при выводе в консоль: numeric_only=True
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df.mean(numeric_only=True))
# print(presidents_df.var(numeric_only=True))
# print(presidents_df.std(numeric_only=True))
#
# print(presidents_df.min(numeric_only=True))
# print(presidents_df.max(numeric_only=True))
# print(presidents_df.quantile([0.25, 0.5, 0.75, 1.0], numeric_only=True))
# TODO: Таким же образом мы можем применить min, max, quantile и var ко всему DataFrame.

# TODO: describe() (описывать())
#  describe() выводит почти всю сводную статистику, упомянутую ранее, за исключением дисперсии.
#  Кроме того, он подсчитывает все ненулевые значения каждого столбца.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df['age'].describe())
# print(presidents_df.describe())
# TODO: Из вывода мы видим, что существует 45 ненулевых точек данных
#  о возрасте со средним значением 55 и стандартным значением 6,60.
#  Возраст варьируется от 42 до 70 лет со средним значением 55 лет.
#  Его первый и третий квартили составляют 51 и 58 лет соответственно.
#  Теперь у нас есть общее описание всех возрастных данных.
#  В дополнение к применению к ряду, describe() можно применить к DataFrame с несколькими столбцами.
#  Как показывает количество (= 45), ни в одном из трех столбцов нет нулевых значений.
#  order — это просто индекс от 1 до 45. Интересно, что и возраст, и рост
#  лежат в интервале примерно одинаковой длины: 70–42 = 28 для возраста, а 193–163 = 30 для роста.
#  Кроме того, обе функции имеют аналогичные стандартные отклонения, что указывает на аналогичный разброс данных.
#  .describe() игнорирует нулевые значения, такие как `NaN` (не число), и генерирует описательную статистику,
#  которая обобщает центральную тенденцию (т.е. среднее значение),
#  дисперсию (т.е. стандартное отклонение) и форму (т.е. мин., max и квантили) распределения набора данных.

# TODO: Categorical Variable (Категориальная переменная)
#  Четвертый столбец party был опущен в выводе .describe(), потому что это категориальная переменная.
#  Категориальная переменная — это та, которая принимает одно значение из ограниченного набора категорий.
#  Не имеет смысла рассчитывать среднее значение демократических, республиканских, федералистских и других партий.
#  Мы можем проверить уникальные значения и соответствующую частоту, используя .value_counts():
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df['party'].value_counts())
# TODO: Мы также можем вызвать .describe(), чтобы увидеть,
#  что существует 45 ненулевых значений, 7 уникальных партий,
#  наиболее часто встречающаяся партия — республиканская, всего 19 президентов принадлежат к этой партии.
# import pandas as pd
#
# presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')
#
# print(presidents_df['party'].describe())
# TODO: Сводная статистика предоставляет нам большой объем информации, изложенной максимально просто.
#  Мера местоположения, медиана, является более надежной, чем среднее, для непрерывных переменных,
#  поскольку последнее чувствительно к выбросам, например, чрезвычайно большим значениям.

# TODO: Groupby (Группа по)
#  Сводная статистика по всему набору данных обеспечивает хорошее общее представление,
#  но часто нас интересуют некоторые вычисления, зависящие от данной метки или категории.
#  Например, каков средний рост условной партии президентов? Чтобы найти значение на основе условия,
#  мы можем использовать операцию groupby. Подумайте о группе, выполнив три шага: разделить, применить и объединить.
#  Шаг разделения разбивает DataFrame на несколько DataFrame на основе значения указанного ключа;
#  шаг применения заключается в выполнении операции внутри каждого меньшего DataFrame;
#  последний шаг объединяет части обратно в более крупный DataFrame.
# presidents_df.groupby('party')
# TODO: .groupby("party") возвращает объект DataFrameGroupBy, а не набор DataFrames.
#  Чтобы получить результат, примените агрегат (.mean()) к этому объекту DataFrameGroupBy:
import pandas as pd

presidents_df = pd.read_csv('https://sololearn.com/uploads/files/president_heights_party.csv', index_col='name')

print(presidents_df.groupby('party').mean())
# TODO: Метод mean() является одной из многих возможностей, вы можете применить любую функцию агрегации pandas
#  или numpy или любую операцию DataFrame, как мы демонстрируем в этом курсе.
