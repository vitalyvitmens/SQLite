# TODO: Intermediate Python (Промежуточный Python)
#  Если вы уже знакомы с основами Python и хотите расширить свои знания, этот курс для вас.
#  Вы узнаете о типах коллекций Python, лямбда-функциях, генераторах, декораторах,
#  объектно-ориентированном программировании и многом другом.

# TODO: Welcome! (Добро пожаловать!)
#  Добро пожаловать на курс Python для среднего уровня.
#  В этом курсе вы узнаете о типах коллекций Python, лямбда-функциях, генераторах, декораторах, ООП и многом другом.
#  Мы также создадим реальные проекты и решим несколько задач программирования.
#  Этот курс предназначен для разработчиков Python среднего уровня,
#  которые уже знают основы Python и хотят расширить свои знания.
#  Если вы новичок в Python, мы предлагаем вам начать с нашего курса Python для начинающих.
# n = [2, 4, 6, 8]
# res = 1
# for x in n[1:3]:
#     res *= x
#
# print(res)

# TODO: Dictionaries (Словари)
#  Python предоставляет ряд встроенных типов коллекций для хранения нескольких значений.
#  Списки являются одним из этих типов коллекций и позволяют хранить индексированные значения:
# x = ['hi', 'hello', 'welcome']
# print(x[2])
# TODO: Каждый элемент списка имеет индекс, который устанавливается автоматически.
#  Словари — это еще один тип коллекций, которые позволяют сопоставлять произвольные ключи со значениями.
#  Словари можно индексировать так же, как и списки, используя квадратные скобки, содержащие ключи.
#  Каждый элемент словаря представлен парой ключ:значение.
#  Пример:
# ages = {"Dave": 24, "Mary": 42, "John": 58}
# print(ages["Dave"])
# print(ages["Mary"])

# TODO: Dictionaries (Словари)
#  В качестве ключей к словарям можно использовать только неизменяемые объекты.
#  Неизменяемые объекты — это объекты, которые нельзя изменить.
#  До сих пор единственными изменяемыми объектами, с которыми вы сталкивались, были списки и словари.
#  Поскольку списки изменяемы, приведенный ниже код выдает ошибку.
#  Это означает, что вы можете использовать строки, целые числа,
#  логические значения и любые другие неизменяемые типы в качестве ключей словаря.
# bad_dict = {
#     [1, 2, 3]: "one two three",
# }

# TODO: ЗАДАЧА: Dictionaries Словари
#  Вы работаете в автосалоне и храните данные об автомобиле в словаре:
#  car = {
#     'brand': 'BMW',
#     'year': 2018,
#     'color': 'red'
#  }
#  Ваша программа должна принимать ключ в качестве входных данных и выводить соответствующее значение.
#  Sample Input:
#  year
#  Sample Output:
#  2018
#  Данные уже определены в коде.
# car = {
#     'brand': 'BMW',
#     'year': 2018,
#     'color': 'red',
#     'mileage': 15000
# }
# print(car[input()])

# TODO: Dictionaries (Словари)
#  Чтобы определить, находится ли ключ в словаре, вы можете использовать in и not in так же, как и для списка.
#  Пример:
# nums = {
#     1: "one",
#     2: "two",
#     3: "three",
# }
# print(1 in nums)
# print("three" in nums)
# print(4 not in nums)

# TODO: Dictionaries (Словари) Полезной словарной функцией является get.
#  Он делает то же самое, что и индексация, но если ключ не найден в словаре,
#  вместо этого возвращается другое указанное значение.
#  Чтобы определить количество элементов в словаре, используйте функцию len() .
#  Пример:
# pairs = {1: "apple",
#          "orange": [2, 3, 4],
#          True: False,
#          12: "True",
#          }
#
# print(pairs.get("orange"))
# print(pairs.get(7, 42))
# print(pairs.get(12345, "not found"))

# TODO: ЗАДАЧА: Dictionary Functions (Функции словаря)
#  Вы работаете с данными, отражающими рейтинг экономической свободы по странам.
#  Каждое название страны и ранг хранятся в словаре, где ключом является название страны.
#  Завершите программу, чтобы взять название страны в качестве входных данных
#  и вывести соответствующий рейтинг экономической свободы.
#  Если указанное название страны отсутствует в данных, выведите «Not found».
#  Вспомните метод словаря get(), который позволяет указать значение по умолчанию.
# data = {
#     'Singapore': 1,
#     'Ireland': 6,
#     'United Kingdom': 7,
#     'Germany': 27,
#     'Armenia': 34,
#     'United States': 17,
#     'Canada': 9,
#     'Italy': 74
# }
# print(data.get(input(), 'Not found'))

# fib = {1: 1, 2: 1, 3: 2, 4: 3}
# print(fib.get(4, 0) + fib.get(7, 5))

# TODO: Tuples (Кортежи)
#  Кортежи очень похожи на списки, за исключением того, что они неизменяемы (их нельзя изменить).
#  Кроме того, они создаются с использованием круглых скобок, а не квадратных скобок.
#  Пример:
#  words = ("spam", "eggs", "sausages")
#  Вы можете получить доступ к значениям в кортеже с их индексом, как и со списками:
# words = ("spam", "eggs", "sausages",)
# print(words[0])
# TODO: Попытка переназначить значение в кортеже приводит к ошибке.
#  Подобно спискам и словарям, кортежи могут быть вложены друг в друга.
# words = ("spam", "eggs", "sausages",)
# words[1] = "cheese"

# TODO: Tuples (Кортежи)
#  Кортежи можно создавать без круглых скобок, просто разделяя значения запятыми.
#  Кортежи быстрее, чем списки, но их нельзя изменить.
#  Пример:
# my_tuple = "one", "two", "three"
# print(my_tuple[0])

# TODO: ЗАДАЧА: Tuples (Кортежи)
#  Вам предоставляется список контактов, где каждый контакт представлен кортежем с именем и возрастом контакта.
#  Завершите программу, чтобы получить строку в качестве входных данных,
#  найти имя в списке контактов и вывести возраст контакта в формате, представленном ниже:
#  Sample Input:
#  John
#  Sample Output:
#  John is 31
#  Если контакт не найден, программа должна вывести "Not Found".
# contacts = [
#     ('James', 42),
#     ('Amy', 24),
#     ('John', 31),
#     ('Amanda', 63),
#     ('Bob', 18)
# ]
# dict_contacts = dict(contacts)
# name = input()
# if name in dict_contacts:
#     print(f'{name} is {dict_contacts[name]}')
# else:
#     print('Not Found')

# contacts = [
#     ('James', 42),
#     ('Amy', 24),
#     ('John', 31),
#     ('Amanda', 63),
#     ('Bob', 18),
# ]
# name = input().lower()
# for i in contacts:
#     if name in str(i).lower():
#         print(f'{i[0]} is {i[1]}')
#         break
# else:
#     print('Not Found')

# TODO: Tuple Unpacking (Распаковка кортежа)
#  Распаковка кортежей позволяет присвоить каждый элемент коллекции переменной.
#  Это также можно использовать для замены переменных, выполнив a, b = b, a,
#  поскольку b, a в правой части формирует кортеж (b, a), который затем распаковывается.
#  Пример:
# numbers = (1, 2, 3)
# a, b, c = numbers
# print(a)
# print(b)
# print(c)

# TODO: Tuple Unpacking (Распаковка кортежа)
#  Переменная, перед которой стоит звездочка (*),
#  принимает все значения из коллекции, оставшиеся от других переменных.
#  c будут присвоены значения от 3 до 8.
#  Пример:
# a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# print(a)
# print(b)
# print(c)
# print(d)

# TODO: ЗАДАЧА: Tuple Unpacking (Распаковка кортежа)
#  Кортежи можно использовать для вывода нескольких значений функции.
#  Вам нужно создать функцию с именем calc(), которая будет принимать длину стороны квадрата
#  в качестве аргумента и возвращать периметр и площадь, используя кортеж.
#  Периметр — это сумма всех сторон, а площадь — это квадрат длины стороны.
#  Данный код берет число из пользовательского ввода, передает его функции calc()
#  и использует распаковку для получения возвращаемых значений.
#      Sample Input:
#      3
#      Sample Output:
#      Perimeter: 12
#      Area: 9
# def calc(x):
#     return x * 4, x ** 2
#
#
# side = int(input())
# p, a = calc(side)
#
# print(f'Perimeter: {p}')
# print(f'Area: {a}')

# a, b, c, d, *e, f, g = range(20)
# print(len(e))

# TODO: Sets (Множества, Наборы)
#  Наборы похожи на списки или словари.
#  Они создаются с помощью фигурных скобок и не упорядочены,
#  что означает, что они не могут быть проиндексированы.
#  Из-за того, как они хранятся, быстрее проверить,
#  является ли элемент частью набора, используя оператор in, а не часть списка.
#  Наборы не могут содержать повторяющиеся элементы.
# num_set = {1, 2, 3, 4, 5}
#
# print(3 in num_set)
# print(3 not in num_set)

# letters = {"a", "b", "c", "d"}
# if "e" not in letters:
#     print(1)
# else:
#     print(2)

# TODO: Sets (Множества, Наборы)
#  Вы можете использовать функцию add() для добавления новых элементов в набор
#  и remove() для удаления определенного элемента:
#  Повторяющиеся элементы будут автоматически удалены из набора.
#  Функцию len() можно использовать для возврата количества элементов набора.
# nums = {1, 2, 1, 3, 1, 4, 5, 6}
# print(nums)
# nums.add(-7)
# nums.remove(3)
# print(nums)

# TODO: Sets (Множества, Наборы)
#  Наборы можно комбинировать с помощью математических операций.
#  Оператор объединения | объединяет два набора, чтобы сформировать новый, содержащий элементы в любом из них.
#  Оператор пересечения & получает элементы только в обоих случаях.
#  Оператор разности - получает элементы в первом наборе, но не во втором.
#  Оператор симметричной разности ^ получает элементы в любом наборе, но не в обоих одновременно.
# first = {1, 2, 3, 4, 5, 6}
# second = {4, 5, 6, 7, 8, 9}
#
# print(first | second)
# print(first & second)
# print(first - second)
# print(second - first)
# print(first ^ second)

# TODO: ЗАДАЧА: Sets (Множества, Наборы)
#  Вы работаете над рекрутинговой платформой,
#  которая должна соответствовать имеющимся вакансиям и кандидатам в зависимости от их навыков.
#  Навыки, необходимые для работы, и навыки кандидата хранятся в наборах.
#  Завершите программу, чтобы вывести соответствующий навык.
#  Вы можете использовать оператор пересечения, чтобы получить значения, присутствующие в обоих наборах.
# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(*skills & job_skills)

# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(' '.join(skills & job_skills))

# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(list(skills & job_skills)[0])

# a = {1, 2, 3}
# b = {0, 3, 4, 5}
# print(a & b)

# TODO: List Comprehensions (генераторы списка)
#  Генерация списков — это полезный способ быстрого создания списков, содержимое которых подчиняется правилу.
#  Например, мы можем сделать следующее:
#  Генераторы списков вдохновлены нотацией построителя множеств в математике.
# # a list comprehension
# cubes = [i ** 3 for i in range(5)]
#
# print(cubes)

# TODO: List Comprehensions (генераторы списка)
#  Генерация списка также может содержать оператор if для принудительного применения условия к значениям в списке.
#  Пример:
# evens = [i ** 2 for i in range(10) if i ** 2 % 2 == 0]
#
# print(evens)

# TODO: ЗАДАЧА: List Comprehensions (генераторы списка)
#  По заданному слову выведите список, содержащий только те буквы слова, которые не являются гласными.
#  Гласные  a, e, i, o, u.
#  Используйте генерацию списка, чтобы создать требуемый список букв и вывести его.
#      Sample Input:
#      awesome
#      Sample Output:
#      ['w', 's', 'm']
# word = input()
# print([x for x in word if x not in ['a', 'e', 'i', 'o', 'u']])

# TODO: Data Structures (Структуры данных)
#  Как мы видели в предыдущих уроках, Python поддерживает следующие типы коллекций:
#  - Lists
#  - Dictionaries
#  - Tuples
#  - Sets
#  Когда использовать словарь:
#  - Когда вам нужна логическая ассоциация между парой ключ: значение.
#  - Когда вам нужен быстрый поиск ваших данных на основе пользовательского ключа.
#  - Когда ваши данные постоянно изменяются. Помните, что словари изменяемы.
#  Когда использовать другие типы:
#  - Используйте списки, если у вас есть коллекция данных, не требующая произвольного доступа,
#  когда вам нужна простая итерируемая коллекция, которая часто изменяется.
#  - Используйте набор, если вам нужна уникальность для элементов.
#  - Используйте кортежи, когда ваши данные не могут или не должны изменяться.
#  Часто кортеж используется в сочетании со словарем,
#  например, кортеж может представлять ключ, потому что он неизменяем.

# a = (1, 2, 3, 1)
# print(a[0:2])

# nums = (55, 44, 33, 22)
# print(max(min(nums[:2]), abs(-42)))

# TODO: ЗАДАЧА: Letter Counter (Счетчик писем)
#  Учитывая строку в качестве входных данных, вам нужно вывести, сколько раз каждая буква встречается в строке.
#  Вы решаете хранить данные в словаре, используя буквы в качестве ключей
#  и соответствующие значения в качестве значений.
#  Создайте программу, которая принимает строку в качестве входных данных
#  и выводит словарь, представляющий количество букв.
#  Вам нужно вывести объект словаря.
#  Обратите внимание, что буквы расположены в порядке появления в строке.
#      Sample Input:
#      hello
#      Sample Output:
#      {'h': 1, 'e': 1, 'l': 2, 'o': 1}
# text = input().lower()
# dict = {}
# for x in text:
#     dict[x] = text.count(x)
#
# print(dict)

# text = input()
# print({x: text.count(x) for x in text})

# TODO: Functional Programming (Функциональное программирование)
#  Функциональное программирование — это стиль программирования,
#  который (как следует из названия) основан на функциях.
#  Ключевой частью функционального программирования являются функции высшего порядка.
#  Функции более высокого порядка принимают другие функции
#  в качестве аргументов или возвращают их в качестве результатов.
#  Функция apply_twice принимает в качестве аргумента другую функцию и дважды вызывает ее внутри своего тела.
#  Пример:
# def apply_twice(func, arg):
#     return func(func(arg))
#
#
# def add_five(x):
#     return x + 5
#
#
# print(apply_twice(add_five, 10))

# def test(func, arg):
#     return func(func(arg))
#
#
# def mult(x):
#     return x * x
#
#
# print(test(mult, 2))

# TODO: Pure Functions (Чистые функции)
#  Функциональное программирование стремится использовать чистые функции.
#  Чистые функции не имеют побочных эффектов и возвращают значение, которое зависит только от их аргументов.
#  Вот как работают функции в математике: например, cos(x) для одного и того же значения x
#  всегда будет возвращать один и тот же результат.
#  Ниже приведены примеры чистых и нечистых функций.
# TODO: Чистая функция:
# def pure_function(x, y):
#     temp = x + 2 * y
#     return temp / (2 * x + y)
#
#
# TODO: Нечистая функция:
# some_list = []
#
#
# def impure(arg):
#     some_list.append(arg)
# TODO: Приведенная выше функция не является чистой, потому что она изменила состояние some_list.

# def func(x):
#     y = x ** 2
#     z = x + y
#     return z
#
#
# print(func(5))

# TODO: Pure Functions (Чистые функции)
#  Использование чистых функций имеет как преимущества, так и недостатки.
#  Чистые функции:
#  - легче рассуждать и тестировать.
#  - более эффективным. После того, как функция была оценена для ввода,
#  результат может быть сохранен и использован в следующий раз, когда функция этого ввода потребуется,
#  что сократит количество вызовов функции. Это называется мемоизацией.
#  - легче работать параллельно.
#  Чистые функции в некоторых ситуациях написать сложнее.

# TODO: Lambdas (Лямбда-функции)
#  При обычном создании функции (используя def) она автоматически присваивается переменной с ее именем.
#  Python позволяет нам создавать функции «на лету», при условии, что они созданы с использованием лямбда - синтаксиса.
#  Этот подход чаще всего используется при передаче простой функции в качестве аргумента другой функции.
#  Синтаксис показан в следующем примере и состоит из ключевого слова lambda, за которым следует список аргументов,
#  двоеточие и выражение для оценки и возврата.
#  Функции, созданные с использованием лямбда-синтаксиса, называются анонимными .
# def my_func(f, arg):
#     return f(arg)
#
#
# print(my_func(lambda x: 2 * x * x, 5))

# TODO: Lambdas (Лямбда-функции)
#  Лямбда-функции не так эффективны, как именованные функции.
#  Они могут делать только то, что требует одного выражения, обычно эквивалентного одной строке кода.
#  В приведенном ниже коде мы на лету создали анонимную функцию и вызвали ее с аргументом.
#  Пример:
# # named function
# def polynomial(x):
#     return x ** 2 + 5 * x + 4
#
#
# print(polynomial(-4))
#
# # lambda
# print((lambda x: x ** 2 + 5 * x + 4)(-4))

# TODO: ЗАДАЧА: Lambdas (Лямбда-функция)
#  Вам дан код, который должен рассчитать соответствующий процент от цены.
#  Кто-то написал лямбда-функцию для этого, однако лямбда неверна.
#  Исправьте код для вывода заданного процента от цены.
#  Sample Input:
#  50
#  10
#  Sample Output:
#  5.0
#  Первый вход — это цена, а второй вход — это процент, который нам нужно рассчитать: 10% от 50 равно 5,0.
# price = int(input())
# perc = int(input())
#
# res = (lambda x, y: x * (y / 100))(price, perc)
#
# print(res)

# TODO: map (Карта)
#  Встроенные функции map и filter — это очень полезные функции высшего порядка,
#  которые работают со списками (или подобными объектами, называемыми итерируемыми).
#  Карта функций принимает функцию и итерируемый объект в качестве аргументов
#  и возвращает новый итерируемый объект с функцией, примененной к каждому аргументу.
#  Чтобы преобразовать результат в список, мы использовали list явно.
#  Пример:
# def add_five(x):
#     return x + 5
#
#
# nums = [11, 22, 33, 44, 55]
# result = list(map(add_five, nums))
# print(result)
# TODO: Мы могли бы добиться того же результата более легко, используя лямбда - синтаксис.
# nums = [11, 22, 33, 44, 55]
#
# result = list(map(lambda x: x + 5, nums))
# print(result)

# TODO: ЗАДАЧА: map (Карта)
#  Вы работаете по зарплатной программе.
#  Учитывая список зарплат, вам нужно взять бонус,
#  который все получают в качестве входных данных,
#  и увеличить все зарплаты на эту сумму.
#  Выведите получившийся список.
#  Вы можете использовать функцию map() для увеличения всех значений списка.
# salaries = [2000, 1800, 3100, 4400, 1500]
# bonus = int(input())
#
# print(list(map(lambda x: x + bonus, salaries)))

# TODO: filter (фильтр)
#  Функция filter фильтрует итерируемый объект, оставляя только те элементы,
#  которые соответствуют условию (также называемому предикатом).
#  Как и map, результат должен быть явно преобразован в список, если вы хотите его распечатать.
#  Пример:
# nums = [11, 22, 33, 44, 55]
# res = list(filter(lambda x: x % 2 == 0, nums))
# print(res)

# TODO: Generators (Генераторы)
#  Генераторы — это тип итерируемых объектов, таких как списки или кортежи.
#  В отличие от списков, они не допускают индексации с произвольными индексами,
#  но их все же можно перебирать с помощью циклов for.
#  Их можно создать с помощью функций и оператора yield.
#  Оператор yield используется для определения генератора,
#  заменяющего возврат функции для предоставления результата вызывающей стороне без уничтожения локальных переменных.
#  Пример:
# def countdown():
#     i = 10
#     while i >= 0:
#         yield i
#         i -= 1
#
#
# for i in countdown():
#     print(i)

# TODO: Generators (Генераторы)
#  Из-за того, что они выдают по одному элементу за раз, у генераторов нет ограничений по памяти, как у списков.
#  На самом деле, они могут быть бесконечными!
#  Короче говоря, генераторы позволяют вам объявить функцию,
#  которая ведет себя как итератор, т.е. ее можно использовать в цикле for.
# def infinite_sevens():
#     while True:
#         yield 7
#
#
# for i in infinite_sevens():
#     print(i)

# def is_prime(n):
#     for i in range(2, int(n ** 0.5) + 1):
#         if n % i == 0:
#             return False
#
#     return True
#
#
# def get_primes():
#     num = 2
#     while True:
#         if is_prime(num):
#             yield num
#         num += 1
#
#
# for x in get_primes():
#     print(x)

# TODO: Generators (Генераторы)
#  Конечные генераторы можно преобразовать в списки, передав их в качестве аргументов функции списка.
#  Использование генераторов приводит к повышению производительности,
#  что является результатом ленивой генерации значений (по запросу),
#  что приводит к меньшему использованию памяти.
#  Кроме того, нам не нужно ждать, пока все элементы будут сгенерированы, прежде чем мы начнем их использовать.
# def numbers(x):
#     for i in range(x):
#         if i % 2 == 0:
#             yield i
#
#
# print(list(numbers(11)))

# TODO: ЗАДАЧА: Generators (Генераторы)
#  Нахождение простых чисел — обычная задача на собеседовании по программированию.
#  Данный код определяет функцию isPrime(x), которая возвращает True, если x простое число.
#  Вам нужно создать функцию генератора primeGenerator(),
#  которая будет принимать два числа в качестве аргументов и использовать функцию isPrime()
#  для вывода простых чисел в заданном диапазоне (между двумя аргументами).
#  Данный код принимает два аргумента в качестве входных данных
#  и передает их функции-генератору, выводя результат в виде списка.
#  Sample Input:
#  10
#  20
#  Sample Output:
#  [11, 13, 17, 19]
# def isPrime(x):
#     if x < 2:
#         return False
#     elif x == 2:
#         return True
#     for n in range(2, x):
#         if x % n == 0:
#             return False
#     return True
#
#
# def primeGenerator(a, b):
#     for i in range(a, b):
#         if isPrime(i) is True:
#             yield i
#
#
# f = int(input())
# t = int(input())
#
# print(list(primeGenerator(f, t)))

# def isPrime(x):
#     if x < 2:
#         return False
#     elif x == 2:
#         return True
#     for n in range(2, x):
#         if x % n == 0:
#             return False
#     return True
#
#
# def primeGenerator(a, b):
#     for i in range(a, b):
#         if isPrime(i):
#             yield i
#
#
# f = int(input())
# t = int(input())
#
# print(list(primeGenerator(f, t)))

def make_word():
    word = ""
    for ch in "spam":
        word += ch
        yield word


print(list(make_word()))
