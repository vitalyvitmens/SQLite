# TODO: Intermediate Python (Промежуточный Python)
#  Если вы уже знакомы с основами Python и хотите расширить свои знания, этот курс для вас.
#  Вы узнаете о типах коллекций Python, лямбда-функциях, генераторах, декораторах,
#  объектно-ориентированном программировании и многом другом.

# TODO: Welcome! (Добро пожаловать!)
#  Добро пожаловать на курс Python для среднего уровня.
#  В этом курсе вы узнаете о типах коллекций Python, лямбда-функциях, генераторах, декораторах, ООП и многом другом.
#  Мы также создадим реальные проекты и решим несколько задач программирования.
#  Этот курс предназначен для разработчиков Python среднего уровня,
#  которые уже знают основы Python и хотят расширить свои знания.
#  Если вы новичок в Python, мы предлагаем вам начать с нашего курса Python для начинающих.
# n = [2, 4, 6, 8]
# res = 1
# for x in n[1:3]:
#     res *= x
#
# print(res)

# TODO: Dictionaries (Словари)
#  Python предоставляет ряд встроенных типов коллекций для хранения нескольких значений.
#  Списки являются одним из этих типов коллекций и позволяют хранить индексированные значения:
# x = ['hi', 'hello', 'welcome']
# print(x[2])
# TODO: Каждый элемент списка имеет индекс, который устанавливается автоматически.
#  Словари — это еще один тип коллекций, которые позволяют сопоставлять произвольные ключи со значениями.
#  Словари можно индексировать так же, как и списки, используя квадратные скобки, содержащие ключи.
#  Каждый элемент словаря представлен парой ключ:значение.
#  Пример:
# ages = {"Dave": 24, "Mary": 42, "John": 58}
# print(ages["Dave"])
# print(ages["Mary"])

# TODO: Dictionaries (Словари)
#  В качестве ключей к словарям можно использовать только неизменяемые объекты.
#  Неизменяемые объекты — это объекты, которые нельзя изменить.
#  До сих пор единственными изменяемыми объектами, с которыми вы сталкивались, были списки и словари.
#  Поскольку списки изменяемы, приведенный ниже код выдает ошибку.
#  Это означает, что вы можете использовать строки, целые числа,
#  логические значения и любые другие неизменяемые типы в качестве ключей словаря.
# bad_dict = {
#     [1, 2, 3]: "one two three",
# }

# TODO: ЗАДАЧА: Dictionaries Словари
#  Вы работаете в автосалоне и храните данные об автомобиле в словаре:
#  car = {
#     'brand': 'BMW',
#     'year': 2018,
#     'color': 'red'
#  }
#  Ваша программа должна принимать ключ в качестве входных данных и выводить соответствующее значение.
#  Sample Input:
#  year
#  Sample Output:
#  2018
#  Данные уже определены в коде.
# car = {
#     'brand': 'BMW',
#     'year': 2018,
#     'color': 'red',
#     'mileage': 15000
# }
# print(car[input()])

# TODO: Dictionaries (Словари)
#  Чтобы определить, находится ли ключ в словаре, вы можете использовать in и not in так же, как и для списка.
#  Пример:
# nums = {
#     1: "one",
#     2: "two",
#     3: "three",
# }
# print(1 in nums)
# print("three" in nums)
# print(4 not in nums)

# TODO: Dictionaries (Словари) Полезной словарной функцией является get.
#  Он делает то же самое, что и индексация, но если ключ не найден в словаре,
#  вместо этого возвращается другое указанное значение.
#  Чтобы определить количество элементов в словаре, используйте функцию len() .
#  Пример:
# pairs = {1: "apple",
#          "orange": [2, 3, 4],
#          True: False,
#          12: "True",
#          }
#
# print(pairs.get("orange"))
# print(pairs.get(7, 42))
# print(pairs.get(12345, "not found"))

# TODO: ЗАДАЧА: Dictionary Functions (Функции словаря)
#  Вы работаете с данными, отражающими рейтинг экономической свободы по странам.
#  Каждое название страны и ранг хранятся в словаре, где ключом является название страны.
#  Завершите программу, чтобы взять название страны в качестве входных данных
#  и вывести соответствующий рейтинг экономической свободы.
#  Если указанное название страны отсутствует в данных, выведите «Not found».
#  Вспомните метод словаря get(), который позволяет указать значение по умолчанию.
# data = {
#     'Singapore': 1,
#     'Ireland': 6,
#     'United Kingdom': 7,
#     'Germany': 27,
#     'Armenia': 34,
#     'United States': 17,
#     'Canada': 9,
#     'Italy': 74
# }
# print(data.get(input(), 'Not found'))

# fib = {1: 1, 2: 1, 3: 2, 4: 3}
# print(fib.get(4, 0) + fib.get(7, 5))

# TODO: Tuples (Кортежи)
#  Кортежи очень похожи на списки, за исключением того, что они неизменяемы (их нельзя изменить).
#  Кроме того, они создаются с использованием круглых скобок, а не квадратных скобок.
#  Пример:
#  words = ("spam", "eggs", "sausages")
#  Вы можете получить доступ к значениям в кортеже с их индексом, как и со списками:
# words = ("spam", "eggs", "sausages",)
# print(words[0])
# TODO: Попытка переназначить значение в кортеже приводит к ошибке.
#  Подобно спискам и словарям, кортежи могут быть вложены друг в друга.
# words = ("spam", "eggs", "sausages",)
# words[1] = "cheese"

# TODO: Tuples (Кортежи)
#  Кортежи можно создавать без круглых скобок, просто разделяя значения запятыми.
#  Кортежи быстрее, чем списки, но их нельзя изменить.
#  Пример:
# my_tuple = "one", "two", "three"
# print(my_tuple[0])

# TODO: ЗАДАЧА: Tuples (Кортежи)
#  Вам предоставляется список контактов, где каждый контакт представлен кортежем с именем и возрастом контакта.
#  Завершите программу, чтобы получить строку в качестве входных данных,
#  найти имя в списке контактов и вывести возраст контакта в формате, представленном ниже:
#  Sample Input:
#  John
#  Sample Output:
#  John is 31
#  Если контакт не найден, программа должна вывести "Not Found".
# contacts = [
#     ('James', 42),
#     ('Amy', 24),
#     ('John', 31),
#     ('Amanda', 63),
#     ('Bob', 18)
# ]
# dict_contacts = dict(contacts)
# name = input()
# if name in dict_contacts:
#     print(f'{name} is {dict_contacts[name]}')
# else:
#     print('Not Found')

# contacts = [
#     ('James', 42),
#     ('Amy', 24),
#     ('John', 31),
#     ('Amanda', 63),
#     ('Bob', 18),
# ]
# name = input().lower()
# for i in contacts:
#     if name in str(i).lower():
#         print(f'{i[0]} is {i[1]}')
#         break
# else:
#     print('Not Found')

# TODO: Tuple Unpacking (Распаковка кортежа)
#  Распаковка кортежей позволяет присвоить каждый элемент коллекции переменной.
#  Это также можно использовать для замены переменных, выполнив a, b = b, a,
#  поскольку b, a в правой части формирует кортеж (b, a), который затем распаковывается.
#  Пример:
# numbers = (1, 2, 3)
# a, b, c = numbers
# print(a)
# print(b)
# print(c)

# TODO: Tuple Unpacking (Распаковка кортежа)
#  Переменная, перед которой стоит звездочка (*),
#  принимает все значения из коллекции, оставшиеся от других переменных.
#  c будут присвоены значения от 3 до 8.
#  Пример:
# a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# print(a)
# print(b)
# print(c)
# print(d)

# TODO: ЗАДАЧА: Tuple Unpacking (Распаковка кортежа)
#  Кортежи можно использовать для вывода нескольких значений функции.
#  Вам нужно создать функцию с именем calc(), которая будет принимать длину стороны квадрата
#  в качестве аргумента и возвращать периметр и площадь, используя кортеж.
#  Периметр — это сумма всех сторон, а площадь — это квадрат длины стороны.
#  Данный код берет число из пользовательского ввода, передает его функции calc()
#  и использует распаковку для получения возвращаемых значений.
#      Sample Input:
#      3
#      Sample Output:
#      Perimeter: 12
#      Area: 9
# def calc(x):
#     return x * 4, x ** 2
#
#
# side = int(input())
# p, a = calc(side)
#
# print(f'Perimeter: {p}')
# print(f'Area: {a}')

# a, b, c, d, *e, f, g = range(20)
# print(len(e))

# TODO: Sets (Множества, Наборы)
#  Наборы похожи на списки или словари.
#  Они создаются с помощью фигурных скобок и не упорядочены,
#  что означает, что они не могут быть проиндексированы.
#  Из-за того, как они хранятся, быстрее проверить,
#  является ли элемент частью набора, используя оператор in, а не часть списка.
#  Наборы не могут содержать повторяющиеся элементы.
# num_set = {1, 2, 3, 4, 5}
#
# print(3 in num_set)
# print(3 not in num_set)

# letters = {"a", "b", "c", "d"}
# if "e" not in letters:
#     print(1)
# else:
#     print(2)

# TODO: Sets (Множества, Наборы)
#  Вы можете использовать функцию add() для добавления новых элементов в набор
#  и remove() для удаления определенного элемента:
#  Повторяющиеся элементы будут автоматически удалены из набора.
#  Функцию len() можно использовать для возврата количества элементов набора.
# nums = {1, 2, 1, 3, 1, 4, 5, 6}
# print(nums)
# nums.add(-7)
# nums.remove(3)
# print(nums)

# TODO: Sets (Множества, Наборы)
#  Наборы можно комбинировать с помощью математических операций.
#  Оператор объединения | объединяет два набора, чтобы сформировать новый, содержащий элементы в любом из них.
#  Оператор пересечения & получает элементы только в обоих случаях.
#  Оператор разности - получает элементы в первом наборе, но не во втором.
#  Оператор симметричной разности ^ получает элементы в любом наборе, но не в обоих одновременно.
# first = {1, 2, 3, 4, 5, 6}
# second = {4, 5, 6, 7, 8, 9}
#
# print(first | second)
# print(first & second)
# print(first - second)
# print(second - first)
# print(first ^ second)

# TODO: ЗАДАЧА: Sets (Множества, Наборы)
#  Вы работаете над рекрутинговой платформой,
#  которая должна соответствовать имеющимся вакансиям и кандидатам в зависимости от их навыков.
#  Навыки, необходимые для работы, и навыки кандидата хранятся в наборах.
#  Завершите программу, чтобы вывести соответствующий навык.
#  Вы можете использовать оператор пересечения, чтобы получить значения, присутствующие в обоих наборах.
# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(*skills & job_skills)

# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(' '.join(skills & job_skills))

# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(list(skills & job_skills)[0])

# a = {1, 2, 3}
# b = {0, 3, 4, 5}
# print(a & b)

# TODO: List Comprehensions (генераторы списка)
#  Генерация списков — это полезный способ быстрого создания списков, содержимое которых подчиняется правилу.
#  Например, мы можем сделать следующее:
#  Генераторы списков вдохновлены нотацией построителя множеств в математике.
# # a list comprehension
# cubes = [i ** 3 for i in range(5)]
#
# print(cubes)

# TODO: List Comprehensions (генераторы списка)
#  Генерация списка также может содержать оператор if для принудительного применения условия к значениям в списке.
#  Пример:
# evens = [i ** 2 for i in range(10) if i ** 2 % 2 == 0]
#
# print(evens)

# TODO: ЗАДАЧА: List Comprehensions (генераторы списка)
#  По заданному слову выведите список, содержащий только те буквы слова, которые не являются гласными.
#  Гласные  a, e, i, o, u.
#  Используйте генерацию списка, чтобы создать требуемый список букв и вывести его.
#      Sample Input:
#      awesome
#      Sample Output:
#      ['w', 's', 'm']
# word = input()
# print([x for x in word if x not in ['a', 'e', 'i', 'o', 'u']])

# TODO: Data Structures (Структуры данных)
#  Как мы видели в предыдущих уроках, Python поддерживает следующие типы коллекций:
#  - Lists
#  - Dictionaries
#  - Tuples
#  - Sets
#  Когда использовать словарь:
#  - Когда вам нужна логическая ассоциация между парой ключ: значение.
#  - Когда вам нужен быстрый поиск ваших данных на основе пользовательского ключа.
#  - Когда ваши данные постоянно изменяются. Помните, что словари изменяемы.
#  Когда использовать другие типы:
#  - Используйте списки, если у вас есть коллекция данных, не требующая произвольного доступа,
#  когда вам нужна простая итерируемая коллекция, которая часто изменяется.
#  - Используйте набор, если вам нужна уникальность для элементов.
#  - Используйте кортежи, когда ваши данные не могут или не должны изменяться.
#  Часто кортеж используется в сочетании со словарем,
#  например, кортеж может представлять ключ, потому что он неизменяем.

# a = (1, 2, 3, 1)
# print(a[0:2])

# nums = (55, 44, 33, 22)
# print(max(min(nums[:2]), abs(-42)))

# TODO: ЗАДАЧА: Letter Counter (Счетчик писем)
#  Учитывая строку в качестве входных данных, вам нужно вывести, сколько раз каждая буква встречается в строке.
#  Вы решаете хранить данные в словаре, используя буквы в качестве ключей
#  и соответствующие значения в качестве значений.
#  Создайте программу, которая принимает строку в качестве входных данных
#  и выводит словарь, представляющий количество букв.
#  Вам нужно вывести объект словаря.
#  Обратите внимание, что буквы расположены в порядке появления в строке.
#      Sample Input:
#      hello
#      Sample Output:
#      {'h': 1, 'e': 1, 'l': 2, 'o': 1}
# text = input().lower()
# dict = {}
# for x in text:
#     dict[x] = text.count(x)
#
# print(dict)

# text = input()
# print({x: text.count(x) for x in text})

# TODO: Functional Programming (Функциональное программирование)
#  Функциональное программирование — это стиль программирования,
#  который (как следует из названия) основан на функциях.
#  Ключевой частью функционального программирования являются функции высшего порядка.
#  Функции более высокого порядка принимают другие функции
#  в качестве аргументов или возвращают их в качестве результатов.
#  Функция apply_twice принимает в качестве аргумента другую функцию и дважды вызывает ее внутри своего тела.
#  Пример:
# def apply_twice(func, arg):
#     return func(func(arg))
#
#
# def add_five(x):
#     return x + 5
#
#
# print(apply_twice(add_five, 10))

# def test(func, arg):
#     return func(func(arg))
#
#
# def mult(x):
#     return x * x
#
#
# print(test(mult, 2))

# TODO: Pure Functions (Чистые функции)
#  Функциональное программирование стремится использовать чистые функции.
#  Чистые функции не имеют побочных эффектов и возвращают значение, которое зависит только от их аргументов.
#  Вот как работают функции в математике: например, cos(x) для одного и того же значения x
#  всегда будет возвращать один и тот же результат.
#  Ниже приведены примеры чистых и нечистых функций.
# TODO: Чистая функция:
# def pure_function(x, y):
#     temp = x + 2 * y
#     return temp / (2 * x + y)
#
#
# TODO: Нечистая функция:
# some_list = []
#
#
# def impure(arg):
#     some_list.append(arg)
# TODO: Приведенная выше функция не является чистой, потому что она изменила состояние some_list.

# def func(x):
#     y = x ** 2
#     z = x + y
#     return z
#
#
# print(func(5))

# TODO: Pure Functions (Чистые функции)
#  Использование чистых функций имеет как преимущества, так и недостатки.
#  Чистые функции:
#  - легче рассуждать и тестировать.
#  - более эффективным. После того, как функция была оценена для ввода,
#  результат может быть сохранен и использован в следующий раз, когда функция этого ввода потребуется,
#  что сократит количество вызовов функции. Это называется мемоизацией.
#  - легче работать параллельно.
#  Чистые функции в некоторых ситуациях написать сложнее.

# TODO: Lambdas (Лямбда-функции)
#  При обычном создании функции (используя def) она автоматически присваивается переменной с ее именем.
#  Python позволяет нам создавать функции «на лету», при условии, что они созданы с использованием лямбда - синтаксиса.
#  Этот подход чаще всего используется при передаче простой функции в качестве аргумента другой функции.
#  Синтаксис показан в следующем примере и состоит из ключевого слова lambda, за которым следует список аргументов,
#  двоеточие и выражение для оценки и возврата.
#  Функции, созданные с использованием лямбда-синтаксиса, называются анонимными .
# def my_func(f, arg):
#     return f(arg)
#
#
# print(my_func(lambda x: 2 * x * x, 5))

# TODO: Lambdas (Лямбда-функции)
#  Лямбда-функции не так эффективны, как именованные функции.
#  Они могут делать только то, что требует одного выражения, обычно эквивалентного одной строке кода.
#  В приведенном ниже коде мы на лету создали анонимную функцию и вызвали ее с аргументом.
#  Пример:
# # named function
# def polynomial(x):
#     return x ** 2 + 5 * x + 4
#
#
# print(polynomial(-4))
#
# # lambda
# print((lambda x: x ** 2 + 5 * x + 4)(-4))

# TODO: ЗАДАЧА: Lambdas (Лямбда-функция)
#  Вам дан код, который должен рассчитать соответствующий процент от цены.
#  Кто-то написал лямбда-функцию для этого, однако лямбда неверна.
#  Исправьте код для вывода заданного процента от цены.
#  Sample Input:
#  50
#  10
#  Sample Output:
#  5.0
#  Первый вход — это цена, а второй вход — это процент, который нам нужно рассчитать: 10% от 50 равно 5,0.
# price = int(input())
# perc = int(input())
#
# res = (lambda x, y: x * (y / 100))(price, perc)
#
# print(res)

# TODO: map (Карта)
#  Встроенные функции map и filter — это очень полезные функции высшего порядка,
#  которые работают со списками (или подобными объектами, называемыми итерируемыми).
#  Карта функций принимает функцию и итерируемый объект в качестве аргументов
#  и возвращает новый итерируемый объект с функцией, примененной к каждому аргументу.
#  Чтобы преобразовать результат в список, мы использовали list явно.
#  Пример:
# def add_five(x):
#     return x + 5
#
#
# nums = [11, 22, 33, 44, 55]
# result = list(map(add_five, nums))
# print(result)
# TODO: Мы могли бы добиться того же результата более легко, используя лямбда - синтаксис.
# nums = [11, 22, 33, 44, 55]
#
# result = list(map(lambda x: x + 5, nums))
# print(result)

# TODO: ЗАДАЧА: map (Карта)
#  Вы работаете по зарплатной программе.
#  Учитывая список зарплат, вам нужно взять бонус,
#  который все получают в качестве входных данных,
#  и увеличить все зарплаты на эту сумму.
#  Выведите получившийся список.
#  Вы можете использовать функцию map() для увеличения всех значений списка.
# salaries = [2000, 1800, 3100, 4400, 1500]
# bonus = int(input())
#
# print(list(map(lambda x: x + bonus, salaries)))

# TODO: filter (фильтр)
#  Функция filter фильтрует итерируемый объект, оставляя только те элементы,
#  которые соответствуют условию (также называемому предикатом).
#  Как и map, результат должен быть явно преобразован в список, если вы хотите его распечатать.
#  Пример:
# nums = [11, 22, 33, 44, 55]
# res = list(filter(lambda x: x % 2 == 0, nums))
# print(res)

# TODO: Generators (Генераторы)
#  Генераторы — это тип итерируемых объектов, таких как списки или кортежи.
#  В отличие от списков, они не допускают индексации с произвольными индексами,
#  но их все же можно перебирать с помощью циклов for.
#  Их можно создать с помощью функций и оператора yield.
#  Оператор yield используется для определения генератора,
#  заменяющего возврат функции для предоставления результата вызывающей стороне без уничтожения локальных переменных.
#  Пример:
# def countdown():
#     i = 10
#     while i >= 0:
#         yield i
#         i -= 1
#
#
# for i in countdown():
#     print(i)

# TODO: Generators (Генераторы)
#  Из-за того, что они выдают по одному элементу за раз, у генераторов нет ограничений по памяти, как у списков.
#  На самом деле, они могут быть бесконечными!
#  Короче говоря, генераторы позволяют вам объявить функцию,
#  которая ведет себя как итератор, т.е. ее можно использовать в цикле for.
# def infinite_sevens():
#     while True:
#         yield 7
#
#
# for i in infinite_sevens():
#     print(i)

# def is_prime(n):
#     for i in range(2, int(n ** 0.5) + 1):
#         if n % i == 0:
#             return False
#
#     return True
#
#
# def get_primes():
#     num = 2
#     while True:
#         if is_prime(num):
#             yield num
#         num += 1
#
#
# for x in get_primes():
#     print(x)

# TODO: Generators (Генераторы)
#  Конечные генераторы можно преобразовать в списки, передав их в качестве аргументов функции списка.
#  Использование генераторов приводит к повышению производительности,
#  что является результатом ленивой генерации значений (по запросу),
#  что приводит к меньшему использованию памяти.
#  Кроме того, нам не нужно ждать, пока все элементы будут сгенерированы, прежде чем мы начнем их использовать.
# def numbers(x):
#     for i in range(x):
#         if i % 2 == 0:
#             yield i
#
#
# print(list(numbers(11)))

# TODO: ЗАДАЧА: Generators (Генераторы)
#  Нахождение простых чисел — обычная задача на собеседовании по программированию.
#  Данный код определяет функцию isPrime(x), которая возвращает True, если x простое число.
#  Вам нужно создать функцию генератора primeGenerator(),
#  которая будет принимать два числа в качестве аргументов и использовать функцию isPrime()
#  для вывода простых чисел в заданном диапазоне (между двумя аргументами).
#  Данный код принимает два аргумента в качестве входных данных
#  и передает их функции-генератору, выводя результат в виде списка.
#  Sample Input:
#  10
#  20
#  Sample Output:
#  [11, 13, 17, 19]
# def isPrime(x):
#     if x < 2:
#         return False
#     elif x == 2:
#         return True
#     for n in range(2, x):
#         if x % n == 0:
#             return False
#     return True
#
#
# def primeGenerator(a, b):
#     for i in range(a, b):
#         if isPrime(i) is True:
#             yield i
#
#
# f = int(input())
# t = int(input())
#
# print(list(primeGenerator(f, t)))

# def isPrime(x):
#     if x < 2:
#         return False
#     elif x == 2:
#         return True
#     for n in range(2, x):
#         if x % n == 0:
#             return False
#     return True
#
#
# def primeGenerator(a, b):
#     for i in range(a, b):
#         if isPrime(i):
#             yield i
#
#
# f = int(input())
# t = int(input())
#
# print(list(primeGenerator(f, t)))

# def make_word():
#     word = ""
#     for ch in "spam":
#         word += ch
#         yield word
#
#
# print(list(make_word()))

# TODO: Decorators (Декораторы)
#  Декораторы позволяют изменять функции, используя другие функции.
#  Это идеально, когда вам нужно расширить функциональность функций, которые вы не хотите изменять.
#  Пример:
# def decor(func):
#     def wrap():
#         print("============")
#         func()
#         print("============")
#
#     return wrap
#
#
# def print_text():
#     print("Hello world!")
#
#
# decorated = decor(print_text)
# decorated()
# TODO: Мы определили функцию с именем decor, которая имеет единственный параметр func.
#  Внутри decor мы определили вложенную функцию с именем wrap (обертка).
#  Функция wrap (обертка) напечатает строку, затем вызовет func() и напечатает другую строку.
#  Функция декора возвращает в качестве результата функцию wrap (обертка).
#  Можно сказать, что декорированная переменная — это декорированная версия print_text — это print_text плюс что-то еще.
#  На самом деле, если бы мы написали полезный декоратор, мы могли бы заменить print_text
#  с украшенной версией в целом, поэтому мы всегда получали нашу версию print_text «плюс что-то» .
#  Это делается путем переназначения переменной, содержащей нашу функцию:
#  Теперь print_text соответствует нашей оформленной версии.
# def decor(func):
#     def wrap():
#         print("============")
#         func()
#         print("============")
#
#     return wrap
#
#
# def print_text():
#     print("Hello world!")
#
#
# print_text = decor(print_text)
# print_text()

# TODO: Decorators (Декораторы)
#  В нашем предыдущем примере мы украсили нашу функцию, заменив переменную, содержащую функцию, обернутой версией.
# def decor(func):
#     def wrap():
#         print("============")
#         func()
#         print("============")
#
#     return wrap
#
#
# def print_text():
#     print("Hello world!")
#
#
# print_text = decor(print_text)
# print_text()
# TODO: Этот шаблон можно использовать в любое время, чтобы обернуть любую функцию.
#  Python поддерживает перенос функции в декоратор, добавляя перед определением функции имя декоратора и символ @.
#  Если мы определяем функцию, мы можем «украсить» ее символом @.
#  Это будет иметь тот же результат, что и приведенный ниже код.
#  У одной функции может быть несколько декораторов.
#  Например:
# def decor(func):
#     def wrap():
#         print("============")
#         func()
#         print("============")
#
#     return wrap
#
#
# @decor
# def print_text():
#     print("Hello world!")
#
#
# print_text()

# TODO: ЗАДАЧА: Decorators (Декораторы)
#  Вы работаете над системой выставления счетов.
#  В системе уже определена функция invoice(), которая принимает в качестве аргумента номер счета и выводит его.
#  Вам нужно добавить декоратор для функции invoice(), который будет печатать счет в следующем формате:
#      Sample Input:
#      42
#      Sample Output:
#      ***
#      INVOICE #42
#      ***
#      END OF PAGE
#  Данный код принимает номер счета-фактуры в качестве входных данных и передает его в функцию invoice().
# def decor(func):
#     def wrap(x):
#         print('***')
#         func(x)
#         print('***')
#         print('END OF PAGE')
#
#     return wrap
#
#
# @decor
# def invoice(num):
#     print(f'INVOICE #{num}')
#
#
# invoice(input())

# TODO: Recursion (Рекурсия)
#  Рекурсия — очень важная концепция в функциональном программировании.
#  Фундаментальной частью рекурсии является самоссылка — функции, вызывающая саму себя.
#  Она используется для решения проблем, которые можно разбить на более простые подзадачи того же типа.
#  Классическим примером рекурсивно реализованной функции является функция факториала,
#  которая находит произведение всех положительных целых чисел, меньших заданного числа.
#  Например, 5! (5 факториал) это 5 * 4 * 3 * 2 * 1 (120).
#  Чтобы реализовать это рекурсивно, обратите внимание, что 5! = 5*4!, 4! = 4 * 3!, 3! = 3 * 2! и так далее.
#  В общем, n! = n * (n-1)!. Кроме того, 1! = 1. Это известно как базовый случай,
#  так как его можно вычислить без дополнительных факториалов.
#  Ниже приведена рекурсивная реализация функции факториала.
#  Базовый случай действует как условие выхода рекурсии.
#  Отсутствие добавления базового варианта приводит к бесконечным вызовам функций, что приводит к сбою программы.
# def factorial(x):
#     if x == 1:
#         return 1
#     else:
#         return x * factorial(x - 1)
#
#
# print(factorial(5))

# TODO: Recursion (Рекурсия)
#  Рекурсия также может быть косвенной.
#  Одна функция может вызывать вторую,
#  которая вызывает первую, которая вызывает вторую и так далее.
#  Это может произойти с любым количеством функций.
#  Пример:
# def is_even(x):
#     if x == 0:
#         return True
#     else:
#         return is_odd(x - 1)
#
#
# def is_odd(x):
#     return not is_even(x)
#
#
# print(is_odd(17))
# print(is_even(23))

# TODO: ЗАДАЧА: Recursion (Рекурсия)
#  Данный код определяет рекурсивную функцию convert(),
#  которая должна преобразовать свой аргумент из десятичного числа в двоичное.
#  Однако в коде есть ошибка.
#  Исправьте код, добавив базовый случай для рекурсии,
#  затем возьмите число из пользовательского ввода и вызовите функцию convert() для вывода результата.
#      Sample Input:
#      8
#      Sample Output:
#      1000
#  Двоичное представление числа 8 равно 1000.
# def convert(num):
#     if num == 0:
#         return 0
#     return num % 2 + 10 * convert(num // 2)
#
#
# x = int(input())
# print(convert(x))

# def fib(x):
#     if x == 0 or x == 1:
#         return 1
#     else:
#         return fib(x - 1) + fib(x - 2)
#
#
# print(fib(4))

# TODO: *args
#  Python позволяет вам иметь функции с различным количеством аргументов.
#  Использование *args в качестве параметра функции позволяет передать произвольное количество аргументов этой функции.
#  Аргументы затем доступны как аргументы кортежа в теле функции.
#  Параметр *args должен идти после именованных параметров функции.
#  Имя args — это просто соглашение; вы можете использовать другой.
#  Пример:
# def function(named_arg, *args):
#     print(named_arg)
#     print(args)
#
#
# function(1, 2, 3, 4, 5)

# TODO: **kwargs
#  **kwargs (расшифровывается как аргументы ключевого слова) позволяет вам обрабатывать именованные аргументы,
#  которые вы не определили заранее.
#  Аргументы ключевого слова возвращают словарь, в котором ключи — это имена аргументов,
#  а значения — значения аргументов.
#  a и b — имена аргументов, которые мы передали вызову функции.
#  Аргументы, возвращаемые **kwargs , не включаются в *args.
#  Пример:
# def my_func(x, y=7, *args, **kwargs):
#     print(kwargs)
#     print(x, y, args, kwargs)
#
#
# my_func(2, 3, 4, 5, 6, a=7, b=8)

# TODO: ЗАДАЧА: *args
#  В данном коде определена функция my_min(), которая принимает два аргумента и возвращает меньший из них.
#  Нужно улучшить функцию, чтобы она могла принимать любое количество переменных, чтобы работал вызов функции.
#  Помните, к *args можно обращаться внутри функции как к кортежу.
# def my_min(*args):
#     return min(args)
#
#
# print(my_min(8, 13, 4, 42, 120, 7))

# nums = {1, 2, 3, 4, 5, 6}
# nums = {0, 1, 2, 3} & nums
# nums = filter(lambda x: x > 1, nums)
# print(len(list(nums)))

# def power(x, y):
#     if y == 0:
#         return 1
#     else:
#         return x * power(x, y - 1)
#
#
# print(power(2, 3))

# def func(**kwargs):
#     print(kwargs["zero"])
#
#
# func(a=0, zero=8)

# TODO: ЗАДАЧА: Spelling Backwards (Правописание в обратном порядке)
#  Получив строку в качестве входных данных, используйте рекурсию для вывода каждой буквы строк
#  в обратном порядке на новой строке.
#      Sample Input:
#      HELLO
#      Sample Output:
#      O
#      L
#      L
#      E
#      H
#  Завершите рекурсивную функцию spell(), чтобы получить ожидаемый результат.
# def spell(txt):
#     for i in txt[::-1]:
#         print(i)
#
#
# t = input()
# spell(t)

# def spell(txt):
#     while len(txt) > 0:
#         print(txt[-1])
#         return spell(txt[:-1])
#
#
# t = input()
# spell(t)

# TODO: Classes (Классы)
#  В основе объектно-ориентированного программирования (ООП) лежат объекты,
#  которые создаются с использованием классов.
#  Класс описывает, каким будет объект, но он отделен от самого объекта.
#  Другими словами, класс можно описать как схему, описание или определение объекта.
#  Вы можете использовать один и тот же класс в качестве схемы для создания нескольких разных объектов.
#  Классы создаются с использованием ключевого слова class и блока с отступом,
#  который содержит методы класса (которые являются функциями).
#  Ниже приведен пример простого класса и его объектов.
# class Cat:
#     def __init__(self, color, legs):
#         self.color = color
#         self.legs = legs
#
#
# felix = Cat("ginger", 4)
# rover = Cat("dog-colored", 4)
# stumpy = Cat("brown", 3)


# TODO: Этот код определяет класс с именем Cat, который имеет два атрибута: цвет и ноги.
#  Затем класс используется для создания 3 отдельных объектов этого класса.

# TODO: __init__ (__горячий__)
#  Метод __init__ — самый важный метод в классе.
#  Он вызывается при создании экземпляра (объекта) класса с использованием имени класса в качестве функции.
#  Все методы должны иметь self в качестве первого параметра, хотя он не передается явно,
#  Python добавляет аргумент self в список за вас; вам не нужно включать его при вызове методов.
#  В определении метода self ссылается на экземпляр, вызывающий метод.
#  Экземпляры класса имеют атрибуты, которые представляют собой фрагменты данных, связанных с ними.
#  В этом примере экземпляры Cat имеют атрибуты цвета и ног.
#  Доступ к ним можно получить, поставив точку и имя атрибута после экземпляра.
#  Таким образом, в методе __init__ self.attribute можно использовать
#  для установки начального значения атрибутов экземпляра.
#  В приведенном выше примере метод __init__ принимает два аргумента и присваивает их атрибутам объекта.
#  Метод __init__ называется конструктором класса.
#  Пример:
# class Cat:
#     def __init__(self, color, legs):
#         self.color = color
#         self.legs = legs
#
#
# felix = Cat("ginger", 4)
# print(felix.color)

# TODO: Methods (Методы)
#  Классы могут иметь другие методы, определенные для добавления к ним функциональности.
#  Помните, что все методы должны иметь self в качестве первого параметра.
#  Доступ к этим методам осуществляется с использованием того же синтаксиса точек, что и у атрибутов.
#  Атрибуты класса являются общими для всех экземпляров класса.
#  Пример:
# class Dog:
#     def __init__(self, name, color):
#         self.name = name
#         self.color = color
#
#     def bark(self):
#         print("Woof!")
#
#
# fido = Dog("Fido", "brown")
# print(fido.name)
# fido.bark()

# TODO: ЗАДАЧА: Methods (Методы)
#  Вы делаете видеоигру! Данный код объявляет класс Player с его атрибутами и методом intro().
#  Завершите код, чтобы взять имя и уровень из пользовательского ввода,
#  создать объект Player с соответствующими значениями и вызвать метод intro() этого объекта.
#      Sample Input:
#      Tony
#      12
#      Sample Output:
#      Tony (Level 12)
#  Используйте точечный синтаксис для вызова метода intro() для объявленного объекта.
# class Player:
#     def __init__(self, name, level):
#         self.name = name
#         self.level = level
#
#     def intro(self):
#         print(self.name + " (Level " + self.level + ")")
#
#
# player = Player(input(), input())
# player.intro()

# TODO: Inheritance (Наследование)
#  Наследование позволяет разделить функциональность между классами.
#  Представьте себе несколько классов, Cat , Dog , Rabbit и так далее.
#  Хотя они могут в чем-то отличаться (только у Dog может быть метод bark),
#  у других они, скорее всего, будут похожи (все имеют атрибуты color и name).
#  Это сходство можно выразить, заставив их всех наследовать от суперкласса Animal, который содержит общие функции.
#  Чтобы наследовать класс от другого класса, поместите имя суперкласса в круглых скобках после имени класса.
#  Пример:
# class Animal:
#     def __init__(self, name, color):
#         self.name = name
#         self.color = color
#
#
# class Cat(Animal):
#     def purr(self):
#         print("Purr...")
#
#
# class Dog(Animal):
#     def bark(self):
#         print("Woof!")
#
#
# fido = Dog("Fido", "brown")
# print(fido.color)
# fido.bark()

# TODO: Inheritance (Наследование)
#  Класс, который наследуется от другого класса, называется подклассом.
#  Класс, который наследуется - называется суперклассом.
#  Если класс наследуется от другого с теми же атрибутами или методами, он переопределяет их.
#  В приведенном ниже примере Волк — это суперклассом (надкласс), а Собака — подкласс.
# class Wolf:
#     def __init__(self, name, color):
#         self.name = name
#         self.color = color
#
#     def bark(self):
#         print("Grr...")
#
#
# class Dog(Wolf):
#     def bark(self):
#         print("Woof")
#
#
# husky = Dog("Max", "grey")
# husky.bark()

# class A:
#     def method(self):
#         print(1)
#
#
# class B(A):
#     def method(self):
#         print(2)
#
#
# B().method()

# TODO: Inheritance (Наследование)
#  Функция super — полезная функция, связанная с наследованием, которая ссылается на родительский класс.
#  Его можно использовать для поиска метода с определенным именем в суперклассе объекта.
#  super().spam() вызывает спам - метод суперкласса.
#  Пример:
# class A:
#     def spam(self):
#         print(1)
#
#
# class B(A):
#     def spam(self):
#         print(2)
#         super().spam()
#
#
# B().spam()

# TODO: ЗАДАЧА: Inheritance (Наследование)
#  Вы создаете приложение для рисования, которое имеет базовый класс Shape.
#  Данный код определяет класс Rectangle, создает объект Rectangle и вызывает его методы area() и perimeter().
#  Для завершения программы выполните следующие действия:
#  1. Унаследуйте класс Rectangle от Shape.
#  2. Определить метод perimeter() в классе Rectangle, печатающий периметр прямоугольника.
#  Периметр равен 2*(ширина+высота)
# class Shape:
#     def __init__(self, w, h):
#         self.width = w
#         self.height = h
#
#     def area(self):
#         print(self.width * self.height)
#
#
# class Rectangle(Shape):
#     def perimeter(self):
#         print(2 * (self.width + self.height))
#
#
# w = int(input())
# h = int(input())
#
# r = Rectangle(w, h)
# print(r.width, r.height)
# r.area()
# r.perimeter()

# TODO: Magic Methods (Магические методы)
#  Магические методы - это специальные методы, имена которых имеют двойное подчеркивание в начале и в конце.
#  Они также известны как дандеры. Пока что мы столкнулись только с __init__ , но есть и некоторые другие.
#  Они используются для создания функциональности, которую нельзя представить в виде обычного метода.
#  Одним из их распространенных применений является перегрузка операторов.
#  Это означает определение операторов для пользовательских классов,
#  которые позволяют использовать в них такие операторы, как + и *.
#  Пример магического метода __add__ для +.
#  Метод __add__ позволяет определить пользовательское поведение для оператора + в нашем классе.
#  Как видите, он добавляет соответствующие атрибуты объектов и возвращает новый объект, содержащий результат.
#  Как только он определен, мы можем добавить два объекта класса вместе.
# class Vector2D:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def __add__(self, other):
#         return Vector2D(self.x + other.x, self.y + other.y)
#
#
# first = Vector2D(5, 7)
# second = Vector2D(3, 9)
# result = first + second
# print(result.x)
# print(result.y)

# TODO: Magic Methods (Магические методы)
#  Еще магические методы для общих операторов:
#  __sub__ for -
#  __mul__ for *
#  __truediv__ for /
#  __floordiv__ for //
#  __mod__ for %
#  __pow__ for **
#  __and__ for &
#  __xor__ for ^
#  __or__ for | Выражение x + y переводится в x.__add__(y)
#  Однако, если x не реализовал __add__, а x и y имеют разные типы, то вызывается y.__radd__(x)
#  Существуют эквивалентные r методов для всех только что упомянутых магических методов.
#  В приведенном ниже примере мы определили операцию деления для нашего класса SpecialString.
#  Пример:
# class SpecialString:
#     def __init__(self, cont):
#         self.cont = cont
#
#     def __truediv__(self, other):
#         line = "=" * len(other.cont)
#         return "\n".join([self.cont, line, other.cont])
#
#
# spam = SpecialString("spam")
# hello = SpecialString("Hello world!")
# print(spam / hello)

# TODO: Magic Methods (Магические методы)
#  Python также предоставляет волшебные методы для сравнения.
#  __lt__ for <
#  __le__ for <=
#  __eq__ for ==
#  __ne__ for !=
#  __gt__ for >
#  __ge__ for >= Если __ne__ не реализовано, возвращается значение, противоположное __eq__
#  Других отношений между другими операторами нет.
#  Как видите, вы можете определить любое пользовательское поведение для перегруженных операторов.
#  Пример:
# class SpecialString:
#     def __init__(self, cont):
#         self.cont = cont
#
#     def __gt__(self, other):
#         for index in range(len(other.cont) + 1):
#             result = other.cont[:index] + ">" + self.cont
#             result += ">" + other.cont[index:]
#             print(result)
#
#
# spam = SpecialString("spam")
# eggs = SpecialString("eggs")
# spam > eggs

# TODO: Magic Methods (Магические методы)
#  Есть несколько волшебных способов заставить классы работать как контейнеры.
#  __len__ для len()
#  __getitem__ для индексации
#  __setitem__ для присвоения индексированным значениям
#  __delitem__ для удаления индексированных значений
#  __iter__ для итерации по объектам (например, in для циклов)
#  __contains__ для in
#  Существует множество других волшебных методов, которые мы не будем здесь рассматривать,
#  например __call__ для вызова объектов как функций и __int__ , __str__ и т.п.
#  для преобразования объектов во встроенные типы.
#  Мы переопределили функцию len() для класса VagueList, чтобы она возвращала случайное число.
#  Функция индексирования также возвращает случайный элемент в диапазоне из списка на основе выражения.
#  Пример:
# import random
#
#
# class VagueList:
#     def __init__(self, cont):
#         self.cont = cont
#
#     def __getitem__(self, index):
#         return self.cont[index + random.randint(-1, 1)]
#
#     def __len__(self):
#         return random.randint(0, len(self.cont) * 2)
#
#
# vague_list = VagueList(["A", "B", "C", "D", "E"])
# print(len(vague_list))
# print(len(vague_list))
# print(vague_list[2])
# print(vague_list[2])

# TODO: ЗАДАЧА: Operator Overloading (Перегрузка оператора)
#  Мы улучшаем наше приложение для рисования.
#  Наше приложение должно поддерживать добавление и сравнение двух объектов Shape.
#  Добавьте соответствующие методы, чтобы включить сложение + и сравнение, используя оператор больше > для класса Shape.
#  Сложение должно возвращать новый объект с суммой ширин и высот операндов,
#  а сравнение должно возвращать результат сравнения площадей объектов.
#  Данный код создает два объекта Shape из пользовательского ввода, выводит область() их добавления и сравнивает их.
# class Shape:
#     def __init__(self, w, h):
#         self.width = w
#         self.height = h
#
#     def area(self):
#         return self.width * self.height
#
#     def __add__(self, other):
#         return Shape(self.width + other.width, self.height + other.height)
#
#     def __gt__(self, other):
#         return self.area() > other.area()
#
#
# w1 = int(input())
# h1 = int(input())
# w2 = int(input())
# h2 = int(input())
#
# s1 = Shape(w1, h1)
# s2 = Shape(w2, h2)
# result = s1 + s2
#
# print(result.area())
# print(s1 > s2)

# TODO: Data Hiding (Скрытие данных)
#  Ключевой частью объектно-ориентированного программирования является инкапсуляция,
#  которая включает упаковку связанных переменных и функций в один простой в использовании объект — экземпляр класса.
#  Родственная концепция — скрытие данных, в которой говорится, что детали реализации класса должны быть скрыты,
#  а для тех, кто хочет использовать класс, должен быть представлен чистый стандартный интерфейс.
#  В других языках программирования это обычно делается с помощью закрытых методов и атрибутов,
#  которые блокируют внешний доступ к определенным методам и атрибутам в классе. Философия Python немного отличается.
#  Часто говорят, что «мы все здесь взрослые по обоюдному согласию», что означает,
#  что вы не должны накладывать произвольные ограничения на доступ к частям класса.
#  Следовательно, нет способов обеспечить, чтобы метод или атрибут были строго закрытыми.
#  Однако есть способы отговорить людей от доступа к частям класса, например, обозначив,
#  что это деталь реализации, которую следует использовать на свой страх и риск.

# TODO: Data Hiding (Скрытие данных)
#  Слабо приватные методы и атрибуты имеют одно подчеркивание в начале.
#  Это сигнализирует о том, что они являются частными и не должны использоваться внешним кодом.
#  Однако в основном это всего лишь соглашение, которое не препятствует доступу к ним внешнего кода.
#  В приведенном выше коде атрибут _hiddenlist помечен как приватный,
#  но к нему по-прежнему можно получить доступ во внешнем коде.
#  Магический метод __repr__ используется для строкового представления экземпляра.
#  Пример:
# class Queue:
#     def __init__(self, contents):
#         self._hiddenlist = list(contents)
#
#     def push(self, value):
#         self._hiddenlist.insert(0, value)
#
#     def pop(self):
#         return self._hiddenlist.pop(-1)
#
#     def __repr__(self):
#         return f'Queue({self._hiddenlist})'
#
#
# queue = Queue([1, 2, 3])
# print(queue)
# queue.push(0)
# print(queue)
# queue.pop()
# print(queue)
# print(queue._hiddenlist)

# TODO: Data Hiding (Скрытие данных)
#  Строгие частные методы и атрибуты имеют двойное подчеркивание в начале своего имени.
#  Это приводит к тому, что их имена искажаются, а это означает, что к ним нельзя получить доступ извне класса.
#  Цель этого не в том, чтобы гарантировать их приватность, а во избежание ошибок, если есть подклассы,
#  которые имеют методы или атрибуты с теми же именами.
#  Доступ к методам с измененным именем по-прежнему можно получить извне, но под другим именем.
#  К методу __privatemethod класса Spam можно было получить доступ извне с помощью _Spam__privatemethod.
#  По сути, Python защищает эти члены, внутренне изменяя имя, чтобы оно включало имя класса.
#  Пример:
# class Spam:
#     __egg = 7
#
#     def print_egg(self):
#         print(self.__egg)
#
#
# s = Spam()
# s.print_egg()
# print(s._Spam__egg)
# print(s.__egg)

# TODO: ЗАДАЧА: Data Hiding (Скрытие данных)
#  Мы работаем над игрой. Наш класс Player имеет атрибуты name и private _lives.
#  Метод hit() должен уменьшать жизни игрока на 1. Если жизни равны 0, он должен выводить «Game Over».
#  Завершите метод hit(), чтобы программа работала должным образом.
#  Код создает объект Player и несколько раз вызывает его метод hit().
# class Player:
#     def __init__(self, name, lives):
#         self.name = name
#         self._lives = lives
#
#     def hit(self):
#         self._lives -= 1
#         if self._lives == 0:
#             print('Game Over')
#
#
# p = Player("Cyberpunk77", 3)
# p.hit()
# p.hit()
# p.hit()

# TODO: Class Methods (Методы класса)
#  Методы объектов, которые мы рассмотрели до сих пор, вызываются экземпляром класса,
#  который затем передается параметру self метода.
#  Методы класса разные — они вызываются классом, который передается в параметр cls метода.
#  Обычно они используются в фабричных методах, которые создают экземпляр класса с использованием параметров,
#  отличных от тех, которые обычно передаются конструктору класса.
#  Методы класса отмечены декоратором classmethod.
#  new_square — это метод класса, который вызывается в классе, а не в экземпляре класса.
#  Он возвращает новый объект класса cls.
#  Технически параметры self и cls — это просто соглашения; их можно поменять на что угодно.
#  Тем не менее, им следуют повсеместно, поэтому разумно придерживаться их.
#  Пример:
# class Rectangle:
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height
#
#     def calculate_area(self):
#         return self.width * self.height
#
#     @classmethod
#     def new_square(cls, side_length):
#         return cls(side_length, side_length)
#
#
# square = Rectangle.new_square(5)
# print(square.calculate_area())

# TODO: Static Methods (Статические методы)
#  Статические методы аналогичны методам класса, за исключением того,
#  что они не получают никаких дополнительных аргументов; они идентичны обычным функциям, принадлежащим классу.
#  Они отмечены декоратором staticmethod.
#  Статические методы ведут себя как обычные функции, за исключением того, что их можно вызывать из экземпляра класса.
#  Пример:
# class Pizza:
#     def __init__(self, toppings):
#         self.toppings = toppings
#
#     @staticmethod
#     def validate_topping(topping):
#         if topping == "pineapple":
#             raise ValueError("No pineapples!")
#         else:
#             return True
#
#
# ingredients = ["cheese", "onions", "spam"]
# if all(Pizza.validate_topping(i) for i in ingredients):
#     pizza = Pizza(ingredients)

# TODO: ЗАДАЧА: Static Methods (Статические методы)
#  Данный код принимает на вход 2 числа и вызывает метод static area() класса Shape,
#  для вывода площади фигуры, равной: высоте * ширину.
#  Чтобы код работал, вам нужно определить класс Shape и метод static area(),
#  который должен возвращать произведение двух своих аргументов.
#  Используйте декоратор @staticmethod для определения статического метода.
# class Shape:
#     def __init__(self):
#         self.weight = w
#         self.height = h
#
#     @staticmethod
#     def area(weight, height):
#         return weight * height
#
#
# w = int(input())
# h = int(input())
#
# print(Shape.area(w, h))

# TODO: Properties (Характеристики)
#  Свойства предоставляют способ настройки доступа к атрибутам экземпляра.
#  Они создаются путем размещения декоратора свойства над методом, что означает,
#  что при доступе к атрибуту экземпляра с тем же именем, что и у метода, вместо этого будет вызываться метод.
#  Одно из распространенных применений свойства — сделать атрибут доступным только для чтения.
#  Пример:
# class Pizza:
#     def __init__(self, toppings):
#         self.toppings = toppings
#
#     @property
#     def pineapple_allowed(self):
#         return False
#
#
# pizza = Pizza(["cheese", "tomato"])
# print(pizza.pineapple_allowed)
# pizza.pineapple_allowed = True

# TODO: Properties (Характеристики)
#  Свойства также можно установить, определив функции setter/getter (установки/получения).
#  Функция установки устанавливает значение соответствующего свойства.
#  Геттер получает значение.
#  Чтобы определить setter, вам нужно использовать декоратор с тем же именем, что и у свойства,
#  за которым следует точка и ключевое слово setter.
#  То же самое относится к определению функций получения.
#  Пример:
# class Pizza:
#     def __init__(self, toppings):
#         self.toppings = toppings
#         self._pineapple_allowed = False
#
#     @property
#     def pineapple_allowed(self):
#         return self._pineapple_allowed
#
#     @pineapple_allowed.setter
#     def pineapple_allowed(self, value):
#         if value:
#             password = input("Enter the password: ")
#             if password == "Sw0rdf1sh!":
#                 self._pineapple_allowed = value
#             else:
#                 raise ValueError("Alert! Intruder!")
#
#
# pizza = Pizza(["cheese", "tomato"])
# print(pizza.pineapple_allowed)
# pizza.pineapple_allowed = True
# print(pizza.pineapple_allowed)

# TODO: ЗАДАЧА: Properties (Характеристики)
#  Мы улучшаем нашу игру и должны добавить свойство isAlive, которое возвращает True,
#  если количество жизней больше 0.
#  Завершите код, добавив свойство isAlive.
#  Код использует цикл while для обращения к Player до тех пор,
#  пока его количество жизней не станет равным 0, используя свойство isAlive для создания условия.
# class Player:
#     def __init__(self, name, lives):
#         self.name = name
#         self._lives = lives
#
#     def hit(self):
#         self._lives -= 1
#
#     @property
#     def isAlive(self):
#         if self._lives > 0:
#             return True
#
#
# p = Player("Cyberpunk77", int(input()))
# i = 1
# while True:
#     p.hit()
#     print(f'Hit # {i}')
#     i += 1
#     if not p.isAlive:
#         print("Game Over")
#         break

# TODO: ЗАДАЧА: Shooting Game (Стрелялки)
#  Вы создаете стрелялку!
#  В игре есть два типа врагов, инопланетяне и монстры.
#  Вы стреляете в инопланетян с помощью лазера, а в монстров с помощью пистолета.
#  Каждое попадание уменьшает количество жизней врагов на 1.
#  Данный код объявляет общий класс Enemy, а также классы Alien и Monster с соответствующим количеством жизней.
#  Он также определяет метод hit() для класса Enemy.
#  Для завершения программы вам необходимо сделать следующее:
#  1. Наследовать классы Alien и Monster от класса Enemy.
#  2. Завершите цикл while, который непрерывно берет выбранное оружие из пользовательского ввода
#  и вызывает метод hit() соответствующего объекта. Выход из лазерной пушки
#      Sample Input:
#      laser
#      laser
#      gun
#      exit
#      Sample Output:
#      Alien has 4 lives
#      Alien has 3 lives
#      Monster has 2 lives
#  Цикл while останавливается, когда пользователь вводит « выход ».
# class Enemy:
#     name = ""
#     lives = 0
#
#     def __init__(self, name, lives):
#         self.name = name
#         self.lives = lives
#
#     def hit(self):
#         self.lives -= 1
#         if self.lives <= 0:
#             print(self.name + ' killed')
#         else:
#             print(self.name + ' has ' + str(self.lives) + ' lives')
#
#
# class Monster(Enemy):
#     def __init__(self):
#         super().__init__('Monster', 3)
#
#
# class Alien(Enemy):
#     def __init__(self):
#         super().__init__('Alien', 5)
#
#
# m = Monster()
# a = Alien()
#
# while True:
#     x = input()
#     if x == 'exit':
#         break
#     elif x == 'laser':
#         a.hit()
#     elif x == 'gun':
#         m.hit()

# TODO: Exceptions (Исключения)
#  Вы уже видели исключения в предыдущем коде. Они возникают, когда что-то идет не так,
#  из-за неправильного кода или ввода.
#  При возникновении исключения программа немедленно останавливается.
#  Следующий код создает исключение ZeroDivisionError при попытке разделить 7 на 0:
#  Исключением является событие, которое происходит во время выполнения программы и нарушает нормальный ход программы.
# num1 = 7
# num2 = 0
# print(num1 / num2)

# TODO: Exceptions (Исключения)
#  Разные исключения вызываются по разным причинам.
#  Общие исключения:
#  ImportError: сбой импорта;
#  IndexError: список проиндексирован с номером вне допустимого диапазона;
#  NameError: используется неизвестная переменная;
#  SyntaxError: код не может быть проанализирован должным образом;
#  TypeError: функция вызывается для значения неподходящего типа;
#  ValueError: функция вызывается для значения правильного типа, но с неподходящим значением.
#  Python имеет несколько других встроенных исключений, таких как ZeroDivisionError и OSError.
#  Сторонние библиотеки также часто определяют свои собственные исключения.

# TODO: Исключение вызовет ошибку TypeError:
#      print("7" + 4)
