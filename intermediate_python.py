# TODO: Intermediate Python (Промежуточный Python)
#  Если вы уже знакомы с основами Python и хотите расширить свои знания, этот курс для вас.
#  Вы узнаете о типах коллекций Python, лямбда-функциях, генераторах, декораторах,
#  объектно-ориентированном программировании и многом другом.

# TODO: Welcome! (Добро пожаловать!)
#  Добро пожаловать на курс Python для среднего уровня.
#  В этом курсе вы узнаете о типах коллекций Python, лямбда-функциях, генераторах, декораторах, ООП и многом другом.
#  Мы также создадим реальные проекты и решим несколько задач программирования.
#  Этот курс предназначен для разработчиков Python среднего уровня,
#  которые уже знают основы Python и хотят расширить свои знания.
#  Если вы новичок в Python, мы предлагаем вам начать с нашего курса Python для начинающих.
# n = [2, 4, 6, 8]
# res = 1
# for x in n[1:3]:
#     res *= x
#
# print(res)

# TODO: Dictionaries (Словари)
#  Python предоставляет ряд встроенных типов коллекций для хранения нескольких значений.
#  Списки являются одним из этих типов коллекций и позволяют хранить индексированные значения:
# x = ['hi', 'hello', 'welcome']
# print(x[2])
# TODO: Каждый элемент списка имеет индекс, который устанавливается автоматически.
#  Словари — это еще один тип коллекций, которые позволяют сопоставлять произвольные ключи со значениями.
#  Словари можно индексировать так же, как и списки, используя квадратные скобки, содержащие ключи.
#  Каждый элемент словаря представлен парой ключ:значение.
#  Пример:
# ages = {"Dave": 24, "Mary": 42, "John": 58}
# print(ages["Dave"])
# print(ages["Mary"])

# TODO: Dictionaries (Словари)
#  В качестве ключей к словарям можно использовать только неизменяемые объекты.
#  Неизменяемые объекты — это объекты, которые нельзя изменить.
#  До сих пор единственными изменяемыми объектами, с которыми вы сталкивались, были списки и словари.
#  Поскольку списки изменяемы, приведенный ниже код выдает ошибку.
#  Это означает, что вы можете использовать строки, целые числа,
#  логические значения и любые другие неизменяемые типы в качестве ключей словаря.
# bad_dict = {
#     [1, 2, 3]: "one two three",
# }

# TODO: ЗАДАЧА: Dictionaries Словари
#  Вы работаете в автосалоне и храните данные об автомобиле в словаре:
#  car = {
#     'brand': 'BMW',
#     'year': 2018,
#     'color': 'red'
#  }
#  Ваша программа должна принимать ключ в качестве входных данных и выводить соответствующее значение.
#  Sample Input:
#  year
#  Sample Output:
#  2018
#  Данные уже определены в коде.
# car = {
#     'brand': 'BMW',
#     'year': 2018,
#     'color': 'red',
#     'mileage': 15000
# }
# print(car[input()])

# TODO: Dictionaries (Словари)
#  Чтобы определить, находится ли ключ в словаре, вы можете использовать in и not in так же, как и для списка.
#  Пример:
# nums = {
#     1: "one",
#     2: "two",
#     3: "three",
# }
# print(1 in nums)
# print("three" in nums)
# print(4 not in nums)

# TODO: Dictionaries (Словари) Полезной словарной функцией является get.
#  Он делает то же самое, что и индексация, но если ключ не найден в словаре,
#  вместо этого возвращается другое указанное значение.
#  Чтобы определить количество элементов в словаре, используйте функцию len() .
#  Пример:
# pairs = {1: "apple",
#          "orange": [2, 3, 4],
#          True: False,
#          12: "True",
#          }
#
# print(pairs.get("orange"))
# print(pairs.get(7, 42))
# print(pairs.get(12345, "not found"))

# TODO: ЗАДАЧА: Dictionary Functions (Функции словаря)
#  Вы работаете с данными, отражающими рейтинг экономической свободы по странам.
#  Каждое название страны и ранг хранятся в словаре, где ключом является название страны.
#  Завершите программу, чтобы взять название страны в качестве входных данных
#  и вывести соответствующий рейтинг экономической свободы.
#  Если указанное название страны отсутствует в данных, выведите «Not found».
#  Вспомните метод словаря get(), который позволяет указать значение по умолчанию.
# data = {
#     'Singapore': 1,
#     'Ireland': 6,
#     'United Kingdom': 7,
#     'Germany': 27,
#     'Armenia': 34,
#     'United States': 17,
#     'Canada': 9,
#     'Italy': 74
# }
# print(data.get(input(), 'Not found'))

# fib = {1: 1, 2: 1, 3: 2, 4: 3}
# print(fib.get(4, 0) + fib.get(7, 5))

# TODO: Tuples (Кортежи)
#  Кортежи очень похожи на списки, за исключением того, что они неизменяемы (их нельзя изменить).
#  Кроме того, они создаются с использованием круглых скобок, а не квадратных скобок.
#  Пример:
#  words = ("spam", "eggs", "sausages")
#  Вы можете получить доступ к значениям в кортеже с их индексом, как и со списками:
# words = ("spam", "eggs", "sausages",)
# print(words[0])
# TODO: Попытка переназначить значение в кортеже приводит к ошибке.
#  Подобно спискам и словарям, кортежи могут быть вложены друг в друга.
# words = ("spam", "eggs", "sausages",)
# words[1] = "cheese"

# TODO: Tuples (Кортежи)
#  Кортежи можно создавать без круглых скобок, просто разделяя значения запятыми.
#  Кортежи быстрее, чем списки, но их нельзя изменить.
#  Пример:
# my_tuple = "one", "two", "three"
# print(my_tuple[0])

# TODO: ЗАДАЧА: Tuples (Кортежи)
#  Вам предоставляется список контактов, где каждый контакт представлен кортежем с именем и возрастом контакта.
#  Завершите программу, чтобы получить строку в качестве входных данных,
#  найти имя в списке контактов и вывести возраст контакта в формате, представленном ниже:
#  Sample Input:
#  John
#  Sample Output:
#  John is 31
#  Если контакт не найден, программа должна вывести "Not Found".
# contacts = [
#     ('James', 42),
#     ('Amy', 24),
#     ('John', 31),
#     ('Amanda', 63),
#     ('Bob', 18)
# ]
# dict_contacts = dict(contacts)
# name = input()
# if name in dict_contacts:
#     print(f'{name} is {dict_contacts[name]}')
# else:
#     print('Not Found')

# contacts = [
#     ('James', 42),
#     ('Amy', 24),
#     ('John', 31),
#     ('Amanda', 63),
#     ('Bob', 18),
# ]
# name = input().lower()
# for i in contacts:
#     if name in str(i).lower():
#         print(f'{i[0]} is {i[1]}')
#         break
# else:
#     print('Not Found')

# TODO: Tuple Unpacking (Распаковка кортежа)
#  Распаковка кортежей позволяет присвоить каждый элемент коллекции переменной.
#  Это также можно использовать для замены переменных, выполнив a, b = b, a,
#  поскольку b, a в правой части формирует кортеж (b, a), который затем распаковывается.
#  Пример:
# numbers = (1, 2, 3)
# a, b, c = numbers
# print(a)
# print(b)
# print(c)

# TODO: Tuple Unpacking (Распаковка кортежа)
#  Переменная, перед которой стоит звездочка (*),
#  принимает все значения из коллекции, оставшиеся от других переменных.
#  c будут присвоены значения от 3 до 8.
#  Пример:
# a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# print(a)
# print(b)
# print(c)
# print(d)

# TODO: ЗАДАЧА: Tuple Unpacking (Распаковка кортежа)
#  Кортежи можно использовать для вывода нескольких значений функции.
#  Вам нужно создать функцию с именем calc(), которая будет принимать длину стороны квадрата
#  в качестве аргумента и возвращать периметр и площадь, используя кортеж.
#  Периметр — это сумма всех сторон, а площадь — это квадрат длины стороны.
#  Данный код берет число из пользовательского ввода, передает его функции calc()
#  и использует распаковку для получения возвращаемых значений.
#      Sample Input:
#      3
#      Sample Output:
#      Perimeter: 12
#      Area: 9
# def calc(x):
#     return x * 4, x ** 2
#
#
# side = int(input())
# p, a = calc(side)
#
# print(f'Perimeter: {p}')
# print(f'Area: {a}')

# a, b, c, d, *e, f, g = range(20)
# print(len(e))

# TODO: Sets (Множества, Наборы)
#  Наборы похожи на списки или словари.
#  Они создаются с помощью фигурных скобок и не упорядочены,
#  что означает, что они не могут быть проиндексированы.
#  Из-за того, как они хранятся, быстрее проверить,
#  является ли элемент частью набора, используя оператор in, а не часть списка.
#  Наборы не могут содержать повторяющиеся элементы.
# num_set = {1, 2, 3, 4, 5}
#
# print(3 in num_set)
# print(3 not in num_set)

# letters = {"a", "b", "c", "d"}
# if "e" not in letters:
#     print(1)
# else:
#     print(2)

# TODO: Sets (Множества, Наборы)
#  Вы можете использовать функцию add() для добавления новых элементов в набор
#  и remove() для удаления определенного элемента:
#  Повторяющиеся элементы будут автоматически удалены из набора.
#  Функцию len() можно использовать для возврата количества элементов набора.
# nums = {1, 2, 1, 3, 1, 4, 5, 6}
# print(nums)
# nums.add(-7)
# nums.remove(3)
# print(nums)

# TODO: Sets (Множества, Наборы)
#  Наборы можно комбинировать с помощью математических операций.
#  Оператор объединения | объединяет два набора, чтобы сформировать новый, содержащий элементы в любом из них.
#  Оператор пересечения & получает элементы только в обоих случаях.
#  Оператор разности - получает элементы в первом наборе, но не во втором.
#  Оператор симметричной разности ^ получает элементы в любом наборе, но не в обоих одновременно.
# first = {1, 2, 3, 4, 5, 6}
# second = {4, 5, 6, 7, 8, 9}
#
# print(first | second)
# print(first & second)
# print(first - second)
# print(second - first)
# print(first ^ second)

# TODO: ЗАДАЧА: Sets (Множества, Наборы)
#  Вы работаете над рекрутинговой платформой,
#  которая должна соответствовать имеющимся вакансиям и кандидатам в зависимости от их навыков.
#  Навыки, необходимые для работы, и навыки кандидата хранятся в наборах.
#  Завершите программу, чтобы вывести соответствующий навык.
#  Вы можете использовать оператор пересечения, чтобы получить значения, присутствующие в обоих наборах.
# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(*skills & job_skills)

# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(' '.join(skills & job_skills))

# skills = {'Python', 'HTML', 'SQL', 'C++', 'Java', 'Scala'}
# job_skills = {'HTML', 'CSS', 'JS', 'C#', 'NodeJS'}
# print(list(skills & job_skills)[0])

# a = {1, 2, 3}
# b = {0, 3, 4, 5}
# print(a & b)

# TODO: List Comprehensions (генераторы списка)
#  Генерация списков — это полезный способ быстрого создания списков, содержимое которых подчиняется правилу.
#  Например, мы можем сделать следующее:
#  Генераторы списков вдохновлены нотацией построителя множеств в математике.
# # a list comprehension
# cubes = [i ** 3 for i in range(5)]
#
# print(cubes)

# TODO: List Comprehensions (генераторы списка)
#  Генерация списка также может содержать оператор if для принудительного применения условия к значениям в списке.
#  Пример:
# evens = [i ** 2 for i in range(10) if i ** 2 % 2 == 0]
#
# print(evens)

# TODO: ЗАДАЧА: List Comprehensions (генераторы списка)
#  По заданному слову выведите список, содержащий только те буквы слова, которые не являются гласными.
#  Гласные  a, e, i, o, u.
#  Используйте генерацию списка, чтобы создать требуемый список букв и вывести его.
#      Sample Input:
#      awesome
#      Sample Output:
#      ['w', 's', 'm']
# word = input()
# print([x for x in word if x not in ['a', 'e', 'i', 'o', 'u']])

# TODO: Data Structures (Структуры данных)
#  Как мы видели в предыдущих уроках, Python поддерживает следующие типы коллекций:
#  - Lists
#  - Dictionaries
#  - Tuples
#  - Sets
#  Когда использовать словарь:
#  - Когда вам нужна логическая ассоциация между парой ключ: значение.
#  - Когда вам нужен быстрый поиск ваших данных на основе пользовательского ключа.
#  - Когда ваши данные постоянно изменяются. Помните, что словари изменяемы.
#  Когда использовать другие типы:
#  - Используйте списки, если у вас есть коллекция данных, не требующая произвольного доступа,
#  когда вам нужна простая итерируемая коллекция, которая часто изменяется.
#  - Используйте набор, если вам нужна уникальность для элементов.
#  - Используйте кортежи, когда ваши данные не могут или не должны изменяться.
#  Часто кортеж используется в сочетании со словарем,
#  например, кортеж может представлять ключ, потому что он неизменяем.

# a = (1, 2, 3, 1)
# print(a[0:2])

# nums = (55, 44, 33, 22)
# print(max(min(nums[:2]), abs(-42)))

# TODO: ЗАДАЧА: Letter Counter (Счетчик писем)
#  Учитывая строку в качестве входных данных, вам нужно вывести, сколько раз каждая буква встречается в строке.
#  Вы решаете хранить данные в словаре, используя буквы в качестве ключей
#  и соответствующие значения в качестве значений.
#  Создайте программу, которая принимает строку в качестве входных данных
#  и выводит словарь, представляющий количество букв.
#  Вам нужно вывести объект словаря.
#  Обратите внимание, что буквы расположены в порядке появления в строке.
#      Sample Input:
#      hello
#      Sample Output:
#      {'h': 1, 'e': 1, 'l': 2, 'o': 1}
# text = input().lower()
# dict = {}
# for x in text:
#     dict[x] = text.count(x)
#
# print(dict)

# text = input()
# print({x: text.count(x) for x in text})

# TODO: Functional Programming (Функциональное программирование)
#  Функциональное программирование — это стиль программирования,
#  который (как следует из названия) основан на функциях.
#  Ключевой частью функционального программирования являются функции высшего порядка.
#  Функции более высокого порядка принимают другие функции
#  в качестве аргументов или возвращают их в качестве результатов.
#  Функция apply_twice принимает в качестве аргумента другую функцию и дважды вызывает ее внутри своего тела.
#  Пример:
# def apply_twice(func, arg):
#     return func(func(arg))
#
#
# def add_five(x):
#     return x + 5
#
#
# print(apply_twice(add_five, 10))

# def test(func, arg):
#     return func(func(arg))
#
#
# def mult(x):
#     return x * x
#
#
# print(test(mult, 2))

# TODO: Pure Functions (Чистые функции)
#  Функциональное программирование стремится использовать чистые функции.
#  Чистые функции не имеют побочных эффектов и возвращают значение, которое зависит только от их аргументов.
#  Вот как работают функции в математике: например, cos(x) для одного и того же значения x
#  всегда будет возвращать один и тот же результат.
#  Ниже приведены примеры чистых и нечистых функций.
# TODO: Чистая функция:
# def pure_function(x, y):
#     temp = x + 2 * y
#     return temp / (2 * x + y)
#
#
# TODO: Нечистая функция:
# some_list = []
#
#
# def impure(arg):
#     some_list.append(arg)
# TODO: Приведенная выше функция не является чистой, потому что она изменила состояние some_list.

# def func(x):
#     y = x ** 2
#     z = x + y
#     return z
#
#
# print(func(5))

# TODO: Pure Functions (Чистые функции)
#  Использование чистых функций имеет как преимущества, так и недостатки.
#  Чистые функции:
#  - легче рассуждать и тестировать.
#  - более эффективным. После того, как функция была оценена для ввода,
#  результат может быть сохранен и использован в следующий раз, когда функция этого ввода потребуется,
#  что сократит количество вызовов функции. Это называется мемоизацией .
#  - легче работать параллельно.
#  Чистые функции в некоторых ситуациях написать сложнее.
