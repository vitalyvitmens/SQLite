"""
Python for Data Science:
Python широко используется в науке о данных и имеет надежный набор мощных инструментов для обмена данными.
В этом курсе вы узнаете о различных библиотеках Python, используемых для обработки и визуализации данных,
таких как numpy, pandas, matplotlib и других.
"""
# TODO: Добро пожаловать на наш курс Python для науки о данных!
#  В этом курсе вы узнаете о самых популярных библиотеках Python,
#  используемых в науке о данных: numpy, pandas и matplotlib .
#  Мы будем решать реальные проблемы, решать задачи, анализировать реальные данные и визуализировать полученные данные!
#  Если вы не знакомы с базовым синтаксисом Python,
#  лучше сначала пройти наши курсы Python для начинающих и Структуры данных Python, прежде чем начинать этот.

# TODO: Python — язык программирования №1 для Data Science, и на то есть веские причины:
#  — Python легко освоить.
#  - Синтаксис легко читать и понимать.
#  - Есть много полезных библиотек для выполнения вычислений и других операций.
#  Как правило, код Python также намного короче по сравнению с другими языками программирования.

# TODO: Statistics (Статистика)
#  Наука о данных использует различные техники и методы для извлечения знаний и статистики из данных.
#  Давайте сначала погрузимся в некоторые основы статистики.
#  Эти концепции составляют основные строительные блоки анализа данных.
#  В качестве примера набора данных рассмотрим цены на группу товаров:
#  [18, 24, 67, 55, 42, 14, 19, 26, 33]
#  Данный набор данных включает цены на 9 товаров. Среднее значение — это среднее значение набора данных.
#  Мы можем рассчитать его, сложив все цены вместе и разделив на количество продуктов: среднее значение = 298/9 = 33,1.
#  Обратите внимание, что среднее значение обычно не является частью нашего набора данных.
# from statistics import mean
#
# x = [2, 4, 6, 8]
# a = sum(x) / len(x)
# b = mean(x)
# print(round(a, 1))
# print(b)

# TODO: Median (медиана)
#  Еще одна полезная концепция — медиана: среднее значение упорядоченного набора данных.
#  Чтобы вычислить медиану для нашего набора данных о ценах, давайте сначала упорядочим его в порядке возрастания:
#  [14, 18, 19, 24, 26, 33, 42, 55, 67]
#  Медиана равна 26, так как это среднее значение.
#  Если бы в нашем наборе данных было четное количество значений,
#  мы бы взяли два значения посередине и вычислили их среднее значение.
#  Медиана обычно более полезна, чем среднее значение.
#  Это связано с тем, что среднее значение может сильно различаться из-за того,
#  что одно значение намного больше или меньше других.
#  Среднее значение и медиана называются показателями центральной тенденции,
#  поскольку они описывают, где находится центр наших данных.
# from statistics import median
#
# x = [2, 2, 3, 5, 8, 9]
# print(median(x))

# TODO: ЗАДАЧА: Количество прививок
#  У нас есть отчет о количестве прививок от гриппа в классе из 20 человек.
#  Он имеет следующие числа:
#  - никогда: 5
#  - единожды: 8
#  - дважды: 4
#  - трижды: 3
#  Каково среднее количество раз, когда эти люди были вакцинированы? Выведите результат с помощью оператора print().
#  Подсказка: подумайте о данных следующим образом: они содержат 20 значений,
#  каждое из которых представляет количество прививок, сделанных соответствующему человеку.
# vac_nums = [0, 0, 0, 0, 0,
#             1, 1, 1, 1, 1, 1, 1, 1,
#             2, 2, 2, 2,
#             3, 3, 3
#             ]
# print(sum(vac_nums) / len(vac_nums))

# TODO: Standard Deviation (Стандартное отклонение)
#  Стандартное отклонение — это мера того, насколько разбросаны наши данные.
#  Чтобы вычислить его, нам сначала нужно вычислить значение, называемое дисперсией:
#  это среднее значение квадратов отличий от среднего.
#  Итак, для наших ценовых данных:
#  [14, 18, 19, 24, 26, 33, 42, 55, 67]
#  среднее значение 33,1.
#  Чтобы вычислить дисперсию, мы берем разницу между каждым значением и средним значением, возводим ее в квадрат, а
#  затем усредняем результат:
#  можно проверить, какие возрасты находятся в пределах одного стандартного отклонения (17,1)
#  от среднего (33,1) - от (33,1-17,1) до (33,1+17,1):
#  [14, 18, 19, 24, 26, 33, 42, 55, 67]
#  Как видите, 6 значений из 9 находятся в этом диапазоне.
#  Низкое стандартное отклонение указывает на то, что значения имеют тенденцию быть близкими к среднему значению набора,
#  в то время как высокое стандартное отклонение указывает на то, что значения разбросаны по более широкому диапазону.
# from statistics import *
#
# x = [2, 2, 2, 2]
# mean = round(mean(x), 1)
# print(mean)
# dispersions = []
# for i in x:
#     a = round((i - mean), 1)
#     dispersions.append(a)
# print(dispersions)
# dispersion = []
# for i in dispersions:
#     a = round((i ** 2))
#     dispersion.append(a)
# print(dispersion)
# disper = (sum(dispersion) / len(dispersion)) ** 0.5
# print(round(disper, 1))
# b = []
# for i in x:
#     if mean - disper <= i <= mean + disper:
#         b.append(i)
# print(b)
# print(len(b))

# TODO: Статистика
#  Мы узнали, как рассчитать основную сводную статистику для набора данных:
#  mean (среднее значение): среднее значение.
#  median (медиана): медианное значение.
#  standard deviation (стандартное отклонение): мера разброса.
#  Эти статистические данные предоставляют информацию о вашем наборе данных и помогают понять,
#  где находятся значения ваших данных и как они распределяются.
#  Python предоставляет библиотеки, которые вычисляют для вас сводную статистику. О них мы узнаем на следующих уроках.

# TODO: ЗАДАЧА: Количество прививок
#  Использование того же набора данных о прививках,
#  который включает количество раз, когда люди получали вакцину против гриппа.
#  Набор данных содержит следующие числа:
#  - никогда: 5
#  - единожды: 8
#  - дважды: 4
#  - трижды: 3
#  Рассчитайте и выведите дисперсию.
#  Вскоре мы узнаем о более простых способах расчета дисперсии и других сводных статистических данных с помощью Python.
#  А пока используйте код Python для вычисления результата с помощью соответствующего уравнения.
#  Подсказка : Дисперсия – это среднее квадратов отличий от среднего.
# import numpy as np
#
# vac_nums = [0, 0, 0, 0, 0,
#             1, 1, 1, 1, 1, 1, 1, 1,
#             2, 2, 2, 2,
#             3, 3, 3
#             ]
# a = np.array(vac_nums)
# mean = np.sum(a) / a.size
# v = np.sum((a - mean) ** 2) / a.size
# print(v)

# vac_nums = [0, 0, 0, 0, 0,
#             1, 1, 1, 1, 1, 1, 1, 1,
#             2, 2, 2, 2,
#             3, 3, 3
#             ]
# mean = sum(vac_nums) / len(vac_nums)
# v = []
# for i in vac_nums:
#     v.append((i - mean) ** 2)
# v1 = sum(v) / len(v)
# print(v)
# print(v1)

# TODO: ЗАДАЧА: Баскетболисты
#  Данный код включает в себя список роста для различных баскетболистов.
#  Вам нужно рассчитать и вывести, сколько игроков находится в диапазоне одного стандартного отклонения от среднего.
#  Выведите результат с помощью оператора печати.
# players = [180, 172, 178, 185, 190, 195, 192, 200, 210, 190]
# mean = sum(players) / len(players)
# dispersions = []
# for i in players:
#     a = i - mean
#     dispersions.append(a)
# dispersion = []
# for i in dispersions:
#     a = i ** 2
#     dispersion.append(a)
# disper = (sum(dispersion) / len(dispersion)) ** 0.5
# b = []
# for i in players:
#     if mean - disper <= i <= mean + disper:
#         b.append(i)
# print(len(b))

# TODO: NumPy (Numerical Python)(Числовой Python) — это библиотека Python, используемая для работы с числовыми данными.
#  NumPy включает в себя функции и структуры данных, которые могут выполнять широкий спектр математических операций.
#  Чтобы начать использовать NumPy, нам сначала нужно его импортировать:
#  импортировать numpy как np
#  import numpy as np
#  np — наиболее распространенное имя, используемое для импорта numpy.

# TODO: NumPy Array Массив NumPy
#  В Python списки используются для хранения данных.
#  NumPy предоставляет структуру массива для выполнения операций с данными.
#  Массивы NumPy быстрее и компактнее списков. Массив NumPy можно создать с помощью функции np.array(),
#  предоставив ей список в качестве аргумента:
#  x = np.array([1, 2, 3, 4])
#  Теперь x — это массив NumPy, содержащий 4 значения.
#  Мы можем получить доступ к его элементам, используя их индексы, которые начинаются с 0:
#  Массивы NumPy являются гомогенными, то есть они могут содержать только один тип данных,
#  тогда как списки могут содержать несколько разных типов данных.
# import numpy as np
#
# x = np.array([1, 2, 3, 4])
# print(x[0])
# mean = np.sum(x) / x.size
# print(mean)
# v = np.sum((x - mean) ** 2) / x.size
# print(v)

# TODO: NumPy Arrays - Массивы NumPy часто называют ndarrays, что означает "N-dimensional array" (N-мерный массив),
#  поскольку они могут иметь несколько измерений.
#  Например:
#  x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
#  print(x[1][2])
#  Это создаст двумерный массив, который имеет 3 столбца и 3 строки, и выведет значение во 2-й строке и 3-м столбце.
#  Массивы имеют свойства, доступ к которым можно получить с помощью точки
#       .ndim возвращает количество измерений массива
#       .size возвращает общее количество элементов массива
#       .shape возвращает кортеж целых чисел, указывающих количество элементов, хранящихся в каждом измерении массива.
#  Например:
#  x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
#  print(x.ndim)  # 2
#  print(x.size)  # 9
#  print(x.shape)  # (3, 3)
#  Итак, массив в нашем примере имеет 2 измерения, 9 элементов и представляет собой матрицу 3x3 (3 строки и 3 столбца).
# import numpy as np
#
# x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# print(x[1][2])
# vac_nums = np.array([0, 0, 1, 0, 1,
#                      0, 0, 0, 1, 1,
#                      1, 0, 0, 0, 0,
#                      0, 1, 0, 0, 1,
#                      1, 1, 0, 1, 0,
#                      ])
# print(vac_nums.ndim)
# print(vac_nums.size)
# print(vac_nums.shape)

# TODO: Массивы NumPy
#  Мы можем добавлять, удалять и сортировать массив с помощью функций np.append(), np.delete() и np.sort().
#  Например:
# import numpy as np
#
# x = np.array([2, 3, 1])
#
# x = np.append(x, 4)
# x = np.delete(x, 0)
# x = np.sort(x)
# print(x)

# TODO: np.arange() позволяет создать массив, содержащий диапазон равномерно расположенных интервалов
#  (аналогично диапазону Python):
#  Это создаст массив [2, 5, 8]
# x = np.arange(2, 10, 3)
# print(x)

# TODO: ЗАДАЧА: Квадратные метры
#  Вам дан массив, содержащий данные о площади домов на определенной улице.
#  На этой улице только что построили новый дом.
#  Измените свою программу, чтобы она принимала новое значение дома в качестве входных данных,
#  добавляла его к массиву и выводила массив, отсортированный в порядке возрастания.
#  Используйте оператор печати для вывода объекта массива.
# import numpy as np
#
# data = np.array([1000, 2500, 1400, 1800, 900, 4200, 2200, 1900, 3500])
# data = np.append(data, int(input()))
# data = np.sort(data)
# print(data)

# TODO: Reshape (Изменить форму)
#  Напомним, что фигура относится к количеству строк и столбцов в массиве. Например, рассмотрим следующий массив:
#      import numpy as np
#      x = np.arange(1, 7)
#      print(x)
# TODO: Это одномерный массив, содержащий 6 элементов.
#  NumPy позволяет нам изменять форму наших массивов с помощью функции reshape().
#  Например, мы можем изменить наш одномерный массив на массив с 3 строками и 2 столбцами:
#      import numpy as np
#      x = np.arange(1, 7)
#      z = x.reshape(3, 2)
#      print(z)
# TODO: Когда вы используете метод изменения формы, массив, который вы хотите создать,
#  должен иметь то же количество элементов, что и исходный массив.

# TODO: Reshape также может сделать обратное: взять 2-мерный массив и сделать из него 1-мерный массив:
#  В результате получается плоский массив, содержащий 6 элементов.
#  Того же результата можно добиться с помощью функции flatten().
# import numpy as np
#
# x = np.array([[1, 2], [3, 4], [5, 6]])
# z = x.reshape(6)
# print(z)
#
# x = np.arange(1, 8, 3)
# z = x.reshape(3, 1)
# print(z[1][0])

# TODO: ЗАДАЧА: Места в театре
#  Вам дан массив, представляющий заполняемость мест в кинотеатре.
#  Место, отмеченное цифрой 1, занято, а место, отмеченное цифрой 0, означает, что место свободно.
#  Однако массив плоский и одномерный. Преобразуйте его в двумерный массив, представляющий ряды сидений.
#  В каждом ряду театра по 5 мест, всего 30 мест.
#  Придайте массиву соответствующую форму и выведите строку с заданным индексом,
#  который берется из пользовательского ввода.
#  Индекс строки берется из пользовательского ввода в данном коде.
# import numpy as np
#
# data = np.array([1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0])
# row = int(input())
# data_new = data.reshape(6, 5)
# print(data_new[row])

# TODO: Indexing and Slicing - Индексирование и нарезка
#  Массивы NumPy можно индексировать и нарезать так же, как списки Python.
#  Отрицательные индексы считаются с конца массива, поэтому [-3:] приведет к последним 3 элементам.
#  Например:
# import numpy as np
#
# x = np.arange(1, 10)
# print(x)
# print(x[0:2])
# print(x[5:])
# print(x[:2])
# print(x[-3:])

# TODO: Conditions - Условия
#  Вы можете указать условие в качестве индекса для выбора элементов, которые удовлетворяют заданному условию.
#  Например, давайте выберем элементы меньше 4:
# import numpy as np
#
# x = np.arange(1, 10)
# print(x[x < 4])
# TODO: Условия можно комбинировать с помощью знаков & (и) и | (или) операторы.
#  Например, возьмем четные числа больше 5:
# import numpy as np
#
# x = np.arange(1, 10)
# print(x[(x > 5) & (x % 2 == 0)])
# y = (x > 5) & (x % 2 == 0)
# TODO: Условие также может быть присвоено переменной, которая будет массивом логических значений, показывающих,
#  соответствуют ли значения в массиве условию:
# import numpy as np
#
# x = np.arange(1, 10)
# y = (x > 5) & (x % 2 == 0)
# print(x[y])

# import numpy as np
#
# x = np.array([11, 42, 8, 5, 18])
# z = x[x > 15]
# print(z.size)

# TODO: ЗАДАЧА: Multiples of 3 & 5 (Кратность 3 и 5)
#  Вам дается задание найти все целые числа меньше 100, которые кратны как 3, так и 5.
#  Создайте массив чисел до 100, кратных как 3, так и 5, и выведите его.
#  Вы можете использовать оператор по модулю %, чтобы проверить, является ли число кратным другому числу.
# import numpy as np
# x = np.arange(1, 100)
# y = (x < 100) & (x % 3 == 0) & (x % 5 == 0)
# print(x[y])

# TODO: Operations - Операции
#  С массивами легко выполнять основные математические операции.
#  Например, чтобы найти сумму всех элементов, мы используем функцию sum():
# import numpy as np
#
# x = np.arange(1, 10)
# print(x.sum())
# TODO: Точно так же min() и max() можно использовать для получения наименьшего и наибольшего элементов.
#  Мы также можем выполнять операции между массивом и одним числом. Например, мы можем умножить все элементы на 2:
#  Так просто, как, что! Возьмите свой массив и выполните с ним любую операцию, которую хотите!
#  NumPy понимает, что данная операция должна выполняться с каждым элементом. Это называется трансляция.
# import numpy as np
#
# x = np.arange(1, 10)
# print(x)
# print(sum(x))
# y = x * 2
# print(y)
# print(sum(y))

# TODO: Statistics (Статистика)
#  Помните сводную статистику, которую мы изучили в предыдущем модуле?
#  К ним относятся:
#  - mean (среднее значение),
#  - median (медиана),
#  - variance (дисперсия),
#  - standard deviation (стандартное отклонение).
#  Массивы NumPy имеют встроенные функции для возврата этих значений.
#  Как видите, NumPy предоставляет множество полезных функций для выполнения обычных операций с массивами.
# import numpy as np
#
# x = np.array([14, 18, 19, 24, 26, 33, 42, 55, 67])
#
# print(np.mean(x))
# print(np.median(x))
# print(np.var(x))
# print(np.std(x))

# TODO: ЗАДАЧА: Ежедневные инфекции
#  Данный массив представляет ежедневное количество заражений за 30 дней.
#  Узнайте, на сколько дней превысило среднее число заражений.
#  Создайте условие и выведите размер результирующего массива.
# import numpy as np
#
# data = np.array(
#     [120, 98, 150, 65, 42, 100, 190, 220, 140, 110, 88, 89, 100, 120, 50, 180, 155, 42, 89, 77, 200, 190, 125, 98, 77,
#      40, 39, 59, 30, 67])
# mean = np.mean(data)
# print(data[data > 105].size)

# import numpy as np
#
# x = np.arange(3, 9)
# z = x.reshape(2, 3)
# print(z[1][1])

# import numpy as np
#
# x = np.arange(1, 5)
# x = x * 2
# print(x[:3].sum())

# TODO: ЗАДАЧА: Цены на дома
#  Вам дан массив, представляющий цены на жилье.
#  Вычислите и выведите процент домов, которые находятся в пределах одного стандартного отклонения от среднего значения.
#  Чтобы вычислить процент, разделите количество домов, удовлетворяющих условию,
#  на общее количество домов и умножьте результат на 100.
# import numpy as np
#
# data = np.array(
#     [150000, 125000, 320000, 540000, 200000, 120000, 160000, 230000, 280000, 290000, 300000, 500000, 420000, 100000,
#      150000, 280000])
# mean = np.mean(data)
# # print(mean)
# std = np.std(data)
# # print(std)
# lens = data[(data > mean - std) & (data < mean + std)]
# # print(lens)
# percent = (lens.size / data.size) * 100
# print(percent)

# TODO: What is Pandas? Что такое Панды?
#  Pandas — одна из самых популярных библиотек для обработки данных в Python.
#  Простой в использовании, он построен на основе NumPy и имеет много общих функций и свойств.
#  C Pandas вы можете читать и извлекать данные из файлов, преобразовывать и анализировать их,
#  рассчитывать статистику и корреляции и многое другое!
#  Чтобы начать использовать pandas, нам нужно сначала импортировать его:
#  import pandas as pd
#  pd — это обычное короткое имя, используемое при импорте библиотеки.
#  Pandas происходит от термина «панельные данные», эконометрического термина для наборов данных,
#  которые включают наблюдения за несколькими периодами времени для одних и тех же людей.

# TODO: Series & DataFrames (Серии и кадры данных)
#  Двумя основными компонентами pandas являются Series и DataFrame.
#  Серия — это, по сути, столбец, а DataFrame — это многомерная таблица, состоящая из набора серий.
#  Например, следующий DataFrame состоит из двух серий, возраста и роста. См рис. файл: DataFrame.png
#  Вы можете думать о Series как об одномерном массиве, а DataFrame — как о многомерном массиве.

# TODO: DataFrames (кадры данных)
#  Прежде чем работать с реальными данными, давайте сначала создадим DataFrame вручную, чтобы изучить его функции.
#  Самый простой способ создать DataFrame — использовать словарь:
#  data = {
#    'ages': [14, 18, 24, 42],
#    'heights': [165, 180, 176, 184]
#  }
#  Каждый ключ — это столбец, а значение — это массив, представляющий данные для этого столбца.
#  Теперь мы можем передать этот словарь в конструктор DataFrame:
#  Запустите код, чтобы увидеть полученный DataFrame.
# import pandas as pd
#
# data = {
#     'ages': [14, 18, 24, 42],
#     'heights': [165, 180, 176, 184]
# }
#
# df = pd.DataFrame(data)
# print(df)

# import pandas as pd
#
# x = {
#     'a': [1, 2],
#     'b': [3, 4],
#     'c': [5, 6]
# }
# df = pd.DataFrame(x)
# print(df)

# TODO: кадры данных
#  DataFrame автоматически создает числовой индекс для каждой строки.
#  Мы можем указать собственный индекс при создании DataFrame:
# import pandas as pd
#
# data = {
#     'ages': [14, 18, 24, 42],
#     'heights': [165, 180, 176, 184]
# }
#
# df = pd.DataFrame(data, index=['James', 'Bob', 'Amy', 'Dave'])
# print(df)
# TODO: Теперь мы можем получить доступ к строке, используя ее индекс и функцию loc[]:
#  Это выведет строку, соответствующую индексу «Боб».
#  Обратите внимание, что loc использует квадратные скобки для указания индекса.
# import pandas as pd
#
# data = {
#     'ages': [14, 18, 24, 42],
#     'heights': [165, 180, 176, 184]
# }
#
# df = pd.DataFrame(data, index=['James', 'Bob', 'Amy', 'Dave'])
# print(df.loc["Bob"])

# TODO: ЗАДАЧА: Поиск контактов
#  Вам дан словарь с именами и номерами людей.
#  Вам нужно создать DataFrame из словаря и добавить к нему индекс, который должен быть значениями имени.
#  Затем возьмите имя из пользовательского ввода и выведите строку в DataFrame, которая соответствует этой строке.
#  Использовать . loc , чтобы найти указанную строку.
# import pandas as pd
#
# data = {
#     'name': ['James', 'Billy', 'Bob', 'Amy', 'Tom'],
#     'number': ['1234', '5678', '2222', '1111', '0909']
# }
# df = pd.DataFrame(data, index=['James', 'Billy', 'Bob', 'Amy', 'Tom'])
# print(df.loc[input()])

# TODO: Indexing (Индексация)
#  Мы можем выбрать один столбец, указав его имя в квадратных скобках:
# import pandas as pd
#
# data = {
#     'ages': [14, 18, 24, 42],
#     'heights': [165, 180, 176, 184]
# }
#
# df = pd.DataFrame(data, index=['James', 'Bob', 'Amy', 'Dave'])
#
# print(df["ages"])
# TODO: Результатом является объект Series.
#  Если мы хотим выбрать несколько столбцов, мы можем указать список имен столбцов:
#  На этот раз результатом является DataFrame, так как он включает в себя несколько столбцов.
#  Это полезно, когда нам нужно выбрать только часть столбцов из набора данных.
# import pandas as pd
#
# data = {
#     'ages': [14, 18, 24, 42],
#     'heights': [165, 180, 176, 184]
# }
#
# df = pd.DataFrame(data, index=['James', 'Bob', 'Amy', 'Dave'])
#
# print(df[["ages", "heights"]])

# TODO: Slicing (Нарезка)
#  Pandas использует функцию iloc для выбора данных на основе их числового индекса.
#  Он работает так же, как списки индексации в Python.
#  iloc следует тем же правилам, что и нарезка со списками Python.
#  Например:
# import pandas as pd
#
# data = {
#     'ages': [14, 18, 24, 42],
#     'heights': [165, 180, 176, 184]
# }
#
# df = pd.DataFrame(data, index=['James', 'Bob', 'Amy', 'Dave'])
#
# # third row
# print(df.iloc[2])
#
# # first 3 rows
# print(df.iloc[:3])
#
# # rows 2 to 3
# print(df.iloc[1:3])

# TODO: Conditions (Условия)
#  Мы также можем выбирать данные на основе условия.
#  Например, выберем все строки, где возраст больше 18, а рост больше 180:
#  Точно так же или | Оператор может использоваться для объединения условий.
# import pandas as pd
#
# data = {
#     'ages': [14, 18, 24, 42],
#     'heights': [165, 180, 176, 184]
# }
#
# df = pd.DataFrame(data, index=['James', 'Bob', 'Amy', 'Dave'])
#
# print(df[(df['ages'] > 18) & (df['heights'] > 180)])

# TODO: ЗАДАЧА: Рейтинговая доска
#  Вам предоставляется DataFrame, который включает в себя имена и ранги людей.
#  Вам нужно взять ранг в качестве входных данных и вывести соответствующий столбец имени из DataFrame как ряд.
#  Обратите внимание, что ранг является целым числом,
#  поэтому вам необходимо преобразовать пользовательский ввод в целое число.
# import pandas as pd
#
# data = {
#     'name': ['James', 'Billy', 'Bob', 'Amy', 'Tom', 'Harry'],
#     'rank': [4, 1, 3, 5, 2, 6]
# }
# df = pd.DataFrame(data, index=data['name'])
# print(df['name'][df['rank'] == int(input())])

# TODO: Reading Data (Чтение данных)
#  Довольно часто данные поступают в формате файла.
#  Одним из самых популярных форматов является CSV (значения, разделенные запятыми).
#  Pandas поддерживает чтение данных из файла CSV непосредственно в DataFrame.
#  В наших примерах мы будем использовать файл CSV, содержащий данные о заражении COVID-19 в Калифорнии за 2020 год,
#  который называется «ca-covid.csv».
#  Функция read_csv() считывает данные CSV-файла в DataFrame:
#  df = pd.read_csv("ca-covid.csv")
#  Нам нужно указать путь к файлу для функции read_csv().
#  Pandas также поддерживает чтение из файлов JSON и баз данных SQL.
#  Когда у нас есть данные в DataFrame, мы можем начать их изучение.
#  Мы можем получить первые строки данных, используя функцию head() DataFrame:
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# print(df.head())
# TODO:
#  По умолчанию он возвращает первые 5 строк.
#  Вы можете дать ему указание возвращать в качестве аргумента необходимое количество строк (например:
#  df.head(10) вернет первые 10 строк).
#  Мы видим, что наш DataFrame содержит дату, штат, количество случаев и смертей на эту дату.
#  Точно так же вы можете получить последние строки, используя функцию tail().

# TODO: Функция info() используется для получения важной информации о вашем наборе данных,
#  такой как количество строк, столбцов, типы данных и т. д.:
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.info()
# TODO: Запустите код, чтобы увидеть результат!
#  Из результата мы видим, что наш набор данных содержит 342 строки и 4 столбца: дата, штат, случаи, смерти.
#  Мы также видим, что Pandas добавил автоматически сгенерированный индекс.
#  Мы можем установить наш собственный индексный столбец с помощью функции set_index():
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.set_index("date", inplace=True)
#
# print(df.head())
# TODO: Столбец даты — хороший выбор для нашего индекса, так как для каждой даты есть одна строка.
#  Аргумент inplace=True указывает, что изменение будет применено к нашему DataFrame
#  без необходимости назначать его новой переменной DataFrame.

# TODO: Dropping a Column (Удаление столбца)
#  Поскольку наши данные относятся только к штату Калифорния, мы можем удалить этот столбец из нашего DataFrame,
#  так как он содержит одно и то же значение для всех строк:
#   - drop() удаляет строки и столбцы.
#   - axis=1 указывает, что мы хотим удалить столбец.
#   - axis=0 удалит строку.
#   Теперь наш набор данных стал намного чище: у нас есть индекс дат и столбцы случаев смерти.
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.set_index('date', inplace=True)
# df.drop('state', axis=1, inplace=True)
#
# df.info()
# print(df.head())

# TODO: ЗАДАЧА: 31 декабря
#  Вы работаете с CSV-файлом «ca-covid», который содержит данные о заражении COVID-19 в Калифорнии за 2020 год.
#  В файле представлены данные о ежедневных случаях и смертях за весь год.
#  Найдите и выведите строку, соответствующую 31 декабря 2020 года.
#  Запрашиваемая дата — это последняя строка в наборе данных, поэтому для ее выбора можно использовать индексирование.
# import pandas as pd
#
# # df = pd.read_csv("/usercode/files/ca-covid.csv")
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.set_index('date', inplace=True)
# df.drop('state', axis=1, inplace=True)
# print(df.iloc[-1])

# TODO: Creating Columns (Создание столбцов)
#  Pandas позволяет нам создавать собственные столбцы.
#  Например, мы можем добавить столбец месяца на основе столбца даты:
#  Мы делаем это, преобразуя столбец даты в дату и время и извлекая из него название месяца,
#  присваивая значение нашему новому столбцу месяца.
#  Наша дата имеет формат ДД.ММ.ГГ, поэтому нам нужно указать атрибут формата.
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
#
# df['day'] = pd.to_datetime(df['date'], format="%d.%m.%y").dt.day_name()
# df['month'] = pd.to_datetime(df['date'], format="%d.%m.%y").dt.month_name()
#
# df.set_index('date', inplace=True)
#
# print(df.head())

# df['area'] = df['width'] * df['height']

# TODO: Summary Statistics (Сводные статистические данные)
#  Теперь, когда наш набор данных чист и настроен, мы готовы взглянуть на некоторые статистические данные!
#  Функция description() возвращает сводную статистику по всем числовым столбцам:
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['month'] = pd.to_datetime(df['date'], format="%d.%m.%y").dt.month_name()
# df.set_index('date', inplace=True)
#
# print(df.describe())
# TODO: Эта функция покажет основную статистику для числовых столбцов, таких как стандартное, среднее, минимальное,
#  максимальное значения и т. д. Запустите код, чтобы увидеть результат!
#  Из результата мы видим, что максимальное количество случаев, которые были зафиксированы за сутки, составляет 64987,
#  а среднесуточное количество новых случаев — 6748.
#  Мы также можем получить сводную статистику для одного столбца, например:
#  df['cases'].describe()
# import pandas as pd
#
# data = {
#     'height': [133, 120, 180, 100],
#     'age': [9, 7, 16, 4]
# }
# df = pd.DataFrame(data)
# print(df['age'].mean())

# TODO: ЗАДАЧА: Будние дни
#  Вы продолжаете работать с набором данных COVID для Калифорнии.
#  Теперь добавьте названия дней недели для каждой строки в виде нового столбца с именем «день недели».
#  Затем выведите данные набора данных
#  за последние 7 дней. Не устанавливайте индекс в DataFrame.
#  Данный код преобразует столбец даты в datetime, поэтому вам не нужно менять его формат.
#  Использовать. dt.strftime("%A")  в столбце даты, чтобы преобразовать его в название дня недели.
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# # df = pd.read_csv("/usercode/files/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['weekday'] = df['date'].dt.strftime("%A")
#
# print(df.tail(7))

# TODO: Grouping (Группировка)
#  Поскольку у нас есть столбец месяца, мы можем увидеть,
#  сколько значений имеет каждый месяц, используя функции value_counts():
#  Мы видим, что, например, в январе всего 7 записей, а в остальных месяцах есть данные за все дни.
#  value_counts() возвращает, сколько раз значение появляется в наборе данных, также называемое частотой значений.
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['month'] = pd.to_datetime(df['date'], format="%d.%m.%y").dt.month_name()
# df['weekday'] = pd.to_datetime(df['date'], format="%d.%m.%y").dt.day_name()
# df.set_index('date', inplace=True)
#
# print(df['month'].value_counts())
# print(df['weekday'].value_counts())

# TODO: Группировка
#  Теперь мы можем рассчитать данные!
#  Например, давайте определим общее количество заражений в каждом месяце.
#  Для этого нам нужно сгруппировать наши данные по столбцу месяца,
#  а затем вычислить сумму столбца случаев за каждый месяц:
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['month'] = pd.to_datetime(df['date'], format="%d.%m.%y").dt.month_name()
# df.set_index('date', inplace=True)
#
# print(df.groupby('month')['cases'].sum())
# TODO: Функция groupby() используется для группировки нашего набора данных по заданному столбцу.
#  Мы также можем рассчитать общее количество случаев за весь год:
#  Мы видим, что в 2020 году в Калифорнии было зарегистрировано 2 307 769 случаев заражения.
#  Точно так же мы можем использовать min(), max(), среднее() и т. д.,
#  чтобы найти соответствующие значения для каждой группы.
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['month'] = pd.to_datetime(df['date'], format="%d.%m.%y").dt.month_name()
# df.set_index('date', inplace=True)
#
# print(df['cases'].sum())
# print(df['cases'].min())
# print(df['cases'].max())
# print(df['cases'].mean())

# # Заполните пробелы, чтобы получить максимальный возраст для каждого имени.
# df.groupby('name')['age'].max()

# TODO: ЗАДАЧА: Худший день
#  Учитывая данные о COVID, найдите день с максимальным количеством случаев в данном месяце.
#  Возьмите в качестве входных данных название месяца и выведите строку,
#  соответствующую дню с максимальным количеством случаев в этом месяце.
#  Вы можете сначала отфильтровать DataFrame для данного месяца,
#  а затем выбрать строку с максимальным количеством случаев. Важно: на выходе должен быть DataFrame,
#  включающий все столбцы. Например, для февраля ожидаемый результат будет следующим:
#  число случаев смерти месяц
#  дата
#  2020-02-26 15 0 февраль
#  Данный код добавляет столбец месяца в набор данных и добавляет индекс. Не изменяйте эту часть кода.
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# # df = pd.read_csv("/usercode/files/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month_name()
# # df['day'] = df['date'].dt.day_name()
# df.set_index('date', inplace=True)
# maxim = df[df["month"] == input()]['cases'].max()
# print(df[df['cases'] == maxim])

# import pandas as pd
#
# data = {
#     'a': [1, 2, 3],
#     'b': [5, 8, 4]
# }
# df = pd.DataFrame(data)
# df['c'] = df['a'] + df['b']
# print(df.iloc[2]['c'])

# TODO: ЗАДАЧА: Анализ данных COVID
#  Вы работаете с набором данных COVID для Калифорнии,
#  который включает количество случаев и смертей на каждый день 2020 года.
#  Найдите день, когда соотношение смертей/случаев было самым высоким.
#  Для этого вам нужно сначала рассчитать соотношение смертей/случаев и добавить его в виде столбца в DataFrame
#  с именем 'ratio', затем найти строку, которая соответствует наибольшему значению.
#  Важно: на выходе должен быть DataFrame, содержащий все столбцы набора данных для соответствующей строки.
# import pandas as pd
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# # df = pd.read_csv("/usercode/files/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df.set_index('date', inplace=True)
# df['ratio'] = df['deaths'] / df['cases']
# print(df.loc[df["ratio"] == df["ratio"].max()])

# TODO: Matplotlib (Матплотлиб)
#  Matplotlib — это библиотека, используемая для создания графиков, диаграмм и рисунков.
#  Он также предоставляет функции для настройки ваших фигур путем изменения цветов, меток и т.д.
#  Чтобы начать использовать matplotlib, нам сначала нужно его импортировать:
#       import matplotlib.pyplot as plt
#  pyplot — это модуль, который мы будем использовать для создания наших графиков.
#  plt — это обычное имя, используемое для импорта этого модуля.

# TODO: Matplotlib очень хорошо работает с Pandas!
#  Чтобы продемонстрировать мощь matplotlib, давайте создадим диаграмму из фиктивных данных.
#  Мы создадим серию панд с некоторыми числами и используем ее для создания нашей диаграммы:
# import matplotlib.pyplot as plt
# import pandas as pd
#
# s = pd.Series([18, 42, 9, 32, 81, 64, 3])
# s.plot(kind='bar')
# plt.savefig('plot.png')
# TODO: Функция plot() используется для создания графика из данных в серии Pandas или DataFrame.
#  Вот результат: данные из ряда используют ось Y, а индекс построен по оси X.
#  Поскольку мы не предоставили пользовательский индекс для наших данных, используется числовой индекс по умолчанию.
#  plt.savefig('plot.png') используется для сохранения и отображения диаграммы на нашей площадке для кода.
#  В большинстве сред этот шаг не нужен, так как вызов функции plot() автоматически отображает диаграмму.

# TODO: Line Plot (Линейный график)
#  Matplotlib поддерживает создание различных типов диаграмм.
#  Начнем с самого простого — линейного графика.
#  Мы будем использовать данные COVID-19 из предыдущего модуля для создания наших диаграмм.
#  Давайте покажем количество случаев в декабре месяце. Чтобы создать линейный график,
#  нам просто нужно вызвать функцию plot() в нашем DataFrame, который содержит соответствующие данные:
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# df[df['month'] == 12]['cases'].plot()
# plt.savefig('plot.png')

# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# df[df['month'] == 6]['deaths'].plot()
# plt.savefig('plot.png')

# TODO: Мы также можем включить несколько линий в нашу диаграмму.
#  Например, давайте также включим столбец смертей в наш DataFrame:
#  Как видно из результата, matplotlib автоматически добавил легенду, чтобы показать цвета линий для столбцов.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# (df[df['month'] == 12])[['cases', 'deaths']].plot()
# plt.savefig('plot.png')

# TODO: Bar Plot (Бар График)
#  Функция plot() может принимать аргумент типа, указывающий тип графика, который мы хотим создать.
#  Для гистограмм укажите kind="bar".
#  Давайте сделаем гистограмму для ежемесячных случаев заражения:
#  Сначала мы группируем данные по столбцу месяца, а затем вычисляем сумму случаев в этом месяце.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# (df.groupby('month')['cases'].sum()).plot(kind="bar")
# plt.savefig('plot.png')

# TODO: Рассчитать количество смертей за месяц, и создать столбчатую диаграмму.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# df = df.groupby('month')
# df['deaths'].sum().plot(kind="bar")
# plt.savefig('plot.png')

# TODO: Мы также можем построить несколько столбцов.
#  Свойство stacked можно использовать, чтобы указать, должны ли столбцы располагаться друг над другом.
#  Например:
#  Мы суммировали случаи и смерти за каждый месяц.
#  kind="barh" можно использовать для создания горизонтальной гистограммы.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# # df['day'] = df['date'].dt.day
# df.set_index('date', inplace=True)
#
# # df = df.groupby('day')[['cases', 'deaths']].sum()
# df = df.groupby('month')[['cases', 'deaths']].sum()
# df.plot(kind="bar", stacked=True)
# plt.savefig('plot.png')

# TODO: Файл people.csv содержит возраст и рост людей.
#  Заполните пробелы, чтобы прочитать данные в DataFrame и создать гистограмму,
#  показывающую средний рост для каждого возраста.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("people.csv")
# df.set_index('age', inplace=True)
# df = df.groupby('age')['height'].mean()
# df.plot(kind="bar")

# TODO: Box Plot (Коробчатый График)
#  Блочная диаграмма используется для визуализации распределения значений в столбце,
#  в основном визуализируя результат функции describe().
#  Например, давайте создадим блочную диаграмму для случаев в июне:
#  Зеленая линия показывает среднее значение.
#  В рамке показаны верхний и нижний квартили (25% данных больше или меньше этих значений).
#  Кружками показаны выбросы, а черными линиями показаны минимальные/максимальные значения без учета выбросов.
#  Ознакомьтесь со следующей статьей для получения дополнительной информации о ящичковых диаграммах:
#  https://en.wikipedia.org/wiki/Box_plot
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# df[df["month"] == 6]["cases"].plot(kind="box")
# plt.savefig('plot.png')

# TODO: Histogram (Гистограмма)
#  Подобно ящичковым диаграммам, гистограммы показывают распределение данных.
#  Визуально гистограммы похожи на гистограммы, однако гистограммы отображают частоты для группы данных,
#  а не для отдельной точки данных; поэтому между стержнями нет пробелов.
#  Как правило, гистограмма группирует данные в порции (или ячейки).
#  Например:
#  Гистограмма сгруппировала данные в 9 бинов и показывает их частоту.
#  Вы можете видеть, что, например, только отдельные точки данных превышают 6000.
#  Вы можете вручную указать количество бинов для использования с помощью атрибута bins: plot(kind="hist", bins = 10)
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# df[df["month"] == 6]["cases"].plot(kind="hist")
# plt.savefig('plot.png')

# TODO: Area Plot (График Площади)
#  kind='area' создает график площади:
#  Графики площади по умолчанию сложены, поэтому мы явно указали stacked=False .
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# df[df["month"] == 6][["cases", "deaths"]].plot(kind="area", stacked=False)
# plt.savefig('plot.png')

# TODO: Scatter Plot (Точечная диаграмма)
#  Точечная диаграмма используется для отображения взаимосвязи между двумя переменными.
#  Например, мы можем визуализировать, как связаны случаи/смерти:
#  Нам нужно указать столбцы x и y, которые будут использоваться для графика.
#  График содержит 30 точек, так как мы использовали данные за каждый день июня.
#  Точки данных выглядят «разбросанными» по графику, что и дало название этому типу визуализации данных.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df.set_index('date', inplace=True)
#
# df[df["month"] == 6][["cases", "deaths"]].plot(kind="scatter", x='cases', y='deaths')
# plt.savefig('plot.png')

# TODO: Pie Chart (Круговая диаграмма)
#  Мы можем создать круговую диаграмму, используя kind="pie".
#  Давайте создадим один для дел по месяцам:
#  Круговые диаграммы обычно используются для отображения процентных или пропорциональных данных.
#  Круговые диаграммы обычно используются, когда у вас есть до 6 категорий.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = (df['date'].dt.month_name()).str[:3]
# df.set_index('date', inplace=True)
#
# df.groupby('month')['cases'].sum().plot(kind="pie")
# plt.savefig('plot.png')

# TODO: Plot Formatting (Форматирование графика)
#  Matplotlib предоставляет ряд аргументов для настройки вашего графика.
#  Аргумент легенды указывает, показывать ли легенду.
#  Вы также можете изменить метки оси, задав аргументы xlabel и ylabel:
#  По умолчанию pandas выбирает имя индекса как xlabel, оставляя его пустым для ylabel .
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df['day'] = df['date'].dt.day
# df.set_index('day', inplace=True)
#
# df = df[df['month'] == 6]
#
# df[['cases', 'deaths']].plot(kind="line", legend=True)
# plt.xlabel('Days in June')
# plt.ylabel('Number')
# plt.savefig('plot.png')

# TODO: Функцию suptitle() можно использовать для установки заголовка графика:
#  Мы также можем изменить цвета, используемые на графике, установив атрибут цвета.
#  Он принимает список шестнадцатеричных цветов.
#  Например, давайте установим:
#  - для 'cases' синий цвет,
#  - для 'deaths' красный цвет:
#  Эти атрибуты работают практически для всех типов диаграмм.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df['day'] = df['date'].dt.day
# df.set_index('day', inplace=True)
#
# df = df[df['month'] == 6]
#
# df[['cases', 'deaths']].plot(kind="area", legend=True)
# plt.xlabel('Days in June')
# plt.ylabel('Number')
# plt.suptitle("COVID-19 in June")
# plt.savefig('plot.png')

# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv("https://www.sololearn.com/uploads/ca-covid.csv")
#
# df.drop('state', axis=1, inplace=True)
# df['date'] = pd.to_datetime(df['date'], format="%d.%m.%y")
# df['month'] = df['date'].dt.month
# df['day'] = df['date'].dt.day
# df.set_index('day', inplace=True)
#
# df = df[df['month'] == 6]
#
# df[['cases', 'deaths']].plot(kind="area", legend=True, stacked=False, color=['#1970E7', '#E73E19'])
# plt.xlabel('Days in June')
# plt.ylabel('Number')
# plt.suptitle("COVID-19 in June")
# plt.savefig('plot.png')

# import pandas as pd
# import matplotlib.pyplot as plt
#
# data = {
#     'sport': ["Soccer", "Tennis", "Soccer", "Hockey"],
#     'players': [5, 4, 8, 20]
# }
# df = pd.DataFrame(data)
# df.groupby('sport')['players'].sum().plot(kind="pie")
# plt.savefig('plot.png')

