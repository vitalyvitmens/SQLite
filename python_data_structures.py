"""
Python Data Structures:
Структуры данных Python
Почти ни одна программа не может нормально работать без данных.
Python имеет ряд встроенных структур данных, которые позволяют вам хранить, организовывать и управлять вашими данными.
В этом курсе мы узнаем о различных структурах данных Python,
таких как строки, списки, словари, кортежи, наборы и многое другое.
"""
# TODO: Python Data Structures: Структуры данных Python
#  Почти каждая программа использует данные.
#  Организация, управление и хранение данных важны, поскольку они обеспечивают более легкий доступ и
#  эффективные модификации. Структуры данных позволяют хранить данные и управлять ими.
#  В Python есть ряд встроенных структур данных:
#  - Strings (Строки)
#  - Lists (Списки)
#  - Dictionaries (Словари)
#  - Tuples (Кортежи)
#  - Sets (Наборы)
#  В ходе этого курса мы узнаем об этих структурах данных,
#  используем их для хранения данных и увидим их реальное применение.

# TODO: Python Data Structures
#  В дополнение к встроенным структурам данных Python позволяет создавать собственные структуры данных,
#  что дает вам полный контроль над их функциональностью.
#  Наиболее известными структурами данных являются:
#  - Stacks (Стеки)
#  - Queues (Очереди)
#  - Trees (Деревья)
#  - Linked Lists (Связанные списки)
#  Эти структуры данных широко используются в популярных алгоритмах. Мы узнаем о них в следующих модулях.

# TODO: Strings - Строки используются для хранения текста и являются одной из самых простых и
#  наиболее часто используемых структур данных.
#  Любой текст между двумя одинарными или двойными кавычками является строкой. Например:
# x = "Hello world"
# print(x)
# TODO: Переменная x теперь представляет собой строку.

# TODO: Special Characters Специальные символы
#  В строках можно использовать ряд специальных символов.
#  \n представляет собой новую строку:
# print('One\nTwo\nThree')

# TODO: Точно так же \t представляет собой вкладку.
#  Если вы хотите включить одинарную кавычку в строку с одинарными кавычками
#  (или двойную кавычку в строку с двойными кавычками), вам нужно экранировать ее с помощью обратной косой черты:
# print('Brian\'s mother: He\'s not an angel. He\'s a very naughty boy!')
# TODO: Обратная косая черта также называется escape-символом.

# TODO: Accessing Strings - Доступ к строкам
#  Строки можно рассматривать как последовательность символов.
#  Каждый символ в строке имеет свою уникальную позицию (или индекс).
#  Вы можете получить доступ к символу строки, используя его индекс:
# x = "Hello"
# print(x[2])
# TODO: Приведенный выше код обращается к третьему символу строки.
#  Индекс начинается с 0, что означает, что первый символ имеет индекс 0.

# str = "Some text"
# print(str[0])

# TODO: Вы также можете использовать отрицательные индексы, которые обращаются к символам строки, считая с конца.
#  Приведенный ниже код обращается к последнему символу строки.
# x = "Hello"
# print(x[-1])

# TODO: Вы можете перебирать символы в строке, используя цикл for:
#  Во время каждой итерации переменная c будет представлять текущий символ строки.
# x = "Hello"
# for c in x:
#     print(c)

# text = "some text goes here"
# for x in text:
#     print(x)

# text = input()
# count = 0
# for x in text:
#     if x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' \
#             or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U':
#         count += 1
# print(count)

# text = input()
# count = 0
# for x in text:
#     if x in 'aeiouAEIOU':
#         count += 1
# print(count)

# TODO: String Operations (Строковые операции)
#  Оператор in можно использовать для проверки того, является ли строка частью другой строки.
#  Оператор not in можно использовать для проверки того, не является ли строка частью другой строки.
#  Например:
# x = "I love Python"
# if "love" in x:
#     print("Yes 'love' in x")
# if "love" not in x:
#     print("Yes 'love' not in x")

# res = 0
# s = 'xyz'
# if 'x' in s:
#     res += 1
# elif 'a' in s:
#     res += 1
# print(res)

# TODO: Строки могут быть добавлены вместе (также называемое конкатенацией):
# print("Spam" + 'eggs')
# TODO: Строки также можно умножать на целые числа.
#  Это создает повторяющуюся версию исходной строки.
#  Строки нельзя умножать на другие строки.
#  Строки также нельзя умножать на числа с плавающей запятой,
#  даже если числа с плавающей запятой являются целыми числами.
# print("spam" * 3)
# print(4 * '2')

# a = "abra"
# b = "cad"
# x = a+b+a
# print(x)

# text = input()
# i = 0
# while i < len(text):
#     print(text[i] * (i + 1))
#     i += 1

# TODO: Строка имеет много полезных функций:
#  count(str) возвращает, сколько раз подстрока str встречается в заданной строке.
#  upper() переводит строку в верхний регистр.
#  lower() преобразует строку в нижний регистр.
#  replace(old, new) заменяет все вхождения слова old новым .
#  len(str) возвращает длину строки (количество символов).
#  Взгляните на этот код для примеров:
# x = "This is some text"
#
# print(x.count("s"))
# print(x.upper())
# print(x.lower())
# print(x.replace("some text", "awesome"))
# print(len(x))
# TODO: Обратите внимание, что эти функции возвращают новую строку с соответствующей обработкой.

# x = 'abc'
# x = x * len(x)
# print(x.count('a'))

# a = input()
# b = input()
# text = "Amy has 128 dollars, while David has 54 dollars. Amy is going to the zoo. David watches soccer."
# new_text = text.replace(a, b)
# print(text.count(a))
# print(new_text)

# TODO: ЗАДАЧА: Частота букв
#  Вы делаете программу для анализа текста.
#  Возьмите текст в качестве первого ввода и букву в качестве второго ввода и
#  выведите частоту этой буквы в тексте в виде целого процента.
#  Пример ввода: hello
#  Пример ввода: l
#  Пример вывода: 40
#  Объяснение: Буква l встречается 2 раза в тексте hello, который состоит из 5 букв.
#  Таким образом, частота будет (2/5)*100 = 40 .
#  Результат деления — число с плавающей запятой.
#  Используйте функцию int() для преобразования результата в целое число.
# a = input()
# b = input()
# c = a.count(b)
# d = (c / len(a)) * 100
# print(int(d))

# TODO: Lists (Списки) используются для хранения нескольких элементов,
#  каждый из которых соответствует индексу. Они создаются с помощью квадратных скобок.
#  Например:
# names = ["James", "Tom", "Amy"]
# TODO: Список имен содержит три строки.
#  К каждому элементу списка можно получить доступ, используя его индекс:
#  Это выведет 2-й элемент списка.
#  Индекс первого элемента списка равен 0.
# names = ["James", "Tom", "Amy"]
# print(names[1])

# TODO: Списки можно использовать для представления набора данных, например,
#  возраста людей, ежемесячных темпов роста запасов и т. д.
#  Списки также можно вкладывать друг в друга для представления двумерных сеток, таких как матрицы:
#  Приведенный ниже код выводит 3-й элемент 2-й строки.
#  Матричную структуру можно использовать в тех случаях, когда вам нужно хранить данные в формате строки-столбца.
# m = [
#     [1, 2, 3],
#     [4, 5, 6]
# ]
# print(m[1][2])

# TODO: Список операций Список операций
#  Подобно строкам, мы можем использовать операторы in и not in , чтобы проверить, является ли элемент частью списка:
#  Функцию len() можно использовать для возврата количества элементов в списке.
# words = ["spam", "egg", "spam", "sausage"]
# print("spam" in words)
# print("egg" in words)
# print("tomato" in words)
# print(len(words))

# contacts = ["spam", "egg", "spam", "sausage"]
# name = input()
# if name in contacts:
#     print("Found")
# else:
#     print("Not Found")

# TODO: Loops (Цикл)
#  Подобно строкам, мы можем перебирать элементы списка, используя цикл:
#  n будет представлять текущий элемент списка во время каждой итерации.
# x = [2, 4, 6, 8]
#
# for n in x:
#     print(n)

# x = [2, 5, 7, 3, 1]
#
# res = 1
# for n in x:
#     res *= n
# print(res)

# TODO: ЗАДАЧА:
#  Вам дана двумерная матрица, которая представляет количество людей в комнате, сгруппированных по цвету глаз и полу.
#  Первый ряд представляет мужской пол, а второй ряд — женский.
#  Столбцы — это цвета глаз в следующем порядке: коричневый , синий , зеленый , черный.
#  Данные показывают, что, например, в комнате находится 20 зеленоглазых самок (2-й ряд, 3-й столбец).
#  Наша программа должна принимать цвет глаз в качестве входных данных и
#  выводить процент людей с таким цветом глаз в комнате.
#  data = [
#   [23, 11, 5, 14],
#   [8, 32, 20, 5]
#   ]
#  Пример ввода: синий
#  Пример вывода: 36
#  Объяснение: Есть 11+32=43 человека с голубыми глазами, что составляет 36% от общего числа.
#  Обратите внимание, что вывод должен быть целым числом: используйте функцию int() для преобразования результата.
# data = [
#   [23, 11, 5, 14],
#   [8, 32, 20, 5]
# ]
#
# color = input()
# res = sum(data[0]) + sum(data[1])
# if color == 'brown':
#     brown = data[0][0] + data[1][0]
#     print(int(brown / res * 100))
# elif color == 'blue':
#     blue = data[0][1] + data[1][1]
#     print(int(blue / res * 100))
# elif color == 'green':
#     green = data[0][2] + data[1][2]
#     print(int(green / res * 100))
# elif color == 'black':
#     black = data[0][3] + data[1][3]
#     print(int(black / res * 100))
# else:
#     print('No one has that eye color')

# TODO: List Functions (Функции списка)
#  Списки поддерживают следующие функции:
#  - append(item) добавляет элемент в конец списка.
#  - insert(index, item) добавляет элемент по заданному индексу в список.
#  - remove(item) удаляет элемент из списка.
#  - pop(index) удаляет элемент по заданному индексу.
#  - count(item) возвращает счетчик того, сколько раз элемент встречается в списке.
#  Элементы, которые находятся после вставленного элемента, смещаются вправо.
# x = [2, 4, 6]
# x.append(8)
# x.remove(4)
# x.insert(0, 8)
# print(x)
# print(x.count(8))

# x = [3, 1, 2, 5, 3, 1]
# x.append(8)
# x.insert(2, 6)
# x.remove(2)
# print(len(x))

# TODO:
#  - reverse() переворачивает элементы в списке.
#  - sort() сортирует список. По умолчанию список отсортирован по возрастанию.
#  Вы можете указать reverse=True в качестве параметра для сортировки по убыванию.
#  - max(list) возвращает максимальное значение.
#  - min(list) возвращает минимальное значение.
#  Некоторые примеры:
# x = [2, 4, 6, 8]
# x.reverse()
# print(x)
#
# x.sort()
# print(x)
#
# print(min(x))
# print(max(x))
# TODO: Обратите внимание, что функции reverse() и sort() изменяют список, в котором они вызываются.
# x = [8, 5, 42, 11, 20, 4]
# x.sort()
# print(max(x) - min(x) + x[2])

# TODO: ЗАДАЧА:
#  Вы анализируете цены на жилье. Данный код объявляет список цен на дома в районе.
#  Вам нужно подсчитать и вывести количество домов, цена которых выше средней.
#  Чтобы рассчитать среднюю цену домов, нужно разделить сумму всех цен на количество домов.
#  Используйте sum(list) для вычисления суммы всех элементов в списке и len(list) для получения количества элементов.
# prices = [125000, 78000, 110000, 65000, 300000, 250000, 210000, 150000, 165000, 140000, 125000, 85000, 90000, 128000,
#           230000, 225000, 100000, 300000]
# middle_price = sum(prices) / len(prices)
# res = 0
# for i in prices:
#     if i > middle_price:
#         res += 1
# print(res)

# TODO: List Comprehensions (Список понятий)
#  Генерация списков — это полезный способ быстрого создания списков, содержимое которых подчиняется правилу.
#  Понимание списков вдохновлено нотацией построителя множеств в математике.
#  Например, мы можем сделать следующее:
# cubes = [i ** 3 for i in range(5)]
# print(cubes)

# nums = [i * 2 for i in range(10)]
# print(nums)

# TODO: Понимание списка также может содержать оператор if для принудительного применения условия к значениям в списке.
#  Пример:
# evens = [i ** 2 for i in range(10) if i ** 2 % 2 == 0]
# print(evens)

# a = [i for i in range(20) if i % 3 == 0]
# print(a)

# TODO: ЗАДАЧА:
#  Каждый месяц количество насекомых в лаборатории удваивается.
#  Возьмите начальное количество насекомых в качестве входных данных и выведите список,
#  показывающий количество насекомых за каждый из следующих 12 месяцев, начиная с 0, что является начальным значением.
#  Итак, результирующий список должен содержать 12 пунктов,
#  каждый из которых показывает количество насекомых на начало этого месяца.
#  Пример ввода: 10
#  Пример вывода: [10, 20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 20480]
#  Создайте List Comprehensions, чтобы создать требуемый список.
#  Формула для подсчета количества насекомых через N месяцев будет выглядеть так: count*2ᴺ ,
#  где count — исходное количество насекомых.
# n = int(input())
# count = [n * 2 ** i for i in range(12)]
# print(count)

# nums = [10, 9, 8, 7, 6, 5]
# nums[0] = nums[1] - 5
# if 4 in nums:
#     print(nums[3])
# else:
#     print(nums[4])

# letters = ["a", "b", "c"]
# letters.append("d")
# print(len(letters))

# nums = (55, 44, 33, 22)
# print(max(min(nums[:2]), abs(-42)))

# TODO: ЗАДАЧА: Средняя длина слова
#  Учитывая предложение в качестве входных данных, вычислите и выведите среднюю длину слова этого предложения.
#  Чтобы вычислить среднюю длину слова, нужно разделить сумму всех длин слов на количество слов в предложении.
#  Пример ввода:
#  this is some text
#  Пример вывода:
#  3.5
#  Объяснение: В данном вводе 4 слова, всего 14 букв, поэтому средняя длина будет: 14/4 = 3,5
#  Строки имеют метод split(), который возвращает строку, разделенную на список, с заданным разделителем.
#  По умолчанию разделителем является пробел, поэтому вызов split() вернет список,
#  содержащий слова строки в качестве элементов.
# text = input()
# words = text.split()
# word_num = len(words)
# len_text = len(text) - (word_num - 1)
# avg = len_text / word_num
# print(avg)

# TODO: Dictionaries (Словари)
#  Мы видели, как списки позволяют нам хранить элементы с соответствующими им индексами.
#  Индексы в списке устанавливаются автоматически. Но что, если нам нужно установить собственный индекс?
#  Словари являются еще одним типом коллекций и позволяют нам сопоставлять произвольные ключи со значениями.
#  Словари можно индексировать так же, как и списки, используя квадратные скобки, содержащие ключи.
#  Каждый элемент словаря представлен парой ключ:значение.
#  Пример:
# ages = {"Dave": 24, "Mary": 42, "John": 58}
# print(ages["Dave"])
# print(ages["Mary"])

# TODO: Вы можете использовать строки, целые числа, логические значения и
#  любые другие неизменяемые типы в качестве ключей словаря.
#  Это означает, что вы не можете использовать списки или словари в качестве ключей:
#  Приведенный ниже код выдаст ошибку, так как он попытается использовать список в качестве ключа.
# bad_dict = {
#     [1, 2, 3]: "one two three",
# }

# TODO:
#  Чтобы определить, находится ли ключ в словаре, вы можете использовать in и not in так же, как и для списка.
#  Пример:
# nums = {
#     1: "one",
#     2: "two",
#     3: "three",
# }
# print(1 in nums)
# print("three" in nums)
# print(4 not in nums)

# TODO: Полезной функцией словаря является get().
#  Он делает то же самое, что и индексация, но если ключ не найден в словаре,
#  вместо этого возвращается другое указанное значение.
#  Чтобы определить количество элементов в словаре, используйте функцию len() .
#  Пример:
# pairs = {1: "apple",
#          "orange": [2, 3, 4],
#          True: False,
#          12: "True",
#          }
#
# print(pairs.get("orange"))
# print(pairs.get(7, 42))
# print(pairs.get(12345, "not found"))

# fib = {1: 1, 2: 1, 3: 2, 4: 3}
# print(fib.get(4, 0) + fib.get(7, 5))

# TODO: ЗАДАЧА:
#  Вы делаете телефонную книгу. Контакты хранятся в словаре,
#  где ключ — это имя, а значение — список, представляющий номер и адрес электронной почты контакта.
#  Вам нужно реализовать поиск: взять имя контакта на вход и вывести почту.
#  Если контакт не найден, выведите «Not found».
#  Обратите внимание, что электронная почта является вторым элементом списка.
# contacts = {
#     "David": ["123-321-88", "david@test.com"],
#     "James": ["241-879-093", "james@test.com"],
#     "Bob": ["987-004-322", "bob@test.com"],
#     "Amy": ["340-999-213", "a@test.com"]
# }
# name = input()
# if name in contacts:
#     print(contacts[name][1])
# else:
#     print("Not found")
