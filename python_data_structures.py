"""
Python Data Structures:
Структуры данных Python
Почти ни одна программа не может нормально работать без данных.
Python имеет ряд встроенных структур данных, которые позволяют вам хранить, организовывать и управлять вашими данными.
В этом курсе мы узнаем о различных структурах данных Python,
таких как строки, списки, словари, кортежи, наборы и многое другое.
"""


# TODO: Python Data Structures: Структуры данных Python
#  Почти каждая программа использует данные.
#  Организация, управление и хранение данных важны, поскольку они обеспечивают более легкий доступ и
#  эффективные модификации. Структуры данных позволяют хранить данные и управлять ими.
#  В Python есть ряд встроенных структур данных:
#  - Strings (Строки)
#  - Lists (Списки)
#  - Dictionaries (Словари)
#  - Tuples (Кортежи)
#  - Sets (Наборы)
#  В ходе этого курса мы узнаем об этих структурах данных,
#  используем их для хранения данных и увидим их реальное применение.

# TODO: Python Data Structures
#  В дополнение к встроенным структурам данных Python позволяет создавать собственные структуры данных,
#  что дает вам полный контроль над их функциональностью.
#  Наиболее известными структурами данных являются:
#  - Stacks (Стеки)
#  - Queues (Очереди)
#  - Trees (Деревья)
#  - Linked Lists (Связанные списки)
#  Эти структуры данных широко используются в популярных алгоритмах. Мы узнаем о них в следующих модулях.

# TODO: Strings - Строки используются для хранения текста и являются одной из самых простых и
#  наиболее часто используемых структур данных.
#  Любой текст между двумя одинарными или двойными кавычками является строкой. Например:
# x = "Hello world"
# print(x)
# TODO: Переменная x теперь представляет собой строку.

# TODO: Special Characters Специальные символы
#  В строках можно использовать ряд специальных символов.
#  \n представляет собой новую строку:
# print('One\nTwo\nThree')

# TODO: Точно так же \t представляет собой вкладку.
#  Если вы хотите включить одинарную кавычку в строку с одинарными кавычками
#  (или двойную кавычку в строку с двойными кавычками), вам нужно экранировать ее с помощью обратной косой черты:
# print('Brian\'s mother: He\'s not an angel. He\'s a very naughty boy!')
# TODO: Обратная косая черта также называется escape-символом.

# TODO: Accessing Strings - Доступ к строкам
#  Строки можно рассматривать как последовательность символов.
#  Каждый символ в строке имеет свою уникальную позицию (или индекс).
#  Вы можете получить доступ к символу строки, используя его индекс:
# x = "Hello"
# print(x[2])
# TODO: Приведенный выше код обращается к третьему символу строки.
#  Индекс начинается с 0, что означает, что первый символ имеет индекс 0.

# str = "Some text"
# print(str[0])

# TODO: Вы также можете использовать отрицательные индексы, которые обращаются к символам строки, считая с конца.
#  Приведенный ниже код обращается к последнему символу строки.
# x = "Hello"
# print(x[-1])

# TODO: Вы можете перебирать символы в строке, используя цикл for:
#  Во время каждой итерации переменная c будет представлять текущий символ строки.
# x = "Hello"
# for c in x:
#     print(c)

# text = "some text goes here"
# for x in text:
#     print(x)

# text = input()
# count = 0
# for x in text:
#     if x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' \
#             or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U':
#         count += 1
# print(count)

# text = input()
# count = 0
# for x in text:
#     if x in 'aeiouAEIOU':
#         count += 1
# print(count)

# TODO: String Operations (Строковые операции)
#  Оператор in можно использовать для проверки того, является ли строка частью другой строки.
#  Оператор not in можно использовать для проверки того, не является ли строка частью другой строки.
#  Например:
# x = "I love Python"
# if "love" in x:
#     print("Yes 'love' in x")
# if "love" not in x:
#     print("Yes 'love' not in x")

# res = 0
# s = 'xyz'
# if 'x' in s:
#     res += 1
# elif 'a' in s:
#     res += 1
# print(res)

# TODO: Строки могут быть добавлены вместе (также называемое конкатенацией):
# print("Spam" + 'eggs')
# TODO: Строки также можно умножать на целые числа.
#  Это создает повторяющуюся версию исходной строки.
#  Строки нельзя умножать на другие строки.
#  Строки также нельзя умножать на числа с плавающей запятой,
#  даже если числа с плавающей запятой являются целыми числами.
# print("spam" * 3)
# print(4 * '2')

# a = "abra"
# b = "cad"
# x = a+b+a
# print(x)

# text = input()
# i = 0
# while i < len(text):
#     print(text[i] * (i + 1))
#     i += 1

# TODO: Строка имеет много полезных функций:
#  count(str) возвращает, сколько раз подстрока str встречается в заданной строке.
#  upper() переводит строку в верхний регистр.
#  lower() преобразует строку в нижний регистр.
#  replace(old, new) заменяет все вхождения слова old новым .
#  len(str) возвращает длину строки (количество символов).
#  Взгляните на этот код для примеров:
# x = "This is some text"
#
# print(x.count("s"))
# print(x.upper())
# print(x.lower())
# print(x.replace("some text", "awesome"))
# print(len(x))
# TODO: Обратите внимание, что эти функции возвращают новую строку с соответствующей обработкой.

# x = 'abc'
# x = x * len(x)
# print(x.count('a'))

# a = input()
# b = input()
# text = "Amy has 128 dollars, while David has 54 dollars. Amy is going to the zoo. David watches soccer."
# new_text = text.replace(a, b)
# print(text.count(a))
# print(new_text)

# TODO: ЗАДАЧА: Частота букв
#  Вы делаете программу для анализа текста.
#  Возьмите текст в качестве первого ввода и букву в качестве второго ввода и
#  выведите частоту этой буквы в тексте в виде целого процента.
#  Пример ввода: hello
#  Пример ввода: l
#  Пример вывода: 40
#  Объяснение: Буква l встречается 2 раза в тексте hello, который состоит из 5 букв.
#  Таким образом, частота будет (2/5)*100 = 40 .
#  Результат деления — число с плавающей запятой.
#  Используйте функцию int() для преобразования результата в целое число.
# a = input()
# b = input()
# c = a.count(b)
# d = (c / len(a)) * 100
# print(int(d))

# TODO: Lists (Списки) используются для хранения нескольких элементов,
#  каждый из которых соответствует индексу. Они создаются с помощью квадратных скобок.
#  Например:
# names = ["James", "Tom", "Amy"]
# TODO: Список имен содержит три строки.
#  К каждому элементу списка можно получить доступ, используя его индекс:
#  Это выведет 2-й элемент списка.
#  Индекс первого элемента списка равен 0.
# names = ["James", "Tom", "Amy"]
# print(names[1])

# TODO: Списки можно использовать для представления набора данных, например,
#  возраста людей, ежемесячных темпов роста запасов и т. д.
#  Списки также можно вкладывать друг в друга для представления двумерных сеток, таких как матрицы:
#  Приведенный ниже код выводит 3-й элемент 2-й строки.
#  Матричную структуру можно использовать в тех случаях, когда вам нужно хранить данные в формате строки-столбца.
# m = [
#     [1, 2, 3],
#     [4, 5, 6]
# ]
# print(m[1][2])

# TODO: Список операций Список операций
#  Подобно строкам, мы можем использовать операторы in и not in , чтобы проверить, является ли элемент частью списка:
#  Функцию len() можно использовать для возврата количества элементов в списке.
# words = ["spam", "egg", "spam", "sausage"]
# print("spam" in words)
# print("egg" in words)
# print("tomato" in words)
# print(len(words))

# contacts = ["spam", "egg", "spam", "sausage"]
# name = input()
# if name in contacts:
#     print("Found")
# else:
#     print("Not Found")

# TODO: Loops (Цикл)
#  Подобно строкам, мы можем перебирать элементы списка, используя цикл:
#  n будет представлять текущий элемент списка во время каждой итерации.
# x = [2, 4, 6, 8]
#
# for n in x:
#     print(n)

# x = [2, 5, 7, 3, 1]
#
# res = 1
# for n in x:
#     res *= n
# print(res)

# TODO: ЗАДАЧА:
#  Вам дана двумерная матрица, которая представляет количество людей в комнате, сгруппированных по цвету глаз и полу.
#  Первый ряд представляет мужской пол, а второй ряд — женский.
#  Столбцы — это цвета глаз в следующем порядке: коричневый , синий , зеленый , черный.
#  Данные показывают, что, например, в комнате находится 20 зеленоглазых самок (2-й ряд, 3-й столбец).
#  Наша программа должна принимать цвет глаз в качестве входных данных и
#  выводить процент людей с таким цветом глаз в комнате.
#  data = [
#   [23, 11, 5, 14],
#   [8, 32, 20, 5]
#   ]
#  Пример ввода: синий
#  Пример вывода: 36
#  Объяснение: Есть 11+32=43 человека с голубыми глазами, что составляет 36% от общего числа.
#  Обратите внимание, что вывод должен быть целым числом: используйте функцию int() для преобразования результата.
# data = [
#   [23, 11, 5, 14],
#   [8, 32, 20, 5]
# ]
#
# color = input()
# res = sum(data[0]) + sum(data[1])
# if color == 'brown':
#     brown = data[0][0] + data[1][0]
#     print(int(brown / res * 100))
# elif color == 'blue':
#     blue = data[0][1] + data[1][1]
#     print(int(blue / res * 100))
# elif color == 'green':
#     green = data[0][2] + data[1][2]
#     print(int(green / res * 100))
# elif color == 'black':
#     black = data[0][3] + data[1][3]
#     print(int(black / res * 100))
# else:
#     print('No one has that eye color')

# TODO: List Functions (Функции списка)
#  Списки поддерживают следующие функции:
#  - append(item) добавляет элемент в конец списка.
#  - insert(index, item) добавляет элемент по заданному индексу в список.
#  - remove(item) удаляет элемент из списка.
#  - pop(index) удаляет элемент по заданному индексу.
#  - count(item) возвращает счетчик того, сколько раз элемент встречается в списке.
#  Элементы, которые находятся после вставленного элемента, смещаются вправо.
# x = [2, 4, 6]
# x.append(8)
# x.remove(4)
# x.insert(0, 8)
# print(x)
# print(x.count(8))

# x = [3, 1, 2, 5, 3, 1]
# x.append(8)
# x.insert(2, 6)
# x.remove(2)
# print(len(x))

# TODO:
#  - reverse() переворачивает элементы в списке.
#  - sort() сортирует список. По умолчанию список отсортирован по возрастанию.
#  Вы можете указать reverse=True в качестве параметра для сортировки по убыванию.
#  - max(list) возвращает максимальное значение.
#  - min(list) возвращает минимальное значение.
#  Некоторые примеры:
# x = [2, 4, 6, 8]
# x.reverse()
# print(x)
#
# x.sort()
# print(x)
#
# print(min(x))
# print(max(x))
# TODO: Обратите внимание, что функции reverse() и sort() изменяют список, в котором они вызываются.
# x = [8, 5, 42, 11, 20, 4]
# x.sort()
# print(max(x) - min(x) + x[2])

# TODO: ЗАДАЧА:
#  Вы анализируете цены на жилье. Данный код объявляет список цен на дома в районе.
#  Вам нужно подсчитать и вывести количество домов, цена которых выше средней.
#  Чтобы рассчитать среднюю цену домов, нужно разделить сумму всех цен на количество домов.
#  Используйте sum(list) для вычисления суммы всех элементов в списке и len(list) для получения количества элементов.
# prices = [125000, 78000, 110000, 65000, 300000, 250000, 210000, 150000, 165000, 140000, 125000, 85000, 90000, 128000,
#           230000, 225000, 100000, 300000]
# middle_price = sum(prices) / len(prices)
# res = 0
# for i in prices:
#     if i > middle_price:
#         res += 1
# print(res)

# TODO: List Comprehensions (Список понятий)
#  Генерация списков — это полезный способ быстрого создания списков, содержимое которых подчиняется правилу.
#  Понимание списков вдохновлено нотацией построителя множеств в математике.
#  Например, мы можем сделать следующее:
# cubes = [i ** 3 for i in range(5)]
# print(cubes)

# nums = [i * 2 for i in range(10)]
# print(nums)

# TODO: Понимание списка также может содержать оператор if для принудительного применения условия к значениям в списке.
#  Пример:
# evens = [i ** 2 for i in range(10) if i ** 2 % 2 == 0]
# print(evens)

# a = [i for i in range(20) if i % 3 == 0]
# print(a)

# TODO: ЗАДАЧА:
#  Каждый месяц количество насекомых в лаборатории удваивается.
#  Возьмите начальное количество насекомых в качестве входных данных и выведите список,
#  показывающий количество насекомых за каждый из следующих 12 месяцев, начиная с 0, что является начальным значением.
#  Итак, результирующий список должен содержать 12 пунктов,
#  каждый из которых показывает количество насекомых на начало этого месяца.
#  Пример ввода: 10
#  Пример вывода: [10, 20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 20480]
#  Создайте List Comprehensions, чтобы создать требуемый список.
#  Формула для подсчета количества насекомых через N месяцев будет выглядеть так: count*2ᴺ ,
#  где count — исходное количество насекомых.
# n = int(input())
# count = [n * 2 ** i for i in range(12)]
# print(count)

# nums = [10, 9, 8, 7, 6, 5]
# nums[0] = nums[1] - 5
# if 4 in nums:
#     print(nums[3])
# else:
#     print(nums[4])

# letters = ["a", "b", "c"]
# letters.append("d")
# print(len(letters))

# nums = (55, 44, 33, 22)
# print(max(min(nums[:2]), abs(-42)))

# TODO: ЗАДАЧА: Средняя длина слова
#  Учитывая предложение в качестве входных данных, вычислите и выведите среднюю длину слова этого предложения.
#  Чтобы вычислить среднюю длину слова, нужно разделить сумму всех длин слов на количество слов в предложении.
#  Пример ввода:
#  this is some text
#  Пример вывода:
#  3.5
#  Объяснение: В данном вводе 4 слова, всего 14 букв, поэтому средняя длина будет: 14/4 = 3,5
#  Строки имеют метод split(), который возвращает строку, разделенную на список, с заданным разделителем.
#  По умолчанию разделителем является пробел, поэтому вызов split() вернет список,
#  содержащий слова строки в качестве элементов.
# text = input()
# words = text.split()
# word_num = len(words)
# len_text = len(text) - (word_num - 1)
# avg = len_text / word_num
# print(avg)

# TODO: Dictionaries (Словари)
#  Мы видели, как списки позволяют нам хранить элементы с соответствующими им индексами.
#  Индексы в списке устанавливаются автоматически. Но что, если нам нужно установить собственный индекс?
#  Словари являются еще одним типом коллекций и позволяют нам сопоставлять произвольные ключи со значениями.
#  Словари можно индексировать так же, как и списки, используя квадратные скобки, содержащие ключи.
#  Каждый элемент словаря представлен парой ключ:значение.
#  Пример:
# ages = {"Dave": 24, "Mary": 42, "John": 58}
# print(ages["Dave"])
# print(ages["Mary"])

# TODO: Вы можете использовать строки, целые числа, логические значения и
#  любые другие неизменяемые типы в качестве ключей словаря.
#  Это означает, что вы не можете использовать списки или словари в качестве ключей:
#  Приведенный ниже код выдаст ошибку, так как он попытается использовать список в качестве ключа.
# bad_dict = {
#     [1, 2, 3]: "one two three",
# }

# TODO:
#  Чтобы определить, находится ли ключ в словаре, вы можете использовать in и not in так же, как и для списка.
#  Пример:
# nums = {
#     1: "one",
#     2: "two",
#     3: "three",
# }
# print(1 in nums)
# print("three" in nums)
# print(4 not in nums)

# TODO: Полезной функцией словаря является get().
#  Он делает то же самое, что и индексация, но если ключ не найден в словаре,
#  вместо этого возвращается другое указанное значение.
#  Чтобы определить количество элементов в словаре, используйте функцию len() .
#  Пример:
# pairs = {1: "apple",
#          "orange": [2, 3, 4],
#          True: False,
#          12: "True",
#          }
#
# print(pairs.get("orange"))
# print(pairs.get(7, 42))
# print(pairs.get(12345, "not found"))

# fib = {1: 1, 2: 1, 3: 2, 4: 3}
# print(fib.get(4, 0) + fib.get(7, 5))

# TODO: ЗАДАЧА:
#  Вы делаете телефонную книгу. Контакты хранятся в словаре,
#  где ключ — это имя, а значение — список, представляющий номер и адрес электронной почты контакта.
#  Вам нужно реализовать поиск: взять имя контакта на вход и вывести почту.
#  Если контакт не найден, выведите «Not found».
#  Обратите внимание, что электронная почта является вторым элементом списка.
# contacts = {
#     "David": ["123-321-88", "david@test.com"],
#     "James": ["241-879-093", "james@test.com"],
#     "Bob": ["987-004-322", "bob@test.com"],
#     "Amy": ["340-999-213", "a@test.com"]
# }
# name = input()
# if name in contacts:
#     print(contacts[name][1])
# else:
#     print("Not found")

# TODO: Tuples - Кортежи очень похожи на списки, за исключением того, что они неизменяемы (их нельзя изменить).
#  Кроме того, они создаются с использованием круглых скобок, а не квадратных скобок.
#  Пример:
# words = ("spam", "eggs", "sausages")
# TODO: Вы можете получить доступ к значениям в кортеже с их индексом, как и со списками:
# words = ("spam", "eggs", "sausages",)
# print(words[0])
# TODO: Попытка переназначить значение в кортеже приводит к ошибке.
# words = ("spam", "eggs", "sausages",)
# words[1] = "cheese"
# TODO: Подобно спискам и словарям, кортежи могут быть вложены друг в друга.

# TODO: Преимущество кортежей перед списками состоит в том, что
#  их можно использовать в качестве ключей для словарей (поскольку они неизменяемы):
#  Кортежи быстрее, чем списки, но их нельзя изменить.
# dict = {
#     ("David", 42): "red",
#     ("Bob", 24): "green"
# }
#
# print(dict[("Bob", 24)])

# tuple = (1, (1, 2, 3))
# print(tuple[1])

# TODO: Tuple Unpacking - Распаковка кортежей позволяет присвоить каждый элемент коллекции переменной.
#  Пример:
# numbers = (1, 2, 3)
# a, b, c = numbers
# print(a)
# print(b)
# print(c)
# TODO: Это также можно использовать для замены переменных, выполнив a, b = b, a ,
#  поскольку b, a в правой части формирует кортеж (b, a), который затем распаковывается.
# x, y = [1, 2]
# x, y = y, x
# print(x, y)

# TODO: Переменная, перед которой стоит звездочка (*),
#  принимает все значения из коллекции, оставшиеся от других переменных.
#  *c будут присвоены значения от 3 до 8.
#  Пример:
# a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# print(a)
# print(b)
# print(c)
# print(d)

# a, b, c, d, *e, f, g = range(20)
# print(len(e))

# TODO: ЗАДАЧА: Распаковка кортежа
#  Вы работаете над картографическим программным обеспечением. Карта хранится в виде списка точек,
#  где каждый элемент представлен в виде кортежа, содержащего координаты X и Y точки.
#  Вам нужно рассчитать и вывести расстояние до ближайшей точки от точки (0, 0).
#  Чтобы вычислить расстояние точки (x, y) от (0, 0), используйте следующую формулу: √x²+y²
#  Вы можете выполнить итерацию по списку и использовать распаковку кортежа, чтобы
#  получить координаты x и y каждой точки: для (x, y) в точках: и вывести наименьшее значение.
# points = [
#     (12, 55),
#     (880, 123),
#     (64, 64),
#     (190, 1024),
#     (77, 33),
#     (42, 11),
#     (0, 90)
# ]
# distance = []
# for i in points:
#     distance.append(((i[0] ** 2) + (i[1] ** 2)) ** 0.5)
# print(min(distance))

# import math
#
# points = [
#     (12, 55),
#     (880, 123),
#     (64, 64),
#     (190, 1024),
#     (77, 33),
#     (42, 11),
#     (0, 90)
# ]
# distance = list(range(len(points)))
#
# z = 0
# for (x, y) in points:
#     distance[z] = math.sqrt((x**2) + (y**2))
#     z += 1
# print(min(distance))

# TODO: Sets (Множества) — это наборы неупорядоченных элементов, которые являются уникальными.
#  Они создаются с помощью фигурных скобок, и благодаря способу их хранения быстрее проверить,
#  является ли элемент частью набора, используя оператор in, а не часть списка.
#  Наборы не могут содержать повторяющиеся элементы.
# num_set = {1, 2, 3, 4, 5}
# print(3 in num_set)
# print(num_set)

# letters = {"a", "b", "c", "d"}
# if "e" not in letters:
#     print(1)
# else:
#     print(2)

# TODO: Вы можете использовать функцию add() для добавления новых элементов в набор и
#  remove() для удаления определенного элемента:
#  Повторяющиеся элементы будут автоматически удалены из набора
# nums = {1, 2, 1, 3, 1, 4, 5, 6}
# print(nums)
# nums.add(-7)
# nums.remove(3)
# print(nums)

# TODO: Наборы можно комбинировать с помощью математических операций.
#  - Оператор объединения | объединяет два набора, чтобы сформировать новый, содержащий элементы в любом из них.
#  - Оператор пересечения & получает элементы только в обоих случаях .
#  - Оператор разности - получает элементы в первом наборе, но не во втором.
#  - Оператор симметричной разности ^ получает элементы в любом наборе, но не в обоих одновременно.
# first = {1, 2, 3, 4, 5, 6}
# second = {4, 5, 6, 7, 8, 9}
# print(first | second)
# print(first & second)
# print(first - second)
# print(second - first)
# print(first ^ second)

# a = {1, 2, 3}
# b = {0, 3, 4, 5}
# print(a | b)
# print(a & b)
# print(a - b)
# print(b - a)
# print(a ^ b)

# TODO: ЗАДАЧА: Sets (Множества)
#  Имея два предложения, вам нужно найти и вывести количество общих слов
#  (слов, которые присутствуют в обоих предложениях).
#  Пример ввода:
#  this is some text
#  I would like this tea and some cookies
#  Пример вывода: 2
#  Слова «some» и «this» встречаются в обоих предложениях.
#  Вы можете использовать функцию split(), чтобы получить список слов в строке, а затем использовать функцию set() ,
#  чтобы преобразовать его в набор. Например, чтобы преобразовать список x в набор, вы можете использовать: set(x)
# s1 = input()
# s2 = input()
# list1 = set(s1.split())
# list2 = set(s2.split())
# print(len(list1 & list2))

# TODO: Data Structures (Структуры данных)
#  Как мы видели в предыдущих уроках, Python поддерживает следующие типы коллекций:
#  - Lists,
#  - Dictionaries,
#  - Tuples,
#  - Sets
#  Вот несколько общих рекомендаций по выбору правильной структуры данных:
#  - Используйте словарь, когда вам нужна логическая связь между ключом и значением.
#  - Используйте списки, если у вас есть набор данных, к которым не требуется произвольный доступ.
#  Старайтесь выбирать списки, когда вам нужна простая итерируемая коллекция, которая часто изменяется.
#  - Используйте набор, если вам нужна уникальность элементов.
#  - Используйте кортежи, когда ваши данные не могут/не должны изменяться.
#  Часто кортеж используется в сочетании со словарем, например, кортеж может представлять ключ, потому что он неизменяем

# TODO: ЗАДАЧА: Билетная касса
#  Вы анализируете данные о продажах из кассы.
#  Билет для взрослого стоит 20 долларов, а билет для ребенка до 18 лет — 5 долларов.
#  Данные, которые вы получаете, представлены в формате словаря, где ключи — это
#  номера проданных билетов, а значения — возраст клиентов.
#  Например, «123-08»: 24 означает, что билет куплен 24-летним.
#  Ваша цель — рассчитать, насколько больше денег заработает офис, если он
#  изменит возраст скидки на билеты в соответствии с заданными входными данными.
#  Итак, ваша программа должна взять на вход целое число и вывести процент роста дохода,
#  если скидка была предоставлена людям младше этого возраста.
#  Например, если контора заработала 15 000 долларов США с исходным возрастом скидок и
#  заработала бы 18 000 долларов США с 14 в качестве возраста скидки,
#  тогда рост будет ((18000-15000)/15000)*100 = 20% Итак, для ввода 14 ваша программа должна вывести 20.
#  Выход должен быть целым числом (используйте int() для преобразования результата).
#  Для перебора значений словаря вы можете использовать класс. Функция values(): для значения в data.values()
# data = {
#     "100-90": 25, "42-01": 48, "55-09": 12, "128-64": 71, "002-22": 18, "321-54": 19, "097-32": 33, "065-135": 64,
#     "99-043": 80, "111-99": 11, "123-019": 5, "109-890": 72, "132-123": 27, "32-908": 27, "008-09": 25, "055-967": 35,
#     "897-99": 44, "890-98": 56, "344-32": 65, "43-955": 59, "001-233": 9, "089-111": 15, "090-090": 17, "56-777": 23,
#     "44-909": 27, "13-111": 21, "87-432": 15, "87-433": 14, "87-434": 23, "87-435": 11, "87-436": 12, "87-437": 16,
#     "94-121": 15, "94-122": 35, "80-089": 10, "87-456": 8, "87-430": 40
# }
# age = int(input())
# new = 0
# old = 0
# for x in data.values():
#     old += 5 if x < 18 else 20
# for var in data.values():
#     new += 5 if var < age else 20
# if age < 18:
#     print(int((new - old) / old * 100))
# else:
#     print(0)

# TODO: User-Defined Data Structures (Пользовательские структуры данных)
#  В предыдущих модулях мы видели встроенные в Python структуры данных, которые включают:
#  - списки
#  - словари
#  - кортежи
#  - наборы
#  Некоторым приложениям требуется дополнительная функциональность при работе с данными,
#  например, текстовые процессоры имеют функцию отмены-возврата, планировщикам задач нужны механизмы очередей,
#  картам нужен поиск кратчайшего пути и т. д. В этих случаях нам нужно определить свои собственные структуры данных,
#  которые обеспечить необходимый функционал.
#  Некоторые из самых популярных структур данных:
#  - Стеки
#  - Очереди
#  - Связанные списки
#  - Графики
#  Мы реализуем приведенные выше структуры данных и используем их для решения популярных задач.

# TODO: Stack (Стек) — это простая структура данных, которая добавляет и удаляет элементы в определенном порядке.
#  Каждый раз, когда добавляется элемент, он помещается на «верх» стека.
#  Только элемент в верхней части стопки может быть удален, как и стопка тарелок.
#  Такое поведение называется LIFO (последний пришел, первый ушел).
#  Добавление нового элемента в стек называется push.
#  Удаление элемента из стека называется pop.
#  Стеки приложений можно использовать для создания функций отмены и повтора,
#  синтаксического анализа выражений (преобразование инфикса в постфикс/префикс) и многого другого.
#  Стек можно реализовать с помощью списка в Python.

# TODO: Stack in Python
#  Давайте определим и реализуем класс Stack с соответствующими методами push, pop, is_empty и print_stack.
#  Мы будем использовать список для хранения данных.
# class Stack:
#     def __init__(self):
#         self.items = []
#
#     def is_empty(self):
#         return self.items == []
#
#     def push(self, item):
#         self.items.insert(0, item)
#
#     def pop(self):
#         return self.items.pop(0)
#
#     def print_stack(self):
#         print(self.items)
#
#
# s = Stack()
# s.push('a')
# s.push('b')
# s.push('c')
# s.print_stack()
#
# s.pop()
# s.print_stack()
# TODO: Как видите, стек легко создать с помощью списка.
#  Мы используем список с именем items для хранения наших элементов.
#  Метод push добавляет элемент в начало списка, а метод pop удаляет первый элемент списка.

# TODO: ЗАДАЧА: Stack
#  Вам нужно сделать кнопку «Назад» для браузера. Вы используете стек для хранения посещенных ссылок на веб-сайты.
#  Каждая новая посещенная ссылка помещается в стек. Кнопка «Назад» должна извлекать верхнюю ссылку из стека и
#  переходить к ней. Данный код объявляет класс Browser как стек и реализует некоторые из его методов.
#  Затем некоторые ссылки помещаются в стек. Затем используется цикл while, чтобы вернуться ко всем ссылкам и
#  распечатать их. Реализуйте требуемый метод pop() для Browser, чтобы данный код работал как положено.
#  Обратите внимание, что метод pop() должен возвращать значение, чтобы его можно было распечатать.
# class Browser:
#     def __init__(self):
#         self.links = []
#
#     def is_empty(self):
#         return self.links == []
#
#     def push(self, link):
#         self.links.insert(0, link)
#
#     def pop(self):
#         return self.links.pop(0)
#
#
# x = Browser()
# x.push('about:blank')
# x.push('www.sololearn.com')
# x.push('www.sololearn.com/courses/')
# x.push('www.sololearn.com/courses/python/')
#
# while not x.is_empty():
#     print(x.pop())

# TODO: Queue (очередь) - похожа на стек, но определяет другой способ добавления и удаления элементов.
#  Элементы вставляются с одного конца, называемого задним, и удаляются с другого конца, называемого передним.
#  Такое поведение называется FIFO (First in First Out).
#  Терминология Процесс добавления новых элементов в очередь называется enqueue.
#  Процесс удаления элемента из очереди называется удалением из очереди.
#  Очереди приложений используются всякий раз, когда нам нужно управлять объектами в порядке, начиная с первого.
#  Сценарии включают печать документов на принтере, системы колл-центров, отвечающие на звонки и т. д.
#  Списки Python — это самый простой способ реализовать функциональность очереди.

# TODO: Давайте реализуем класс Queue с соответствующими методами enqueue, dequeue, is_empty и print.
#  Мы будем использовать список для хранения элементов.
#  Метод enqueue добавляет элемент в начало списка, а метод dequeue удаляет последний элемент.
# class Queue:
#     def __init__(self):
#         self.items = []
#
#     def is_empty(self):
#         return self.items == []
#
#     def enqueue(self, item):
#         self.items.insert(0, item)
#
#     def dequeue(self):
#         return self.items.pop()
#
#     def print_queue(self):
#         print(self.items)
#
#
# q = Queue()
# q.enqueue('a')
# q.enqueue('b')
# q.enqueue('42')
# q.print_queue()
#
# q.dequeue()
# q.print_queue()

# TODO: ЗАДАЧА: Очередь
#  Вы делаете приложение колл-центра, которое должно обрабатывать клиентов в очереди.
#  Класс CallCenter реализован как Queue. Каждый элемент очереди имеет в качестве значения тему вызова.
#  Возможны два значения: «общие» и «технические».
#  Обработка «общего» звонка занимает в среднем 5 минут, а «технического» звонка — 10 минут.
#  Данный код добавляет несколько клиентов в очередь из пользовательского ввода.
#  Вам необходимо удалить из очереди всех добавленных клиентов, рассчитать и вывести общее время,
#  необходимое для обработки всех звонков.
#  Используйте цикл while, чтобы удалить всех клиентов из очереди, пока она не станет пустой.
# class CallCenter:
#     def __init__(self):
#         self.customers = []
#
#     def is_empty(self):
#         return self.customers == []
#
#     def add(self, x):
#         self.customers.insert(0, x)
#
#     def next(self):
#         return self.customers.pop()
#
#
# """
# general
# general
# technical
# general
# end
# """
# c = CallCenter()
# time_count = 0
# while True:
#     n = input()
#     if n == 'end':
#         break
#     c.add(n)
#     if n == "general":
#         time_count += 5
#     elif n == "technical":
#         time_count += 10
#         c.next()
# print(time_count)

