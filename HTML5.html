<!--HTML5-->
<!--При написании документов HTML5 одной из первых новых функций, которую вы заметите, является объявление типа документа:-->
<!--&lt;!&ndash;<!DOCTYPE HTML>&ndash;&gt;-->
<!--Объявление кодировки символов (charset) также упрощено:-->
<!--&lt;!&ndash;<meta charset="UTF-8">&ndash;&gt;-->
<!--Новые элементы в HTML5-->
<!--: <article>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <footer>,-->
<!--    <header>, <nav>, <output>, <progress >, <section>, <video> и многое другое!-->
<!--Кодировка символов по умолчанию в HTML5 — UTF-8.-->

<!--New in HTML5 (Новое в HTML5)-->
<!--Формы-->
<!--. Спецификация Web Forms 2.0 позволяет создавать более мощные формы и более привлекательный пользовательский интерфейс.-->
<!-- - Добавлены средства выбора даты, средства выбора цвета и числовые степперы.-->
<!-- - Типы полей ввода теперь включают электронную почту, поиск и URL-адрес.-->
<!-- - Теперь поддерживаются методы формы PUT и DELETE. Интегрированный API (интерфейсы прикладного программирования)-->
<!-- - Перетаскивание-->
<!-- - Аудио и видео-->
<!-- - Автономные веб-приложения-->
<!-- - История-->
<!-- - Локальное хранилище-->
<!-- - Геолокация-->
<!-- - Веб-сообщения-->

<!--The List of Content Models (Список моделей контента)-->
<!--В HTML элементы обычно принадлежали либо к блочному уровню, либо к встроенной модели содержимого.-->
<!--HTML5 представляет семь основных моделей контента:-->
<!-- - Metadata (Метаданные)-->
<!-- - Embedded (Встроенные)-->
<!-- - Interactive (Интерактивные)-->
<!-- - Heading (Заголовки)-->
<!-- - Phrasing (Фразы)-->
<!-- - Flow (Поток)-->
<!-- - Sectioning (Разделение)-->
<!--Модели содержимого HTML5 предназначены для того, чтобы-->
<!--сделать структуру разметки более понятной как для браузера, так и для веб-дизайнера.-->

<!--Content Models (Модели контента)-->
<!--Metadata (Метаданные): контент, который настраивает представление или поведение остального контента.-->
<!--Эти элементы находятся в заголовке документа.-->
<!--    Elements (Элементы): <base>, <link>, <meta>, <noscript>, <script>, <style>, <title>-->
<!--Embedded (Встроенный): контент, который импортирует другие ресурсы в документ.-->
<!--    Elements (Элементы): <audio>, <video>, <canvas>, <iframe>, <img>, <math>, <object>, <svg>-->
<!--Interactive (Интерактивный): контент, специально предназначенный для взаимодействия с пользователем.-->
<!--    Elements: <a>, <audio>, <video>, <button>, <details>, <embed>, <iframe>, <img>, <input>, <label>, <object>, <select>, <textarea>-->
<!--Heading (Заголовок): Определяет заголовок раздела.-->
<!--    Elements (Элементы): <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <hgroup>-->
<!--Phrasing (Фразировка): эта модель имеет ряд встроенных элементов уровня, общих с HTML4.-->
<!--    Elements (Элементы): <img>, <span>, <strong>, <label>, <br />, <small>, <sub>, и другие.-->
<!--Один и тот же элемент может принадлежать более чем одной модели содержимого.-->

<!--Content Models (Модели контента)-->
<!--Flow content (Текущее содержимое): содержит большинство элементов HTML5,-->
<!--которые были бы включены в обычный поток документа.-->
<!--Sectioning content (Разделение содержимого): определяет объем заголовков,-->
<!--содержимого, навигации и нижних колонтитулов.-->
<!--Элементы : <article>, <aside>, <nav>, <section>-->
<!--    См.Рис: picture/ContentModelsPicture.jpg-->
<!--    Различные модели содержимого перекрываются в определенных областях в зависимости от того, как они используются.-->

<!--Page Structure in HTML5 (Структура страницы в HTML5)-->
<!--Общая структура страницы HTML5 выглядит следующим образом:-->
<!--См. Рис: picture/PageStructureHTML5Picture.png-->
<!--Вам могут не понадобиться некоторые из этих элементов, в зависимости от структуры вашей страницы.-->

<!--The <header> Element (Элемент <header>)-->
<!--В HTML4 мы бы определили заголовок следующим образом:-->
<!--<div id="header">-->
<!--Вместо этого в HTML5 используется простой тег <header>. -->
<!--Элемент <header> подходит для использования внутри тега body.-->
<!--<!DOCTYPE html>-->
<!--<html>-->
<!--    <head></head>-->
<!--    <body>-->
<!--        <header>-->
<!--            <h1>Most important heading</h1>-->
<!--            <h2>Less important heading</h2>-->
<!--            <h3>Less important heading</h3>-->
<!--            <h4>Less important heading</h4>-->
<!--            <h5>Less important heading</h5>-->
<!--            <h6>Less important heading</h6>-->
<!--        </header>-->
<!--    </body>-->
<!--</html>-->
<!--Обратите внимание, что <header> полностью отличается от тега <head>.-->

<!--The <footer> Element (Элемент <footer>)-->
<!--Элемент нижнего колонтитула также широко используется.-->
<!--Обычно мы называем раздел, расположенный в самом низу веб-страницы, footer (нижним колонтитулом).-->
<!--<footer></footer>-->
<!--Между этими тегами обычно указывается следующая информация:-->
<!-- - Контактная информация-->
<!-- - Политика конфиденциальности-->
<!-- - Значки социальных сетей-->
<!-- - Условия использования-->
<!-- - Информация об авторских правах-->
<!-- - Карта сайта и сопутствующие документы-->

<!--The <nav> Element (Элемент <nav>)-->
<!--Этот тег представляет раздел страницы, который ссылается на другие страницы или на определенные разделы на странице. -->
<!--Это будет раздел с навигационными ссылками. Вот пример основного блока навигационных ссылок:-->
<!--<nav>-->
<!--    <ul>-->
<!--        <li><a href="#">Home</a></li>-->
<!--        <li><a href="#">Services</a></li>-->
<!--        <li><a href="#">About us</a></li>-->
<!--    </ul>-->
<!--</nav>-->
<!--Не все ссылки в документе должны находиться внутри элемента <nav>. -->
<!--Элемент <nav> предназначен только для основных блоков навигационных ссылок. -->
<!--Как правило, элемент <footer> часто содержит список ссылок,-->
<!--которые не обязательно должны находиться в элементе <nav>.-->

<!--TODO: The <article> Element (Элемент <статья>)-->
<!-- Статья — это самодостаточная, независимая часть контента, которую можно использовать-->
<!-- и распространять отдельно от остальной части страницы или сайта.-->
<!-- Это может быть сообщение на форуме, статья в журнале или газете, запись в блоге, комментарий,-->
<!-- интерактивный виджет или гаджет или любой другой независимый элемент контента.-->
<!-- Элемент <article> заменяет широко используемый в HTML4 элемент <div> вместе с идентификатором или классом.-->
<!--<article>-->
<!--    <h1>The article title</h1>-->
<!--    <p>Contents of the article element </p>-->
<!--</article>-->
<!--TODO: Когда элемент <article> вложен, внутренний элемент представляет статью, связанную с внешним элементом.-->
<!-- Например, комментарии к записи в блоге могут быть элементами <article>, -->
<!-- вложенными в элемент <article>, представляющий запись в блоге.-->

<!--TODO: The <section> Element (Элемент <section>)-->
<!-- <section> — это логический контейнер страницы или статьи.-->
<!-- Разделы можно использовать для разделения контента внутри статьи.-->
<!-- Например, на домашней странице может быть раздел для представления компании, -->
<!-- другой для новостей и еще один для контактной информации. -->
<!-- Каждый <section> должен быть идентифицирован, как правило, -->
<!-- путем включения заголовка (элемент h1-h6) в качестве дочернего элемента <section>.-->
<!-- Если имеет смысл отдельно синдицировать содержимое элемента <section>, -->
<!-- используйте вместо этого элемент <article>.-->
<!--<article>-->
<!--    <h1>Welcome</h1>-->
<!--    <section>-->
<!--        <h1>Heading</h1>-->
<!--        <p>content or image</p>-->
<!--    </section>-->
<!--</article>-->

<!--TODO: The <aside> Element (Элемент <aside>)-->
<!-- <aside> — это вторичное или второстепенное содержимое, которое можно рассматривать как отдельное, -->
<!-- но косвенно связанное с основным содержанием.-->
<!-- Этот тип контента часто представлен на боковых панелях.-->
<!-- Когда тег <aside> используется внутри тега <article>, -->
<!-- содержимое <aside> должно быть конкретно связано с этой статьей.-->
<!--<article>-->
<!--    <h1> Gifts for everyone</h1>-->
<!--    <p>This website will be the best place for choosing gifts</p>-->
<!--    <aside>-->
<!--        <p>Gifts will be delivered to you within 24 hours</p>-->
<!--    </aside>-->
<!--</article>-->

<!--TODO: Audio on the Web (Аудио в Интернете)-->
<!-- До HTML5 не существовало стандарта воспроизведения аудиофайлов на веб-странице.-->
<!-- Элемент HTML5 <audio> определяет стандарт для встраивания звука в веб-страницу. -->
<!-- Существует два разных способа указать URL-адрес исходного аудиофайла. -->
<!-- Первый использует исходный атрибут:-->
<!--<audio src="http://www.sololearn.com/uploads/audio.mp3" controls>-->
<!--    Audio element not supported by your browser-->
<!--</audio>-->
<!--TODO: Второй способ использует элемент <source> внутри элемента <audio>:-->
<!--<audio controls>-->
<!--    <source src="http://www.sololearn.com/uploads/audio.mp3" type="audio/mpeg">-->
<!--    <source src="http://www.sololearn.com/uploads/audio.ogg" type="audio/ogg">-->
<!--</audio>-->
<!--TODO: Несколько элементов <source> могут быть связаны с разными аудиофайлами. -->
<!-- Браузер будет использовать первый распознанный формат.-->

<!--TODO: Audio on the Web (Аудио в Интернете)-->
<!-- Элемент <audio> создает аудиоплеер внутри браузера.-->
<!-- Текст между тегами <audio> и </audio> будет отображаться в браузерах, не поддерживающих элемент <audio>.-->
<!--<audio controls>-->
<!--    <source src="http://www.sololearn.com/uploads/audio.mp3" type="audio/mpeg">-->
<!--    <source src="http://www.sololearn.com/uploads/audio.ogg" type="audio/ogg">-->
<!--    Audio element not supported by your browser.-->
<!--</audio>-->

<!--TODO: Attributes of <audio> (Атрибуты <аудио>)-->
<!-- control-->
<!-- Указывает, что должны отображаться элементы управления звуком-->
<!-- (например, кнопка воспроизведения/паузы и т. д.)-->
<!-- autoplay-->
<!-- Когда этот атрибут определен, звук начинает воспроизводиться,-->
<!-- как только он будет готов, без запроса разрешения посетителя.-->
<!--<audio controls autoplay>-->
<!--    <source src="http://www.sololearn.com/uploads/audio.mp3" type="audio/mpeg">-->
<!--    Audio element not supported by your browser.-->
<!--</audio>-->
<!--TODO: loop (цикл)-->
<!-- Этот атрибут используется для повторного воспроизведения звука каждый раз, когда он заканчивается.-->
<!--<audio controls autoplay loop>-->
<!--    <source src="http://www.sololearn.com/uploads/audio.mp3" type="audio/mpeg">-->
<!--    Audio element not supported by your browser.-->
<!--</audio>-->
<!--TODO: В настоящее время существует три поддерживаемых формата файлов для элемента <audio>: MP3, WAV и OGG.-->

<!--TODO: Videos in HTML (Видео в HTML)-->
<!-- Элемент видео аналогичен элементу аудио.-->
<!-- Вы можете указать URL-адрес источника видео, используя атрибут в элементе видео-->
<!-- или используя исходные элементы внутри элемента видео:-->
<!-- Еще один общий аспект аудио- и видеоэлементов заключается в том, -->
<!-- что не все основные браузеры поддерживают одни и те же типы файлов. -->
<!-- Если браузер не поддерживает первый тип видео, он попытается использовать следующий.-->
<!--<video controls>-->
<!--   <source src="http://www.sololearn.com/uploads/video.mp4" type="video/mp4">-->
<!--   <source src="http://www.sololearn.com/uploads/video.ogg" type="video/ogg">-->
<!--   Video is not supported by your browser-->
<!--</video>-->

<!--TODO: Attributes of <video> (Атрибуты <видео>)-->
<!-- Еще один аспект, общий для аудио и видео элементов, заключается в том, что каждый из них имеет-->
<!-- controls (элементы управления), autoplay (автозапуск) и атрибуты loop (цикла).-->
<!-- В этом примере видео будет воспроизводиться после завершения воспроизведения:-->
<!-- В настоящее время существует три поддерживаемых видеоформата для элемента <video>: MP4, WebM и OGG.-->
<!--<video controls autoplay loop>-->
<!--   <source src="http://www.sololearn.com/uploads/video.mp4" type="video/mp4">-->
<!--   <source src="http://www.sololearn.com/uploads/video.ogg" type="video/ogg">-->
<!--   Video is not supported by your browser-->
<!--</video>-->

<!--<video width="600" height="400" muted controls autoplay loop>-->
<!--    <source src="http://www.sololearn.com/uploads/video.mp4" type="video/mp4">-->
<!--    <source src="http://www.sololearn.com/uploads/video.ogg" type="video/ogg">-->
<!--    Video is not supported by your browser-->
<!--</video>-->

<!--TODO: Progress Bar (Индикатор)-->
<!-- Элемент <progress> позволяет создавать индикаторы выполнения в Интернете.-->
<!-- Элемент прогресса можно использовать в заголовках, абзацах или где-либо еще в теле. -->
<!-- Значение атрибутов элемента прогресса : указывает, какая часть задачи была выполнена. -->
<!-- Max : указывает, сколько работы требуется задаче в целом. -->
<!--Используйте тег <progress> в сочетании с JavaScript для динамического отображения хода выполнения задачи.-->
<!-- Пример:-->
<!--Status: <progress min="0" max="100" value="35">-->
<!--</progress>-->

<!--TODO: HTML5 Web Storage (Веб-хранилище HTML5)-->
<!-- С веб-хранилищем HTML5 веб-сайты могут хранить данные на локальном компьютере пользователя.-->
<!-- До HTML5 нам приходилось использовать файлы cookie JavaScript для реализации этой функциональности.-->
<!-- Преимущества веб-хранилища:-->
<!-- - More secure (Более безопасный)-->
<!-- - Faster (Быстрее)-->
<!-- - Stores a larger amount of data (Хранит больший объем данных)-->
<!-- - Stored data is not sent with every server request (Сохраненные данные не отправляются с каждым запросом к серверу)-->
<!-- Локальное хранилище для каждого домена.-->
<!-- Все страницы из одного домена могут хранить и получать доступ к одним и тем же данным.-->

<!--TODO: Types of Web Storage Objects (Типы объектов веб-хранилища)-->
<!-- Существует два типа объектов веб-хранилища:-->
<!--  - sessionStorage()-->
<!--  - localStorage()-->
<!-- Local vs. Session (Локальное против сеансовое)-->
<!--  - Хранилище сеанса уничтожается, как только пользователь закрывает браузер-->
<!--  - Локальное хранилище хранит данные без даты истечения срока действия-->
<!-- Вам необходимо знать основы JavaScript, чтобы понимать и использовать API.-->

<!--TODO: Working with Values (Работа со значениями)-->
<!-- Синтаксис веб-хранилища как для локального, так и для сеансового хранилища очень прост и похож.-->
<!-- Данные хранятся в виде пар ключ/значение.-->
<!-- Сохранение значения:-->
<!--    localStorage.setItem("key1", "value1");-->
<!-- Получение значения:-->
<!--    //this will print the value-->
<!--    alert(localStorage.getItem("key1"));-->
<!-- Удаление значения:-->
<!--    localStorage.removeItem("key1");-->
<!-- Удаление всех значений:-->
<!--    localStorage.clear();-->
<!-- Тот же синтаксис применяется к хранилищу сеансов с одним отличием:-->
<!-- вместо localStorage используется sessionStorage.-->

<!--TODO: What is the Geolocation API? (Что такое API геолокации?)-->
<!-- В HTML5 API геолокации используется для получения географического местоположения пользователя. -->
<!-- Поскольку это может поставить под угрозу конфиденциальность пользователя, -->
<!-- этот параметр недоступен, если пользователь не одобрит его.-->
<!-- Геолокация намного точнее для устройств с GPS, таких как смартфоны и тому подобное.-->

<!--TODO: Using HTML Geolocation (Использование HTML-геолокации)-->
<!-- Основным методом Geolocation API является getCurrentPosition,-->
<!-- который извлекает текущее географическое местоположение устройства пользователя.-->
<!--    navigator.geolocation.getCurrentPosition();-->
<!-- Параметры:-->
<!-- showLocation (mandatory) (обязательный): определяет метод обратного вызова, который извлекает информацию о местоположении.-->
<!-- ErrorHandler(optional) (необязательно): определяет метод обратного вызова,-->
<!-- который вызывается при возникновении ошибки при обработке асинхронного вызова.-->
<!-- Options (optional) (необязательно): определяет набор параметров для получения информации о местоположении.-->
<!-- Вам необходимо знать основы JavaScript, чтобы понимать и использовать API.-->

<!--TODO: Presenting Data (Представление данных)-->
<!-- Местоположение пользователя может быть представлено двумя способами: геодезическим и гражданским.-->
<!-- 1. Geodetic (Геодезический) способ описания местоположения относится непосредственно к широте и долготе.-->
<!-- 2. Civic (Гражданское) представление данных о местоположении представлено в формате,-->
<!-- который легче читать и понимать среднему человеку.-->
<!-- Каждый параметр имеет как геодезическое, так и гражданское представление:-->
<!--     См. Рис: mandatoryPicture.png-->
<!-- Метод getCurrentPosition() возвращает объект в случае успеха.-->
<!-- Всегда возвращаются свойства широты, долготы и точности.-->

<!--TODO: Making Elements Draggable (Делаем элементы перетаскиваемыми)-->
<!-- Функция drag and drop (перетаскивания) позволяет «grab» (захватить) объект и перетащить его в другое место.-->
<!-- Чтобы сделать элемент перетаскиваемым, просто установите для атрибута draggable значение true:-->
<!--     <img draggable="true" />-->
<!-- Любой элемент HTML можно перетаскивать.-->
<!-- API для перетаскивания HTML5 основан на событиях.-->
<!-- Пример:-->
<!--<!DOCTYPE HTML>-->
<!--<html>-->
<!--   <head>-->
<!--   <script>-->
<!--function allowDrop(ev) {-->
<!--    ev.preventDefault();-->
<!--}-->

<!--function drag(ev) {-->
<!--    ev.dataTransfer.setData("text", ev.target.id);-->
<!--}-->

<!--function drop(ev) {-->
<!--    ev.preventDefault();-->
<!--    var data = ev.dataTransfer.getData("text");-->
<!--    ev.target.appendChild(document.getElementById(data));-->
<!--}-->
<!--   </script>-->
<!--   </head>-->
<!--<body>-->

<!--   <div id="box" ondrop="drop(event)"-->
<!--   ondragover="allowDrop(event)"-->
<!--   style="border:1px solid black;-->
<!--   width:200px; height:200px"></div>-->

<!--   <img id="image" src="sample.jpg" draggable="true"-->
<!--   ondragstart="drag(event)" width="150" height="50" alt="" />-->

<!--</body>-->
<!--</html>-->
<!--TODO: Что перетаскивать-->
<!-- Когда элемент перетаскивается, атрибут ondragstart вызывает функцию drag(event),-->
<!-- которая указывает, какие данные следует перетаскивать.-->
<!-- Метод dataTransfer.setData() устанавливает тип данных и значение перетаскиваемых данных:-->
<!--     function drag(ev) {-->
<!--         ev.dataTransfer.setData("text", ev.target.id);-->
<!--     }-->
<!-- В нашем примере тип данных — «текст», а значение — идентификатор перетаскиваемого элемента («изображение»).-->
<!-- Куда перетащить Событие ondragover указывает, куда можно перетащить перетаскиваемые данные.-->
<!-- По умолчанию данные и элементы не могут быть перенесены в другие элементы.-->
<!-- Чтобы разрешить удаление, мы должны запретить обработку элемента по умолчанию.-->
<!-- Это делается путем вызова события. Метод preventDefault() для события ondragover.-->
<!-- Выполните сброс Когда перетаскиваемые данные удаляются, происходит событие сброса.-->
<!-- В приведенном выше примере атрибут ondrop вызывает функцию drop(event):-->
<!--     function drop(ev) {-->
<!--         ev.preventDefault();-->
<!--         var data = ev.dataTransfer.getData("text");-->
<!--         ev.target.appendChild(document.getElementById(data));-->
<!--     }-->
<!-- Метод preventDefault() предотвращает обработку данных браузером по умолчанию-->
<!-- (по умолчанию открывается как ссылка при перетаскивании).-->
<!-- Доступ к перетаскиваемым данным можно получить с помощью метода dataTransfer.getData().-->
<!-- Этот метод вернет все данные, для которых был установлен тот же тип в методе setData().-->
<!-- Перетаскиваемые данные — это идентификатор перетаскиваемого элемента («изображение»).-->
<!-- В конце перетаскиваемый элемент добавляется к перетаскиваемому с помощью функции appendChild().-->
<!-- Базовые знания JavaScript необходимы для понимания и использования API.-->

<!--TODO: Drawing Shapes (Рисование фигур)-->
<!-- SVG означает масштабируемую векторную графику и используется для рисования фигур с разметкой в стиле HTML. -->
<!-- Он предлагает несколько методов рисования контуров, прямоугольников, кругов, текста и графических изображений.-->
<!-- SVG не основан на пикселях, поэтому его можно бесконечно увеличивать без потери качества.-->

<!--TODO: Inserting SVG Images (Вставка изображений SVG)-->
<!-- Изображение SVG можно добавить в код HTML с помощью простого тега изображения,-->
<!-- который включает исходный атрибут, указывающий на изображение:-->
<!--  <img src="image.svg" alt="" height="300" />-->
<!-- SVG определяет векторную графику в формате XML.-->

<!--TODO: Drawing a Circle (Рисование круга)-->
<!-- Чтобы рисовать фигуры с помощью SVG,-->
<!-- вам сначала нужно создать тег элемента SVG с двумя атрибутами: шириной и высотой.-->
<!--    svg width="1000" height="1000"></svg>-->
<!-- Чтобы создать круг, добавьте тег <circle>:-->
<!--<svg width="2000" height="2000">-->
<!--   <circle cx="80" cy="80" r="50" fill="green" stroke="red" />-->
<!--</svg>-->
<!--TODO:  - cx смещает центр круга дальше вправо от экрана-->
<!--       - cy смещает центр круга дальше вниз от верхней части экрана-->
<!--       - r определяет радиус-->
<!--       - fill (заливка) определяет цвет нашего круга-->
<!--       - stroke (штрих) добавляет контур к кругу-->
<!-- Результат:-->
<!-- Каждый элемент и каждый атрибут в файлах SVG можно анимировать.-->

<!--TODO: Other Shape Elements (Другие элементы формы)-->
<!-- <rect> определяет прямоугольник:-->
<!--TODO: Следующий код нарисует прямоугольник, заполненный зеленым цветом.-->
<!--<svg width="2000" height="2000">-->
<!--   <rect width="300" height="100"-->
<!--     x="20" y="20" fill="green" />-->
<!--</svg>-->
<!--TODO: <line> определяет сегмент линии:-->
<!-- (x1, y1) - определяют начальные координаты (x2, y2) - определяют конечные координаты.-->
<!--<svg width="400" height="410">-->
<!--    <line x1="10" y1="10" x2="200" y2="100"-->
<!--        style="stroke:#000000; stroke-linecap:round;-->
<!--        stroke-width:20"  />-->
<!--</svg>-->
<!--TODO: <polyline> определяет формы, построенные из нескольких определений линий:-->
<!--<svg width="2000" height="500">-->
<!--    <polyline style="stroke-linejoin:miter; stroke:black;-->
<!--        stroke-width:12; fill: none;"-->
<!--        points="100 100, 150 150, 200 100" />-->
<!--</svg>-->
<!--TODO: Точки — это координаты полилинии.-->
<!-- Код ниже нарисует черную галочку:-->
<!-- Атрибуты ширины и высоты элемента <rect> определяют высоту и ширину прямоугольника.-->

<!--TODO: <ellipse> and <polygon> (<эллипс> и <многоугольник>)-->
<!-- Эллипс-->
<!-- <ellipse> похож на <circle>, за одним исключением:-->
<!-- вы можете независимо изменять горизонтальную и вертикальную оси его радиуса, используя атрибуты rx и ry .-->
<!--<svg height="500" width="1000">-->
<!--   <ellipse cx="200" cy="120" rx="150" ry="70" style="fill:green" />-->
<!--</svg>-->
<!--TODO: Многоугольник Элемент <polygon> используется для создания изображения как минимум с тремя сторонами. -->
<!-- Элемент многоугольника уникален, потому что он автоматически закрывает форму для вас.-->
<!--<svg width="2000" height="2000">-->
<!--<polygon points="100 100, 200 200, 300 0"-->
<!--      style="fill: green; stroke:black;" />-->
<!--</svg>-->
<!--TODO: polygon (Многоугольник) происходит от греческого. «poly» означает «много», а «gon» означает «угол».-->

<!--TODO: Shape Animations (Анимация формы)-->
<!-- Анимации SVG можно создавать с помощью элемента <animate>.-->
<!-- В приведенном ниже примере создается прямоугольник,-->
<!-- который изменит свое положение через 3 секунды, а затем дважды повторит анимацию:-->
<!--<svg width="1000" height="250">-->
<!--    <rect width="150" height="150" fill="orange">-->
<!--        <animate attributeName="x" from="0" to="300"-->
<!--      dur="3s" fill="freeze" repeatCount="2"/>-->
<!--    </rect>-->
<!--</svg>-->
<!--TODO: attributeName: Указывает, какой атрибут будет затронут анимацией-->
<!-- from (от): Указывает начальное значение атрибута-->
<!-- to (до): Указывает конечное значение атрибута-->
<!-- dur: Указывает, как долго выполняется анимация (длительность)-->
<!-- fill: Указывает, должно ли значение атрибута вернуться к своему начальному значению,-->
<!-- когда анимация завершена (значения: «remove» сбрасывает значение; «freeze» сохраняет значение «to value»)-->
<!-- RepeatCount: указывает количество повторов анимации.-->
<!-- В приведенном выше примере прямоугольник меняет свой атрибут x от 0 до 300 за 3 секунды.-->
<!-- Чтобы повторять анимацию бесконечно, используйте значение "indefinite" для атрибута RepeatCount.-->

<!--TODO: Paths (Пути)-->
<!-- Элемент <path> используется для определения пути.-->
<!-- Для данных пути доступны следующие команды:-->
<!-- M: (moveto) перейти к-->
<!-- L: (lineto) линия к-->
<!-- H: (horizontal lineto) горизонтальная линия к-->
<!-- V: (vertical lineto) вертикальная линия к-->
<!-- C: (curveto) кривая к-->
<!-- S: (smooth curveto) плавная кривая к-->
<!-- Q: (quadratic Bézier curve) квадратичная кривая Безье-->
<!-- T: (smooth quadratic Bézier curveto) гладкая квадратичная кривая Безье к-->
<!-- A: (elliptical Arc) эллиптическая дуга-->
<!-- Z: (closepath) замкнутый путь путь с использованием атрибута d:-->
<!--<svg width="500" height="500">-->
<!--<path d="M 0 0 L200 200 L200 0 Z" style="stroke:#000;  fill:none;" />-->
<!--</svg>-->
<!--TODO: M помещает наше «виртуальное перо» вниз в положение 0, 0.-->
<!-- Затем оно перемещается на 200 пикселей вниз и вправо, затем перемещается вверх в положение 200, 0.-->
<!-- Команда Z закрывает фигуру, что приводит к гипотенузе:-->
<!-- Все вышеперечисленные команды также могут быть выражены строчными буквами.-->
<!-- Когда используются заглавные буквы, это указывает на абсолютную позицию; нижний регистр указывает относительное положение.-->

<!--TODO: The <canvas> Element (Элемент <холст>)-->
<!-- Холст HTML используется для рисования графики, включающей все,-->
<!-- от простых линий до сложных графических объектов.-->
<!-- Элемент <canvas> определяется:-->
<!--    <canvas id="canvas1" width="200" height="100">-->
<!--    </canvas>-->
<!-- Элемент <canvas> — это только контейнер для графики.-->
<!-- Вы должны использовать скрипт для фактического рисования графики (обычно JavaScript).-->
<!-- Элемент <canvas> должен иметь атрибут id, чтобы на него мог ссылаться JavaScript:-->
<!--<html>-->
<!--   <head></head>-->
<!--   <body>-->
<!--     <canvas id="canvas1"-->
<!--   width="400" height="300"></canvas>-->

<!--   <script>-->
<!--      var can = document.getElementById("canvas1");-->
<!--      var ctx = can.getContext("2d");-->
<!--   </script>-->

<!--   </body>-->
<!--</html>-->
<!--TODO: getContext() возвращает контекст рисования на холсте.-->
<!-- Базовые знания JavaScript необходимы для понимания и использования Canvas.-->

<!--TODO: Canvas Coordinates (Координаты холста)-->
<!-- Холст HTML представляет собой двумерную сетку.-->
<!-- Верхний левый угол холста имеет координаты (0,0).-->
<!-- Координата X увеличивается вправо.-->
<!-- Координата Y увеличивается к нижней части холста.-->
<!--     См. Рис: CanvasCoordinatesPicture.jpg-->
<!-- Элемент <canvas> — это только контейнер для графики.-->

<!--TODO: Drawing Shapes (Рисование фигур)-->
<!-- Метод fillRect(x, y, w, h) рисует «закрашенный» прямоугольник,-->
<!-- в котором w указывает ширину, а h — высоту.-->
<!-- Цвет заливки по умолчанию черный.-->
<!-- Черный прямоугольник размером 100*100 пикселей рисуется на холсте в позиции (20, 20):-->
<!--<html>-->
<!--    <head></head>-->
<!--    <body>-->
<!--        <canvas id="canvas1" width="400" height="300">-->
<!--        </canvas>-->
<!--    <script>-->
<!--        var c=document.getElementById("canvas1");-->
<!--        var ctx=c.getContext("2d");-->
<!--        ctx.fillRect(20,20,100,100);-->
<!--    </script>-->
<!--    </body>-->
<!--</html>-->
<!--TODO: Свойство fillStyle используется для установки цвета, градиента или узора для заливки рисунка.-->
<!-- Использование этого свойства позволяет рисовать прямоугольник, заполненный зеленым цветом.-->
<!--<html>-->
<!--    <head></head>-->
<!--    <body>-->
<!--        <canvas id="canvas1" width="400" height="300">-->
<!--        </canvas>-->
<!--        <script>-->
<!--            var canvas=document.getElementById("canvas1");-->
<!--            var ctx=canvas.getContext("2d");-->
<!--            ctx.fillStyle ="rgba(0, 200, 0, 1)";-->
<!--            ctx.fillRect (36, 10, 22, 22);-->
<!--        </script>-->
<!--    </body>-->
<!--</html>-->
<!--TODO: холст поддерживает различные другие методы рисования:-->
<!-- Рисование линии moveTo(x,y): определяет начальную точку линии.-->
<!-- lineTo(x,y): определяет конечную точку линии.-->
<!-- Нарисовать круг beginPath(): Начинает рисование.-->
<!-- arc(x,y,r,start,stop): устанавливает параметры окружности.-->
<!-- Stroke(): завершает рисование.-->
<!-- Градиенты createLinearGradient(x,y,x1,y1): создает линейный градиент.-->
<!-- createRadialGradient(x,y,r,x1,y1,r1): создает радиальный/круговой градиент.-->
<!-- Рисование текста на холсте.-->
<!-- Шрифт: определяет свойства шрифта для текста.-->
<!-- fillText(text,x,y): рисует «залитый» текст на холсте.-->
<!-- strokeText(text,x,y): рисует текст на холсте (без заливки).-->
<!-- Существует множество других методов, помогающих рисовать фигуры и изображения на холсте.-->

<!--TODO: Canvas vs. SVG (Холст против SVG)-->
<!-- Холст:-->
<!-- — Элементы рисуются программно-->
<!-- — Рисование выполняется с помощью пикселей-->
<!-- — Анимация не встроена-->
<!-- — Высокая производительность операций рисования на основе пикселей-->
<!-- — Зависит от разрешения-->
<!-- — Нет поддержки обработчиков событий-->
<!-- — Полученное изображение можно сохранить в формате .png или .jpg-->
<!-- — Хорошо подходит для игр с интенсивным использованием графики -->
<!-- SVG: -->
<!--  - Элементы являются частью DOM страницы (объектная модель документа) -->
<!--  - Рисование выполняется с помощью векторов -->
<!--  - Встроены эффекты, такие как анимация -->
<!--  - Основан на стандартном синтаксисе XML, который обеспечивает лучшую доступность -->
<!--  - Независимость от разрешения -->
<!--  - Поддержка обработчиков событий -->
<!--  - Не подходит для игровых приложений-->
<!--  - Лучше всего подходит для приложений с большими областями рендеринга (например, Google Maps)-->
<!-- На самом деле вы можете использовать и SVG, и холст на одной странице, если это необходимо.-->
<!-- Однако вы не можете просто нарисовать SVG на холсте или наоборот.-->

<!--TODO: Working with Canvas (Работа с холстом)-->
<!-- Элемент Canvas можно трансформировать.-->
<!-- Например, текст написан на холсте по координатам (10, 30).-->
<!--<html>-->
<!--    <head></head>-->
<!--    <body>-->
<!--        <canvas id="canvas1" width="400" height="300">-->
<!--        </canvas>-->
<!--    <script>-->
<!--        var c=document.getElementById("canvas1");-->
<!--        var ctx=c.getContext("2d");-->
<!--        ctx.font="bold 22px Tahoma";-->
<!--        ctx.textAlign="start";-->
<!--        ctx.fillText("start", 10, 30);-->
<!--    </script>-->
<!--    </body>-->
<!--</html>-->
<!--TODO: метод translate(x,y) используется для перемещения холста.-->
<!-- x указывает, насколько далеко сместить сетку по горизонтали,-->
<!-- а y указывает, насколько далеко сместить сетку по вертикали.-->
<!--<html>-->
<!--    <head></head>-->
<!--    <body>-->
<!--        <canvas id="canvas1" width="400" height="300">-->
<!--        </canvas>-->
<!--    <script>-->
<!--        var c=document.getElementById("canvas1");-->
<!--        var ctx=c.getContext("2d");-->
<!--        ctx.font="bold 22px Tahoma";-->
<!--        ctx.textAlign="start";-->
<!--        ctx.fillText("start", 10, 30);-->
<!--        ctx.translate(100, 150);-->
<!--        ctx.fillText("after translate", 10, 30);-->
<!--    </script>-->
<!--    </body>-->
<!--</html>-->
<!--TODO: В этом примере холст сдвинут на 100 пикселей вправо и на 150 пикселей вниз.-->
<!-- Результат:-->
<!-- Canvas имеет несколько методов для рисования контуров, прямоугольников, кругов, текста и добавления изображений.-->

<!--TODO: The rotate() Method ( Метод поворота() )-->
<!-- Метод rotate() используется для поворота холста HTML5.-->
<!-- Значение должно быть в радианах, а не в градусах.-->
<!-- Вот пример, который рисует один и тот же прямоугольник до и после установки поворота:-->
<!-- Поворот повлияет только на рисунки, сделанные после поворота.-->
<!--<html>-->
<!--    <head></head>-->
<!--    <body>-->
<!--        <canvas id="canvas1" width="1000" height="1000">-->
<!--        </canvas>-->
<!--    <script>-->
<!--        var c=document.getElementById("canvas1");-->
<!--        var ctx=c.getContext("2d");-->
<!--        ctx.fillStyle = "#FF0000";-->
<!--        ctx.fillRect(10,10, 100, 100);-->

<!--        ctx.rotate( (Math.PI / 180) * 25);  //rotate 25 degrees.-->

<!--        ctx.fillStyle = "#0000FF";-->
<!--        ctx.fillRect(10,10, 100, 100);-->
<!--    </script>-->
<!--    </body>-->
<!--</html>-->

<!--TODO: The scale() Method ( Метод шкалы() )-->
<!-- Метод scale() масштабирует текущий рисунок. Он принимает два параметра:-->
<!--  - Количество раз, на которое изображение должно быть масштабировано по оси X.-->
<!--  - Количество раз, на которое изображение должно быть масштабировано в направлении Y.-->
<!--<html>-->
<!--    <head></head>-->
<!--    <body>-->
<!--        <canvas id="canvas1" width="400" height="400">-->
<!--        </canvas>-->
<!--    <script>-->
<!--        var canvas = document.getElementById('canvas1');-->
<!--        ctx =canvas.getContext('2d');-->
<!--        ctx.font="bold 22px Tahoma";-->
<!--        ctx.textAlign="start";-->
<!--        ctx.fillText("start", 10, 30);-->
<!--        ctx.translate(100, 150);-->
<!--        ctx.fillText("after translate", 0, 0);-->
<!--        ctx.rotate(1);-->
<!--        ctx.fillText("after rotate", 0, 0);-->
<!--        ctx.scale(1.5, 4);-->
<!--        ctx.fillText("after scale", 0,20);-->
<!--    </script>-->
<!--    </body>-->
<!--</html>-->
<!--TODO: Это увеличит холст в 1,5 раза по оси X и в 4 раза по оси Y:-->
<!-- Если вы масштабируете чертеж, все будущие чертежи также будут масштабироваться.-->

<!--TODO: HTML5 Forms (HTML5-формы)-->
<!-- HTML5 предоставляет множество функций и улучшений для создания веб-форм.-->
<!-- Были введены новые атрибуты и типы ввода, которые помогают улучшить взаимодействие с веб-пользователями.-->
<!-- Создание формы выполняется в HTML5 так же, как и в HTML4:-->
<!--<form>-->
<!--    <label>Your name:</label>-->
<!--    <input id="user" name="username" type="text" />-->
<!--</form>-->
<!--TODO: Используйте атрибут novalidate, чтобы избежать проверки формы при отправке.-->

<!--TODO: New Attributes-->
<!-- Новые атрибуты-->
<!-- В HTML5 появился новый атрибут под названием placeholder. -->
<!-- В элементах <input> и <textarea> этот атрибут предоставляет пользователю подсказку о том, -->
<!-- какую информацию можно ввести в поле.-->
<form>
    <label for="email">Your e-mail address: </label>
    <input type="text" name="email" placeholder="email@example.com" />
</form>
<!--TODO: Атрибут автофокуса делает желаемый ввод фокусом при загрузке формы:-->
<!-- Требуемый атрибут сообщает браузеру, что требуется ввод.-->
