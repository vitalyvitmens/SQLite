# TODO: Machine Learning (Машинное обучение)
#  Узнайте, как создавать интеллектуальные системы рекомендаций,
#  которые помогают нам в повседневной жизни.
#  Добро пожаловать в машинное обучение.

# TODO: Welcome to Machine Learning (Добро пожаловать в машинное обучение)
#  Поздравляем! Вы сделали большой шаг к тому, чтобы стать практиком машинного обучения!
#  В дополнение к прохождению этого курса не забудьте воспользоваться всей поддержкой обучения,
#  доступной вам на SoloLearn, включая ежедневные советы, практики «Попробуйте сами», задачи тренера по коду,
#  игровую площадку для кода и участие в нашем замечательном сообществе учащихся. Мы рады услышать от вас,
#  поэтому, пожалуйста, оставляйте комментарии и отзывы, когда вы учитесь с нами.
#  Python — это язык программирования, который мы будем использовать на протяжении всего курса.
#  Давайте начнем!

# TODO: Machine Learning Overview (Обзор машинного обучения)
#  Добро пожаловать на курс машинного обучения! Машинное обучение — это способ сбора данных и превращения их в идеи.
#  Мы используем мощность компьютера для анализа примеров из прошлого, чтобы построить модель,
#  которая может предсказать результат для новых примеров. Мы сталкиваемся с моделями машинного обучения каждый день.
#  Например, когда Netflix рекомендует вам шоу, они использовали модель, основанную на том,
#  что вы и другие пользователи смотрели, чтобы предсказать, что вы хотели бы.
#  Когда Amazon выбирает цену для товара, они используют модель,
#  основанную на том, как подобные товары продавались в прошлом.
#  Когда компания, выпустившая вашу кредитную карту, звонит вам из-за подозрительной активности,
#  она использует модель, основанную на вашей прошлой активности, для распознавания аномального поведения.
#  В этом курсе мы изучим несколько методов решения задач машинного обучения.
#  Машинное обучение можно использовать для создания чат-бота, обнаружения спама или распознавания изображений.

# TODO: Course Basics (Основы курса)
#  Одним из наиболее распространенных языков, используемых профессионалами в области машинного обучения, является Python
#  Это очень доступно и очень мощно, поэтому мы будем использовать его в этом курсе.
#  Мы предполагаем рабочее знание Python. В этом курсе мы будем использовать несколько пакетов Python,
#  которые помогут решить задачи машинного обучения. Мы будем использовать pandas, numpy, matplotlib и scikit-learn.
#  Pandas используется для чтения данных и обработки данных, numpy используется для вычисления числовых данных,
#  matplotlib используется для построения графиков данных, а scikit-learn используется для моделей машинного обучения.
#  Каждый из этих пакетов довольно обширен, но мы рассмотрим функции, которые будем использовать.
#  Мы также рассмотрим некоторые основные статистические данные, поскольку они являются основой машинного обучения.
#  Курс будет охватывать как теорию, так и практику методов машинного обучения, но сосредоточится на том,
#  как их использовать на реальных примерах.

# TODO: What's in this Course? (Что в этом курсе?)
#  В машинном обучении мы говорим о контролируемом и неконтролируемом обучении.
#  Обучение с учителем — это когда у нас есть известная цель на основе прошлых данных
#  (например, прогнозирование цены, по которой будет продаваться дом),
#  а обучение без учителя — это когда нет известного прошлого ответа
#  (например, определение тем, обсуждаемых в обзорах ресторанов).
#  В этом курсе мы сосредоточимся на контролируемом обучении.
#  В контролируемом обучении существуют проблемы классификации и регрессии.
#  Регрессия прогнозирует числовое значение (например, прогнозирует, по какой цене будет продаваться дом)
#  и классифицирует предсказывает, к какому классу что-либо принадлежит
#  (например, предсказывает, не выполнит ли заемщик дефолт по своему кредиту).
#  Мы сосредоточимся на проблемах классификации.
#  Это задачи, в которых мы предсказываем, к какому классу что-то принадлежит.
#  Наши примеры будут включать:
#  • Прогнозирование того, кто выживет при крушении «Титаника»
#  • Определение рукописной цифры по изображению
#  • Использование данных биопсии для определения злокачественности новообразования
#  Мы будем использовать ряд популярных методов для решения этих проблем.
#  Мы рассмотрим каждый из них более подробно в следующих модулях:
#  • Логистическая регрессия
#  • Деревья решений
#  • Случайные леса
#  • Нейронные сети
#  В конце этого курса вы сможете взять классификационный набор данных
#  и использовать Python для создания нескольких различных моделей,
#  чтобы определить лучшую модель для данной проблемы.
#  Машинное обучение можно использовать для решения широкого круга задач.
#  Этот курс будет посвящен контролируемому обучению и классификации.

# TODO: Averages (Средние значения)
#  При работе с данными нам часто нужно вычислить некоторые простые статистические данные.
#  Допустим, у нас есть список возрастов людей в классе.
#  Мы располагаем их в порядке возрастания, так будет проще производить расчеты.
#      15, 16, 18, 19, 22, 24, 29, 30, 34
# TODO: Среднее значение является наиболее известным средним значением.
#  Сложите все значения и разделите на количество значений:
#      (15 + 16 + 18 + 19 + 22 + 24 + 29 + 30 + 34) / 9 =  207/9 = 23
# TODO: Медиана — это значение посередине упорядоченных чисел.
#  В этом случае, поскольку имеется 9 значений, среднее значение 5-тое, то есть 22.
#  В статистике как среднее, так и медиана называются средними.
#  Среднее значение для непрофессионала является средним.

# TODO: Percentiles (процентили)
#  Медиану также можно рассматривать как 50-й процентиль.
#  Это означает, что 50% данных меньше медианы, а 50% данных больше медианы.
#  Это говорит нам, где находится середина данных, но нам часто требуется больше понимания распределения данных.
#  Мы часто будем рассматривать 25 -й процентиль и 75 -й процентиль.
#  25 - й процентиль — это значение, которое составляет одну четверть пути через данные.
#  Это значение, при котором 25% данных меньше его (а 75% данных больше его).
#  Точно так же 75 -й процентиль составляет три четверти пути через данные.
#  Это значение, при котором 75% данных меньше его (а 25% данных больше его).
#  Если мы снова посмотрим на наш возраст:
#      15, 16, 18, 19, 22, 24, 29, 30, 34
# TODO: У нас есть 9 значений, поэтому 25% данных будут составлять примерно 2 точки данных.
#  Таким образом, третья точка данных превышает 25% данных. Таким образом, 25-й процентиль равен 18 (3-я точка данных).
#  Точно так же 75% данных составляют примерно 6 точек данных. Таким образом, 7-я точка данных превышает 75% данных.
#  Таким образом, 75-й процентиль равен 29 (7-я точка данных).
#  Полный диапазон наших данных находится в диапазоне от 15 до 34.
#  25-й и 75-й процентили говорят нам, что половина наших данных находится в диапазоне от 18 до 29.
#  Это помогает нам понять, как распределяются данные.
#  Если имеется четное количество точек данных, чтобы найти медиану (или 50-й процентиль),
#  вы берете среднее значение двух значений в середине.

# TODO: Standard Deviation & Variance (Стандартное отклонение и дисперсия)
#  Мы можем получить более глубокое понимание распределения наших данных со стандартным отклонением и дисперсией.
#  Стандартное отклонение и дисперсия — это меры того, насколько разбросаны или рассредоточены данные.
#  Мы измеряем, насколько далеко каждая точка данных от среднего.
#  Давайте еще раз посмотрим на нашу возрастную группу:
#      15, 16, 18, 19, 22, 24, 29, 30, 34
# TODO: Напомним, что среднее равно 23. Давайте подсчитаем, насколько далеко каждое значение от среднего.
#  15 на 8 отличается от среднего (поскольку 23-15=8).
#  Вот список всех этих расстояний:
#      8, 7, 5, 4, 1, 1, 6, 7, 11
# TODO: Мы возводим эти значения в квадрат и складываем их вместе.
#  См. Рис: StandardDeviationPicture1.png
#  Мы делим это значение на общее количество значений, и это дает нам дисперсию.
#      362 / 9 = 40.22
# TODO: Чтобы получить стандартное отклонение, мы просто возьмем квадратный корень из этого числа и получим: 6.34
#  Если наши данные нормально распределены, как показано на графике ниже (См. Рис: StandardDeviationPicture2.png),
#  68% населения находится в пределах одного стандартного отклонения от среднего.
#  На графике мы выделили область в пределах одного стандартного отклонения от среднего значения.
#  Вы можете видеть, что заштрихованная область составляет около двух третей (точнее 68%) от общей площади под кривой.
#  Если мы предположим, что наши данные нормально распределены, мы можем сказать,
#  что 68% данных находятся в пределах 1 стандартного отклонения от среднего.
# TODO: В нашем примере с возрастом, хотя возрасты, вероятно, не совсем нормально распределены,
#  мы предполагаем, что это так, и говорим, что примерно 68% населения имеет возраст
#  в пределах одного стандартного отклонения от среднего. Поскольку среднее значение равно 23 годам,
#  а стандартное отклонение равно 6,34, мы можем сказать, что приблизительно 68% возрастов нашей популяции находятся
#  в диапазоне от 16,66 (23 минус 6,34) до 29,34 (23 плюс 6,34).
#  Несмотря на то, что данные никогда не бывают идеальным нормальным распределением,
#  мы все же можем использовать стандартное отклонение, чтобы получить представление о том, как распределяются данные.

# TODO: Statistics with Python (Статистика с Python)
#  Мы можем рассчитать все эти операции с помощью Python. Мы будем использовать пакет Python numpy.
#  Мы будем использовать numpy позже для работы с массивами, а сейчас мы просто будем использовать несколько функций
#  для статистических вычислений: mean, median, centile, std, var.
#  Сначала мы импортируем пакет. Стандартной практикой является псевдоним numpy как np.
#      import numpy as np
# TODO: Давайте инициализируем переменную data, чтобы иметь список возрастов.
#      data = [15, 16, 18, 19, 22, 24, 29, 30, 34]
# TODO: Теперь мы можем использовать функции numpy.
#  Для функций среднего, медианы, стандартного отклонения и дисперсии мы просто передаем список данных.
#  Для функции процентиля мы передаем список данных и процентиль (в виде числа от 0 до 100).
# import numpy as np
#
# data = [15, 16, 18, 19, 22, 24, 29, 30, 34]
#
# print("mean:", np.mean(data))
# print("median:", np.median(data))
# print("50th percentile (median):", np.percentile(data, 50))
# print("25th percentile:", np.percentile(data, 25))
# print("75th percentile:", np.percentile(data, 75))
# print("standard deviation:", np.std(data).round(2))
# print("variance:", np.var(data).round(2))
# TODO: Numpy — это библиотека Python, которая позволяет быстро и легко выполнять математические операции с массивами.

# TODO: What is Pandas? (Что такое Панды?)
#  Этот курс написан на Python, одном из наиболее часто используемых языков для машинного обучения.
#  Одна из причин, по которой он так популярен, заключается в том,
#  что существует множество полезных модулей Python для работы с данными.
#  Первый, который мы представим, называется Pandas.
#  Pandas — это модуль Python, который помогает нам читать данные и управлять ими.
#  Что хорошо в pandas, так это то, что вы можете брать данные и просматривать их в виде таблицы,
#  удобочитаемой для человека, но их также можно интерпретировать в числовом виде,
#  чтобы вы могли выполнять с ними множество вычислений. Мы называем таблицу данных DataFrame .
#  Python удовлетворит все наши потребности в машинном обучении.
#  Мы будем использовать модуль Pandas для обработки данных.

# TODO: Read in Your Data (Читать в ваших данных)
#  Нам нужно начать с импорта Pandas. Стандартной практикой является прозвище pd, чтобы потом быстрее печатать.
#      import pandas as pd
# TODO: Мы будем работать с набором данных пассажиров Титаника.
#  Для каждого пассажира у нас будут данные о нем, а также о том, выжили ли они в кораблекрушении.
#  Наши данные хранятся в виде файла CSV (значения, разделенные запятыми). Файл titanic.csv находится ниже.
#  Первая строка — это заголовок, а затем каждая последующая строка — это данные для одного пассажира.
#      Survived, Pclass, Sex, Age, Siblings/Spouses, Parents/Children, Fare
#      Выжившие, ПКласс, Пол, Возраст, Братья и сестры/супруги, Родители/Дети, Плата за проезд
#      0, 3, male, 22.0, 1, 0, 7.25
#      1, 1, female, 38.0, 1, 0, 71.2833
#      1, 3, female, 26.0, 0, 0, 7.925
#      1, 1, female, 35.0, 1, 0, 53.1
# TODO: Мы собираемся загружать данные в pandas, чтобы мы могли просматривать их как DataFrame.
#  Функция read_csv берет файл в формате csv и преобразует его в Pandas DataFrame.
#      df = pd.read_csv('titanic.csv')
# TODO: Объект df теперь является нашим фреймом данных pandas с набором данных Titanic.
#  Теперь мы можем использовать метод head для просмотра данных.
#  Метод head возвращает первые 5 строк DataFrame.
#      print(df.head())
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# print(df.head())
# TODO: Обычно данные хранятся в файлах CSV (значения, разделенные запятыми),
#  которые мы можем легко прочитать с помощью функции panda read_csv.
#  Метод head возвращает первые 5 строк.

# TODO: Summarize the Data (Суммарные данные)
#  Обычно наши данные слишком велики, чтобы мы могли отобразить их все.
#  Рассмотрение первых нескольких строк — это первый шаг к пониманию наших данных,
#  но затем мы хотим взглянуть на некоторую сводную статистику.
#  В пандах мы можем использовать метод описания describe().
#  Он возвращает таблицу статистики о столбцах.
#      print(df.describe())
# TODO: Мы добавляем строку в приведенный ниже код, чтобы заставить Python отображать все 6 столбцов.
#  Без линии это будет сокращать результаты.
# import pandas as pd
#
# pd.options.display.max_columns = 6
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# print(df.describe())
# TODO: Для каждого столбца мы видим несколько статистических данных.
#  Обратите внимание, что он дает статистику только для числовых столбцов.
#  Давайте рассмотрим, что означает каждая из этих статистических данных:
#  Count - это количество строк, которые имеют значение.
#  В нашем случае у каждого пассажира есть значение для каждого из столбцов,
#  поэтому значение равно 887 (общее количество пассажиров).
#  Среднее значение: Напомним, что среднее значение является стандартным средним значением.
#  Std : это сокращение от стандартного отклонения. Это мера того, насколько разбросаны данные.
#  Min : наименьшее значение
#  25% : 25-й процентиль
#  50% : 50-й процентиль, также известный как медиана.
#  75% : 75-й процентиль
#  Макс : наибольшее значение
#  Мы используем метод описания Pandas, чтобы начать интуитивно понимать наши данные.

# TODO: Selecting a Single Column (Выбор одного столбца)
#  Часто нам нужно иметь дело только с некоторыми столбцами, которые есть в нашем наборе данных.
#  Чтобы выбрать один столбец, мы используем квадратные скобки и имя столбца.
#  В этом примере мы выбираем только столбец с пассажирскими тарифами.
# col = df['Fare']
# print(col)
# TODO: Результатом является то, что мы называем Pandas Series.
#  Серия похожа на DataFrame, но это всего лишь один столбец.
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# col = df['Fare']
# print(col)
# TODO: Серия Pandas — это один столбец из Pandas DataFrame.

# TODO: Selecting Multiple Columns (Выбор нескольких столбцов)
#  Мы также можем выбрать несколько столбцов из нашего исходного DataFrame, создав меньший DataFrame.
#  Мы собираемся выбрать только столбцы Age, Sex и Survived из нашего исходного DataFrame.
#  Мы помещаем эти значения в список следующим образом:
#      ['Age', 'Sex', 'Survived']
# TODO: Теперь мы используем этот список внутри скобочной нотации df[...]
#  При печати большого DataFrame, который слишком велик для отображения,
#  вы можете использовать метод head для печати только первых 5 строк.
#     small_df = df[['Age', 'Sex', 'Survived']]
#     print(small_df.head())
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# small_df = df[['Age', 'Sex', 'Survived']]
# print(small_df.head())
# TODO: При выборе одного столбца из Pandas DataFrame мы используем одинарные квадратные скобки.
#  При выборе нескольких столбцов мы используем двойные квадратные скобки.

# TODO: Creating a Column (Создание столбца)
#  Мы часто хотим, чтобы наши данные были в несколько ином формате, чем они были изначально.
#  Например, наши данные имеют пол пассажира в виде строки («мужской» или «женский»).
#  Это легко прочитать человеку, но когда мы позже будем выполнять вычисления с нашими данными,
#  нам понадобятся логические значения (истина и ложь).
#  Мы можем легко создать новый столбец в нашем DataFrame, который имеет значение True,
#  если пассажир — мужчина, и False, если он — женщина.
#  Вспомните синтаксис выбора столбца «Пол»:
#      df['Sex']
# TODO: Мы создаем серию панд, которая будет серией истин и ложностей
#  (истина, если пассажир — мужчина, и ложь, если пассажир — женщина ).
# import pandas as pd
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# print(df['Sex'] == 'male')
# TODO: Теперь мы хотим создать столбец с этим результатом.
#  Чтобы создать новый столбец, мы используем тот же синтаксис квадратных скобок (df['male']),
#  а затем присваиваем ему это новое значение.
#      df['male'] = df['Sex'] == 'male'
# import pandas as pd
#
# pd.options.display.max_columns = 8
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
#
# df['male'] = df['Sex'] == 'male'
# print(df.head())
# # print(df[['Age', 'male', 'Survived']].tail())
# TODO: Наш фрейм данных теперь выглядит следующим образом.
#  Обратите внимание на новый столбец в конце. Часто наши данные не в идеальном формате.
#  К счастью, Pandas позволяет нам легко создавать новые столбцы на основе наших данных,
#  чтобы мы могли их соответствующим образом отформатировать.

# TODO: What is Numpy? (Что такое Нампи?)
#  Numpy — это пакет Python для управления списками и таблицами числовых данных.
#  Мы можем использовать его для выполнения большого количества статистических вычислений.
#  Мы называем список или таблицу данных массивом numpy.
#  Мы часто берем данные из нашего панда DataFrame и помещаем их в массивы numpy.
#  Pandas DataFrames великолепны, потому что у нас есть имена столбцов
#  и другие текстовые данные, которые делают их удобочитаемыми.
#  DataFrame, хотя и легко читается человеком, не является идеальным форматом для выполнения вычислений.
#  Массивы numpy, как правило, менее удобочитаемы для человека,
#  но имеют формат, позволяющий выполнять необходимые вычисления.
#  Numpy — это модуль Python для выполнения вычислений в таблицах данных.
#  На самом деле Pandas был построен с использованием Numpy в качестве основы.

# TODO: Converting from a Pandas Series to a Numpy Array (Преобразование из серии Pandas в массив Numpy)
#  Мы часто начинаем с наших данных в Pandas DataFrame, но затем хотим преобразовать их в массив numpy.
#  Атрибут values делает это за нас. Давайте преобразуем столбец Fare в пустой массив.
#  Сначала мы вспомним, что мы можем использовать нотацию с одной скобкой,
#  чтобы получить серию pandas в столбце Fare следующим образом.
#      df['Fare']
# TODO: Затем мы используем атрибут values, чтобы получить значения в виде массива numpy.
#      df['Fare'].values
# import pandas as pd
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# print(df['Fare'].values)
# print(df['Fare'].head().values)
# TODO: Вот как выглядит приведенный выше массив:
#      array([ 7.25 , 71.2833,  7.925, 53.1, 8.05, 8.4583, …
# TODO: В результате получается одномерный массив.
#  Вы можете сказать это, так как есть только один набор скобок,
#  и он расширяется только по странице (а не вниз).
#  Атрибут значений серии Pandas предоставляет данные в виде массива numpy.

# TODO: Converting from a Pandas DataFrame to a Numpy Array (Преобразование из Pandas DataFrame в массив Numpy)
#  Если у нас есть DataFrame pandas (вместо Series, как в прошлой части),
#  мы все еще можем использовать атрибут values, но он возвращает двумерный массив numpy.
#  Напомним, что мы можем создать меньший DataFrame pandas со следующим синтаксисом.
#      df[['Pclass', 'Fare', 'Age']]
# TODO: Опять же, мы применяем атрибут values, чтобы получить пустой массив.
#      df[['Pclass', 'Fare', 'Age']].values
# import pandas as pd
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# print(df[['Pclass', 'Fare', 'Age']].values)
# TODO: Вот как выглядит приведенный выше массив:
#      array([[ 3.    ,  7.25  , 22.    ],
#             [ 1.    , 71.2833, 38.    ],
#             [ 3.    ,  7.925 , 26.    ],
#                          ...           ,
#             [ 3.    , 23.45  ,  7.    ],
#             [ 1.    , 30.    , 26.    ],
#             [ 3.    ,  7.75  , 32.    ]])
# TODO: Это двумерный массив numpy. Вы можете сказать, потому что есть два набора скобок,
#  и они расширяются как по странице, так и вниз.
#  Атрибут значений Pandas DataFrame предоставляет данные в виде массива 2d numpy.

# TODO: Numpy Shape Attribute (Атрибут Numpy Форма)
#  Мы используем атрибут numpy форма, чтобы определить размер нашего массива numpy.
#  Размер говорит нам, сколько строк и столбцов в наших данных.
#  Во-первых, давайте создадим массив numpy с Pclass, Fare и Age.
#      arr = df[['Pclass', 'Fare', 'Age']].values
# TODO: Если мы посмотрим на форму, мы получим количество строк и количество столбцов:
#      print(arr.shape) #(887, 3)
# import pandas as pd
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# arr = df[['Pclass', 'Fare', 'Age']].values
# print(arr.shape)
# print(df.shape)
# TODO: Этот результат означает, что у нас есть 887 строк и 3 столбца.
#  Используйте атрибут shape, чтобы найти количество строк и количество столбцов для массива Numpy.
#  Вы также можете использовать атрибут формы в DataFrame pandas (df.shape).

# TODO: Select from a Numpy Array (Выберите из массива Numpy)
#  Предположим, мы создали следующий массив numpy:
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# arr = df[['Pclass', 'Fare', 'Age']].values
# # arr = df[['Pclass', 'Fare', 'Age']].tail(10).values
# print(arr)
# TODO: Мы можем выбрать один элемент из массива numpy следующим образом:
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# arr = df[['Pclass', 'Fare', 'Age']].values
# print(arr[0, 1])
# TODO: Это будет 2-й столбец 1-й строки (помните, что мы начинаем считать с 0 ).
#  Таким образом, это будет тариф 1-го пассажира или 7,25.
#  Мы также можем выбрать одну строку, например, весь ряд первого пассажира:
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# arr = df[['Pclass', 'Fare', 'Age']].values
# print(arr[0])
# # print(arr[0, :])
# TODO: Чтобы выбрать один столбец (в данном случае столбец «Возраст»), мы должны использовать специальный синтаксис:
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# arr = df[['Pclass', 'Fare', 'Age']].values
# print(arr[:, 2])
# TODO:
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# arr = df[['Pclass', 'Fare', 'Age']].values
# print(arr[0, 1])
# print(arr[0])
# print(arr[:, 2])
# TODO: Синтаксис можно интерпретировать так, что мы берем все строки, но только столбец с индексом 2.
#  Используя другой синтаксис в скобках, мы можем выбрать отдельные значения, всю строку или весь столбец.

# TODO: Masking (Маскировка)
#  Часто требуется выбрать все строки, соответствующие определенному критерию.
#  В этом примере мы выберем все строки детей (пассажиры младше 18 лет).
#  Напоминание о нашем определении массива:
#      arr = df[['Pclass', 'Fare', 'Age']].values
# TODO: Напомним, что мы можем получить столбец Age с помощью следующего синтаксиса:
#      arr[:, 2]
# TODO: Сначала мы создаем то, что мы называем маской.
#  Это массив логических значений (True/False), указывающих, является ли пассажир ребенком или нет.
#      mask = arr[:, 2] < 18
# TODO: Давайте посмотрим на массив маски, чтобы убедиться, что мы его понимаем.
#      array([False, False, False, False, False, False, False, True, False, …
# TODO: Значения False означают взрослого, а значения True — ребенка,
#  поэтому первые 7 пассажиров — взрослые, затем 8-й — ребенок, а 9-й — взрослый.
#  Теперь мы используем нашу маску, чтобы выбрать только нужные нам строки:
#      arr[mask]
# TODO: Давайте посмотрим на этот новый массив.
#      array([[3., 21.075, 2.],
#             [2., 30.0708, 14.],
#             [3., 16.7, 4.],
#             [3., 7.8542, 14.],
# TODO: Если мы вспомним, что третий столбец — это возраст пассажиров,
#  мы увидим, что все строки здесь — для пассажиров-детей.
#  Как правило, нам не нужно определять переменную маски, и мы можем сделать это всего в одной строке:
#      arr[arr[:, 2] < 18]
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# # take first 10 values for simplicity
# arr = df[['Pclass', 'Fare', 'Age']].values
#
# mask = arr[:, 2] < 18
# print(arr[mask])
# print(arr[arr[:, 2] < 18])
# TODO: Маска — это логический массив (значения True/False),
#  который сообщает нам, какие значения из массива нас интересуют.

# TODO: Summing and Counting (Суммирование и подсчет)
#  Допустим, мы хотим знать, сколько среди наших пассажиров детей.
#  У нас все еще есть то же определение массива,
#  и мы можем взять нашу маску или логические значения из предыдущей части.
#      arr = df[['Pclass', 'Fare', 'Age']].values
#      mask = arr[:, 2] < 18
# TODO: Напомним, что значения True интерпретируются как 1, а значения False интерпретируются как 0.
#  Таким образом, мы можем просто суммировать массив, и это эквивалентно подсчету количества истинных значений.
#      print(mask.sum())
# TODO: Опять же, мы можем не определять переменную маски.
#      print((arr[:, 2] < 18).sum())
# import pandas as pd
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# arr = df[['Pclass', 'Fare', 'Age', 'Survived', 'Sex']].values
# mask = arr[:, 2] < 18
#
# print(mask.sum())
# print((arr[:, 2] < 18).sum())
# print(((arr[:, 2] < 18) & (arr[:, 3] == 1)).sum())
# print(((arr[:, 2] < 18) & (arr[:, 3] == 1) & (arr[:, 4] == 'male')).sum())
# print(((arr[:, 2] < 18) & (arr[:, 3] == 1) & (arr[:, 4] == 'female')).sum())
# print(((arr[:, 2] < 18) & (arr[:, 3] == 1) & (arr[:, 4] != 'male')).sum())
# TODO: Суммирование массива логических значений дает количество значений True.

# TODO: Scatter Plot (Точечная диаграмма)
#  Мы можем использовать библиотеку matplotlib для построения графика наших данных.
#  Нанесение данных на график часто может помочь нам создать интуицию в отношении наших данных.
#  Сначала нам нужно импортировать matplotlib. Это стандартная практика называть его plt.
#      import matplotlib.pyplot as plt
# TODO: Мы используем функцию разброса для построения наших данных.
#  Первым аргументом функции рассеяния является ось x (горизонтальное направление),
#  а вторым аргументом — ось y (вертикальное направление).
#      plt.scatter(df['Age'], df['Fare'])
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# plt.scatter(df['Age'], df['Fare'])
# plt.savefig('ScatterPlot.png')
# plt.show()
# TODO: Это отображает возраст по оси x и стоимость проезда по оси y.
#  Чтобы упростить интерпретацию, мы можем добавить метки x и y.
#      plt.xlabel('Age')
#      plt.ylabel('Fare')
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# plt.scatter(df['Age'], df['Fare'])
# plt.xlabel('Age')
# plt.ylabel('Fare')
#
# plt.savefig('ScatterPlot.png')
# plt.show()
# TODO: Мы также можем использовать наши данные для цветового кодирования нашей диаграммы рассеивания.
#  Это даст каждому из 3 классов другой цвет. Мы добавляем параметр c и присваиваем ему серию Pandas.
#  В этом случае наш ряд Pandas имеет 3 возможных значения (1-й, 2-й и 3-й класс),
#  поэтому мы увидим, что наши точки данных получают один из трех цветов.
#      plt.scatter(df['Age'], df['Fare'], c=df['Pclass'])
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# plt.scatter(df['Age'], df['Fare'], c=df['Pclass'])
# # plt.scatter(df['Age'], df['Fare'], c=[df['Sex'] == 'male'])
# plt.xlabel('Age')
# plt.ylabel('Fare')
#
# plt.savefig('ScatterPlot.png')
# plt.show()
# TODO: Фиолетовые точки относятся к 1-первому классу,
#  зеленые точки ко 2-второму классу,
#  желтые точки к 3-третьему классу.
#  Точечная диаграмма используется для отображения всех значений ваших данных на графике.
#  Чтобы получить визуальное представление наших данных, мы должны ограничить наши данные двумя функциями.

# TODO: Line (Линия)
#  Теперь, когда мы можем поместить отдельные точки данных на график, давайте посмотрим, как нарисовать линию.
#  Функция plot делает именно это. Далее проводится линия, примерно отделяющая 1-й класс от 2-го и 3-го классов.
#  На глазок проведем линию от (0, 85) до (80, 5). Наш синтаксис ниже имеет список значений x и список значений y:
#      plt.plot([0, 80], [85, 5])
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# plt.scatter(df['Age'], df['Fare'], c=df['Pclass'])
# plt.plot([0, 80], [85, 5])
# plt.xlabel('Age')
# plt.ylabel('Fare')
#
# plt.savefig('ScatterPlot.png')
# plt.show()
# TODO: Вы можете видеть, что желтые (3-й класс) и зеленые (2-й класс) точки в основном находятся ниже линии,
#  а фиолетовые (1-й класс) — в основном выше.
#  Мы сделали это вручную, но в следующем модуле мы научимся делать это алгоритмически.
#  В matplotlib мы используем функцию scatter (рассеяния) для создания графика scatter
#  и функцию plot (график) для построения линии.

# TODO: ЗАДАЧА: Machine Learning - What's in a Column? (Машинное обучение — что в столбце?)
#  Получение столбца из массива numpy.
#  Задача Учитывая CSV-файл и имя столбца, распечатать элементы в данном столбце.
#  Формат ввода:
#  Первая строка: имя файла csv
#  Вторая строка: имя столбца
#  Формат вывода Массив Numpy
#  Sample Input:
#  https://sololearn.com/uploads/files/one.csv
#  a
#  File one.csv contents:
#  a,b
#  1,3
#  2,4
#  Sample Output:
#  [1 2]
#  Пояснение: a — это заголовок для первого столбца со значениями [1 2].
# import pandas as pd
#
# filename = input()
# column_name = input()
#
# df = pd.read_csv(filename)
# print(df[column_name].values)

# TODO: Where does Classification Fit in the World of Machine Learning?
#  (Какое место классификация Fit (занимает) в мире машинного обучения?)
#  Машинное обучение на высоком уровне состоит из контролируемого и неконтролируемого обучения.
#  Контролируемое обучение означает, что у нас будут помеченные исторические данные,
#  которые мы будем использовать для информирования нашей модели.
#  Мы называем ярлык или вещь, которую пытаемся предсказать - target (целью).
#  Таким образом, в контролируемом обучении есть известная цель для исторических данных,
#  а в неконтролируемом обучении нет известной цели.
#  В контролируемом обучении есть классификация и регрессия.
#  Проблемы классификации возникают, когда целью является категориальное значение
#  (часто True или False, но может быть несколько категорий).
#  Проблемы регрессии — это когда целью является числовое значение.
#  Например, прогнозирование цен на жилье — это проблема регрессии.
#  Это контролируется, так как у нас есть исторические данные о продажах домов в прошлом.
#  Это регрессия, потому что цена жилья является числовым значением.
#  Предсказание того, не выполнит ли кто-то дефолт по своему кредиту, является проблемой классификации.
#  Опять же, он находится под наблюдением, поскольку у нас есть исторические данные о дефолте прошлых кредиторов,
#  и это проблема классификации, потому что мы пытаемся предсказать,
#  относится ли кредит к одной из двух категорий (дефолт или нет).
#  Логистическая регрессия, хотя в ее названии есть регрессия,
#  представляет собой алгоритм решения задач классификации, а не проблем регрессии.

# TODO: Classification Terminology (Терминология классификации)
#  Давайте вернемся к нашему набору данных Титаника.
#  Вот снова Pandas DataFrame данные:
# import pandas as pd
#
# pd.options.display.max_columns = 7
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# print(df.head(5))
# TODO:
#  столбец Survived — это то, что мы пытаемся предсказать. Мы называем это целью.
#  Вы можете видеть, что это список из 1 и 0.
#  1 означает, что пассажир выжил, а 0 означает, что пассажир не выжил.
#  Остальные столбцы — это информация о пассажире, которую мы можем использовать для прогнозирования цели.
#  Мы называем каждый из этих столбцов feature (характеристика).
#  Характеристики — это данные, которые мы используем для прогнозирования.
#  Хотя мы знаем, выжил ли каждый пассажир в наборе данных,
#  мы хотели бы иметь возможность делать прогнозы о дополнительных пассажирах,
#  для которых мы не смогли собрать эти данные.
#  Мы построим модель машинного обучения чтобы помочь нам сделать это.
#  Иногда вы будете слышать характеристики, называемые предикторами.

# TODO: Classification Graphically (Классификация графически)
#  В конечном итоге мы захотим использовать все характеристики, но для простоты давайте начнем только
#  с двух характеристик Fare and Age (плата за проезд и возраст).
#  Использование двух характеристик позволяет нам визуализировать данные на графике.
#  По оси абсцисс (X) отложена стоимость проезда пассажира, а по оси ординат (Y) — его возраст.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# plt.scatter(df['Fare'], df['Age'], c=df['Survived'])
# plt.plot([32, 100], [0, 80])
# plt.xlabel('Fare')
# plt.ylabel('Age')
# plt.savefig('ScatterPlot.png')
# plt.show()
# TODO: Желтые точки — пассажиры, которые выжили, а фиолетовые точки — пассажиры, которые не выжили.
#  Вы можете видеть, что желтых точек внизу графика больше, чем вверху.
#  Это потому, что у детей было больше шансов выжить, чем у взрослых, что соответствует нашей интуиции.
#  Точно так же справа на графике больше желтых точек, что означает,
#  что люди, которые платили больше, имели больше шансов выжить.
# TODO: Задача линейной модели состоит в том, чтобы найти линию, которая наилучшим образом разделяет два класса так,
#  чтобы желтые точки находились с одной стороны, а фиолетовые — с другой. Вот пример хорошей линии:
#      plt.plot([32, 100], [0, 80])
#  Линия используется для прогнозирования появления новых пассажиров.
#  Если точка данных пассажира находится на правой стороне линии, мы прогнозируем, что он выживет.
#  Если на левой стороне, мы бы предсказали, что они не выжили.
#  Задача построения модели будет заключаться в том, чтобы определить наилучшую возможную линию.

# TODO: Equation for the Line (Уравнение для линии)
#  Линия определяется уравнением в следующем виде:
#      0 = ax + by + c
# TODO: Значения a, b и c являются коэффициентами. Любые три значения будут определять уникальную строку.
#  Давайте рассмотрим конкретный пример строки, где коэффициенты равны a=1, b=-1 и c=-30.
#      0 = (1)x + (-1)y + (-30)
# TODO: Вот три коэффициента: 1, -1, -30.
#  Вспомним, что мы наносили наши данные по оси x на тариф и по оси y на возраст пассажира.
#  Чтобы нарисовать прямую из уравнения, нам нужны две точки, лежащие на прямой.
#  Мы можем видеть, например, что точка (30, 0) лежит прямо на линии (Fare 30, Age 0).
#  Если мы подставим это в уравнение, оно сработает.
#      30 - 0 - 30 = 0
# TODO: Мы также можем видеть, что точка (50, 20) находится на линии (Fare 50, Age 20).
#      50 - 20 - 30 = 0
# TODO: Вот как наша линия выглядит на графике.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# plt.scatter(df['Fare'], df['Age'], c=df['Survived'])
# plt.plot([30, 50], [0, 20])
# plt.xlabel('Fare')
# plt.ylabel('Age')
# plt.savefig('ScatterPlot.png')
# plt.show()
# TODO: Коэффициенты линии определяют, где находится линия.

# TODO: Making a Prediction Based on the Line (Делаем предсказание на основе линии)
#  Давайте снова посмотрим на ту же строку.
#      0 = (1)x + (-1)y - 30
# TODO: Если мы возьмем данные о пассажирах, мы можем использовать это уравнение,
#  чтобы определить, на какую сторону линии они попадают.
#  Например, предположим, что у нас есть пассажир, тариф которого равен 100, а возраст 20.
#  Подставим эти значения в наше уравнение:
#      (1)100 + (-1)20 - 30 = 100 - 20 - 30 = 50
# TODO: Поскольку это значение положительное, точка находится на правой стороне линии,
#  и мы предполагаем, что пассажир выжил.
#  Теперь предположим, что тариф для пассажира равен 10, а его возраст равен 50 годам.
#  Подставим эти значения в уравнение.
#      (1)10 + (-1)50 - 30 = -70
# TODO: Поскольку это значение отрицательное, точка находится на левой стороне линии,
#  и мы предполагаем, что пассажир не выжил. Мы можем видеть эти две зеленые точки на графике ниже.
#  С какой стороны линии находится точка, зависит, по нашему мнению, выживет этот пассажир или нет.
# import pandas as pd
# import matplotlib.pyplot as plt
#
# df = pd.read_csv('https://sololearn.com/uploads/files/titanic.csv')
# plt.scatter(df['Fare'], df['Age'], c=df['Survived'])
# plt.plot([32, 100], [0, 80])
# plt.scatter([100, 10], [20, 50], c='g')
# plt.xlabel('Fare')
# plt.ylabel('Age')
# plt.savefig('ScatterPlot.png')
# plt.show()

# TODO: What Makes a Good Line? (Что делает линию хорошей?)
#  Давайте посмотрим на две разные линии. Сначала у нас есть линия, с которой мы работали до сих пор.
#  Назовем эту линию 1.
#      0 = (1)x + (-1)y - 30
# TODO: Далее у нас есть еще одно уравнение для линии.
#  Назовем эту линию 2.
#      0 = (4)x + (5)y - 400
# TODO: Если мы посмотрим на две линии, то увидим, что в строке 1 справа больше желтых точек, а слева больше фиолетовых.
#  У линии 2 не так много точек справа от нее; большинство фиолетовых и желтых точек слева.
#  Это делает линию 1 предпочтительной, поскольку она лучше разделяет желтые и фиолетовые точки.
#  Нам нужно математически определить эту идею, чтобы мы могли алгоритмически найти лучшую линию.
#  Логистическая регрессия — это способ математического поиска наилучшей линии.
